[{"content":"初始化配置 鼠标触控板 鼠标速度最大：Setting -\u0026gt; Mouse -\u0026gt; Tracking speed 调整到 Fast 轻点来点按：Setting -\u0026gt; Trackpad -\u0026gt; Tap to click 打开 三指拖移：Setting -\u0026gt; Accessibility -\u0026gt; Pointer Control -\u0026gt; Trackpad Options -\u0026gt; Use trackpad for dragging: true Dragging style: Three Finger Drag 关闭触发角：Setting -\u0026gt; Desktop \u0026amp; Dock -\u0026gt; 最下方右下角 Hot Corners,点开后设置所有为空 Homebrew (包管理) 确实无愧于自己的 slogan - The Missing Package Manager for macOS。\n软件管理必备了已经是。\n1 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 以上命令在国内环境下因为不可抗因素会执行失败，可以尝试使用手机热点进行下载（无需代理），或者也可以直接使用 Gitee 用户提供的代理来安装：\n1 /bin/zsh -c \u0026#34;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\u0026#34; 科学上网 网络是个拦路虎，首先需要先安装代理软件，否则只能在百度中看满屏的广告了。\n从 Clash Verge Rev 中下载最新版本，进行安装。\n获取最新版本下载地址之后，如果下载过慢，可以使用资源访问加速服务进行下载：gh.lcsk42.com\n该项目来自 hunshcn/gh-proxy\n对其前端页面进行修改之后，部署在了 Cloudflare Workers 上。\n无限感恩赛博佛祖 Cloudflare。\n按键映射 1 brew install --cask karabiner-elements 自定义按键转换，我一般常用的有两个：\nF1: CapsLock 转换为 Ctrl, CapsLock 占用了那么大的位置，但是用处不多（自带的键盘作用还比较多，外接键盘好像确实没有什么用处）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;description\u0026#34;: \u0026#34;Press caps_lock to activate as CTRL\u0026#34;, \u0026#34;manipulators\u0026#34;: [ { \u0026#34;from\u0026#34;: { \u0026#34;key_code\u0026#34;: \u0026#34;caps_lock\u0026#34;, \u0026#34;modifiers\u0026#34;: { \u0026#34;optional\u0026#34;: [\u0026#34;any\u0026#34;] } }, \u0026#34;to\u0026#34;: [{ \u0026#34;key_code\u0026#34;: \u0026#34;left_control\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;basic\u0026#34; } ] } F2: 将右 command 键转换为 F19, 主要是方便启动器，一般会把这个键位绑定到 Raycast 上替换 自带的 spotlight。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;description\u0026#34;: \u0026#34;Change right_command key to command+control+option+shift. (Post f19 key when pressed alone)\u0026#34;, \u0026#34;manipulators\u0026#34;: [ { \u0026#34;from\u0026#34;: { \u0026#34;key_code\u0026#34;: \u0026#34;right_command\u0026#34;, \u0026#34;modifiers\u0026#34;: { \u0026#34;optional\u0026#34;: [\u0026#34;any\u0026#34;] } }, \u0026#34;to\u0026#34;: [ { \u0026#34;key_code\u0026#34;: \u0026#34;left_shift\u0026#34;, \u0026#34;modifiers\u0026#34;: [\u0026#34;left_command\u0026#34;, \u0026#34;left_control\u0026#34;, \u0026#34;left_option\u0026#34;] } ], \u0026#34;to_if_alone\u0026#34;: [{ \u0026#34;key_code\u0026#34;: \u0026#34;f19\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;basic\u0026#34; } ] } 鼠标反转 1 brew install --cask mos 将鼠标滚动方向反转，并保留触控板方向不变。\nMac 的滚轮逻辑挺反人类的，刚开始尝试适应了一段时间，结果发现并不能适应，感谢 Mos 救我。\nBash 配置 iTerm2 仿真终端，替换自带的 Terminal，增加更多的主题和功能。\nMaple Mono 是最近非常喜欢的一个字体，在代码中大量的看会显得有点乱，但是在终端中使用很完美（可能是因为终端中的数据都比较规整，排排站的原因？）。\n1 brew install --cask iterm2 font-maple-mono-nf-cn 安装完成后设置字体：\nSetting -\u0026gt; Profiles -\u0026gt; Text -\u0026gt; Font: Maple Mono NF CN Regular 16 100 100\noh-my-zsh 很慢，但是目前暂时没有时间去寻找更好的替代品，所以咬咬牙，先继续使用。\n1 sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 如果上述命令执行失败，依旧可以尝试国内 Gitee 的代理：\n1 2 3 4 5 6 7 8 # 进入此页面复制脚本内容，创建文件 install.sh，粘贴进文件： https://gitee.com/mirrors/oh-my-zsh/blob/master/tools/install.sh # 替换地址 - REMOTE=${REMOTE:-https://github.com/${REPO}.git} + REMOTE=${REMOTE:-https://gitee.com/mirrors/oh-my-zsh.git} # 增加脚本权限，然后执行脚本即可 chmod +x ./install.sh ./install.sh 配置文件(.zshrc)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # Alias alias vi=vim alias v=vim # alias cat=bat alias n=neofetch alias lg=lazygit alias ,o=\u0026#34;open .\u0026#34; alias ,c=\u0026#34;code .\u0026#34; alias sz=\u0026#34;source ~/.zshrc\u0026#34; alias cdtmp=\u0026#39;cd `mktemp -d /tmp/lucas-XXXXXXXX`\u0026#39; alias hosts=\u0026#34;sudo vim /etc/hosts\u0026#34; alias tail=tailspin alias weather=\u0026#34;clear \u0026amp; curl https://v2d.wttr.in/zhengzhou\u0026#34; function mcd { mkdir $1 \u0026amp;\u0026amp; cd $1 } function ppgrep() { if [[ $1 == \u0026#34;\u0026#34; ]]; then FZF=fzf else FZF=\u0026#34;fzf -q $1\u0026#34; fi ps aux | eval $FZF | awk \u0026#39;{ print $2 }\u0026#39; } function ppkill() { if [[ $1 =~ \u0026#34;^-\u0026#34; ]]; then QUERY=\u0026#34;\u0026#34; # options only else QUERY=$1 # with a query [[ $# \u0026gt; 0 ]] \u0026amp;\u0026amp; shift fi ppgrep $QUERY | xargs kill $* } p10k 也是一个用的比较习惯的主题了。\n1 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git \u0026#34;${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\u0026#34; 国内可以使用以下命令替换\n1 git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git \u0026#34;${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k\u0026#34; 打开 ~/.zshrc,找到 ZSH_THEME, 替换为 powerlevel10k/powerlevel10k 即可。\ndotfile .gitconfig 个人 git 相关配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 cat \u0026gt; ~/.gitconfig \u0026lt;\u0026lt; EOF [push] default = current autoSetupRemote = true [user] name = lcsk42 email = lcsk42@gmail.com [core] pager = diff-so-fancy | less --tabs=4 -RFX [interactive] diffFilter = diff-so-fancy --patch [color] ui = true [color \u0026#34;diff-highlight\u0026#34;] oldNormal = red bold oldHighlight = red bold 52 newNormal = green bold newHighlight = green bold 22 [color \u0026#34;diff\u0026#34;] meta = 11 frag = magenta bold func = 146 bold commit = yellow bold old = red bold new = green bold whitespace = red reverse [init] defaultBranch = main EOF .gitignore_global 全局的 git 忽略类型\n1 2 3 4 5 6 7 8 9 10 cat ~/.gitignore_global \u0026lt;\u0026lt; EOF *~ .DS_Store .idea .vscode .nvm target/ *.iml /out/ EOF .tmux.conf tmux 基础配置（类 vim）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 cat \u0026gt; ~/.tmux.conf \u0026lt;\u0026lt; EOF # -- general ------------------------------------------------------------------- set -g default-terminal \u0026#34;screen-256color\u0026#34; # colors! setw -g xterm-keys on set -s escape-time 10 # faster command sequences set -sg repeat-time 600 # increase repeat timeout set -q -g status-utf8 on # expect UTF-8 (tmux \u0026lt; 2.2) setw -q -g utf8 on set -g history-limit 5000 # boost history # -- display ------------------------------------------------------------------- set -g base-index 1 # start windows numbering at 1 setw -g pane-base-index 1 # make pane numbering consistent with windows setw -g automatic-rename on # rename window to reflect current program set -g renumber-windows on # renumber windows when a window is closed set -g set-titles on # set terminal title set -g display-panes-time 800 # slightly longer pane indicators display time set -g display-time 1000 # slightly longer status messages display time set -g status-interval 10 # redraw status line every 10 seconds # clear both screen and history bind -n C-l send-keys C-l \\; run \u0026#39;sleep 0.1\u0026#39; \\; clear-history # activity set -g monitor-activity on set -g visual-activity off # -- nvigation ---------------------------------------------------------------- # create session bind C-c new-session # find session bind C-f command-prompt -p find-session \u0026#39;switch-client -t %%\u0026#39; # split current window horizontally bind - split-window -v # split current window vertically bind _ split-window -h # pane navigation bind -r h select-pane -L # move left bind -r j select-pane -D # move down bind -r k select-pane -U # move up bind -r l select-pane -R # move right bind \u0026gt; swap-pane -D # swap current pane with the next one bind \u0026lt; swap-pane -U # swap current pane with the previous one #pane resizing bind -r H resize-pane -L 2 bind -r J resize-pane -D 2 bind -r K resize-pane -U 2 bind -r L resize-pane -R 2 # window navigation unbind n unbind p bind -r C-h previous-window # select previous window bind -r C-l next-window # select next window bind Tab last-window # move to last active window EOF Chrome 配置 开发必备了，事实上的前端标准，无数的封装，一个用户的电脑中实际安装可能高达几十个的运行环境。\n1 brew install --cask google-chrome 使用 google 账号进行数据同步。\n插件 Aria2 Explorer 地址： https://chromewebstore.google.com/detail/aria2-explorer/mpkodccbngfoacfalldjimigbofkhgjn?hl=en\n功能： 配合下载软件(aria2c)一起使用\n直接使用打包好的 docker 镜像进行安装： Aria2 Pro - 更好用的 Aria2 Docker 容器镜像\n参照提供的 docker-compose.yml 示例，根据需要修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 services: Aria2-Pro: container_name: aria2-pro image: p3terx/aria2-pro environment: - PUID=65534 - PGID=65534 - UMASK_SET=022 - RPC_SECRET=P3TERX - RPC_PORT=6800 - LISTEN_PORT=6888 - DISK_CACHE=128M - IPV6_MODE=false - UPDATE_TRACKERS=true - CUSTOM_TRACKER_URL= - TZ=Asia/Shanghai volumes: - ${PWD}/aria2-config:/config - ${HOME}/Downloads:/downloads network_mode: host restart: unless-stopped logging: driver: json-file options: max-size: 1m Immersive Translate - Translate Web \u0026amp; PDF 地址： https://chromewebstore.google.com/detail/immersive-translate-trans/bpoadfkcbjbfhfodiogcnhhhpibjhbnh?hl=en\n功能： 真 - 沉浸式翻译\nProxy SwitchyOmega 3 (ZeroOmega) 地址： https://chromewebstore.google.com/detail/proxy-switchyomega-3-zero/pfnededegaaopdmhkdmcofjmoldfiped?hl=en\n功能： 处理不同网站之间的代理\nRule List:\n1 https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt Memo 地址： https://chromewebstore.google.com/detail/memo/chgfencjlhmjhmnnpnlnchglkkdcipii?hl=en\n功能： 配合 GitHub 仓库，将搜藏的页面存储到一个仓库中\nJSON Formatter 地址： https://chromewebstore.google.com/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa?hl=en\n功能： 格式化 JSON 数据\nI still don\u0026rsquo;t care about cookies 地址： https://chromewebstore.google.com/detail/i-still-dont-care-about-c/edibdbjcniadpccecjdfdjjppcpchdlm?hl=en\n功能： 如题\nBiliPlus - Bilibili 加大杯，细节从大杯做起 地址： https://chromewebstore.google.com/detail/biliplus-bilibili-%E5%8A%A0%E5%A4%A7%E6%9D%AF%EF%BC%8C%E7%BB%86%E8%8A%82%E4%BB%8E/liddcdcjkpeaiblhebgihpmcaknpgbgk?hl=en\n功能： B 站优化\nB 站空降助手 地址： https://chromewebstore.google.com/detail/b%E7%AB%99%E7%A9%BA%E9%99%8D%E5%8A%A9%E6%89%8B/eaoelafamejbnggahofapllmfhlhajdd?hl=en\n功能： B 站优化\n油猴脚本 AC-baidu-google_sogou_bing_RedirectRemove_favicon_adaway_TwoLine 地址:https://greasyfork.org/en/scripts/14178-ac-baidu-%E9%87%8D%E5%AE%9A%E5%90%91%E4%BC%98%E5%8C%96%E7%99%BE%E5%BA%A6%E6%90%9C%E7%8B%97%E8%B0%B7%E6%AD%8C%E5%BF%85%E5%BA%94%E6%90%9C%E7%B4%A2-favicon-%E5%8F%8C%E5%88%97\nEndless Google 地址:https://greasyfork.org/en/scripts/41041-endless-google-fork\nAuto Skip YouTube Ads 地址:https://greasyfork.org/en/scripts/498197-auto-skip-youtube-ads\nPixiv Plus 地址：https://greasyfork.org/en/scripts/34153-pixiv-plus\nVS Code 配置 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 { \u0026#34;editor.cursorBlinking\u0026#34;: \u0026#34;solid\u0026#34;, \u0026#34;editor.cursorStyle\u0026#34;: \u0026#34;block\u0026#34;, \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;Default Light+\u0026#34;, \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Hack Nerd Font Mono\u0026#39;, Monaco, \u0026#39;Courier New\u0026#39;, monospace\u0026#34;, \u0026#34;editor.fontSize\u0026#34;: 18, \u0026#34;editor.fontLigatures\u0026#34;: true, \u0026#34;editor.tabSize\u0026#34;: 2, \u0026#34;editor.tabCompletion\u0026#34;: \u0026#34;on\u0026#34;, \u0026#34;editor.renderWhitespace\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;editor.rulers\u0026#34;: [80], \u0026#34;editor.suggestSelection\u0026#34;: \u0026#34;first\u0026#34;, \u0026#34;editor.wordWrap\u0026#34;: \u0026#34;wordWrapColumn\u0026#34;, \u0026#34;editor.wordWrapColumn\u0026#34;: 120, \u0026#34;editor.bracketPairColorization.independentColorPoolPerBracketType\u0026#34;: true, \u0026#34;window.restoreWindows\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;files.autoSave\u0026#34;: \u0026#34;onFocusChange\u0026#34;, \u0026#34;files.defaultLanguage\u0026#34;: \u0026#34;javascript\u0026#34;, \u0026#34;files.trimTrailingWhitespace\u0026#34;: true, \u0026#34;files.exclude\u0026#34;: { \u0026#34;**/.git\u0026#34;: true, \u0026#34;**/.svn\u0026#34;: true, \u0026#34;**/.hg\u0026#34;: true, \u0026#34;**/CVS\u0026#34;: true, \u0026#34;**/.DS_Store\u0026#34;: true, \u0026#34;**/Thumbs.db\u0026#34;: true, \u0026#34;**/.gitignore\u0026#34;: true, \u0026#34;**/package-lock.json\u0026#34;: true }, \u0026#34;files.eol\u0026#34;: \u0026#34;\\n\u0026#34;, \u0026#34;terminal.external.osxExec\u0026#34;: \u0026#34;iTerm.app\u0026#34;, \u0026#34;terminal.integrated.fontSize\u0026#34;: 14, \u0026#34;terminal.integrated.fontFamily\u0026#34;: \u0026#34;Maple Mono NF CN\u0026#34;, \u0026#34;http.proxy\u0026#34;: \u0026#34;http://127.0.0.1:7890\u0026#34;, \u0026#34;workbench.activityBar.location\u0026#34;: \u0026#34;hidden\u0026#34; } 插件 Error lens Better Comments Bookmarks Code Spell Checker 小软件大提升 Raycast 官网地址: https://www.raycast.com//\n安装方式:\n1 brew install --cask raycast 核心功能: 软件启动器\n辅助功能: 历史剪切板等\nBark 官网地址: https://bark.day.app/#/\n安装方式: App Store 直接安装\n核心功能: 消息提醒，基于 Apple 的推送渠道，可以实现不运行软件就可以接受消息\nKeepingYouAwake 官网地址: https://keepingyouawake.app/\n安装方式: App Store 直接安装\n核心功能: 可以保持屏幕常亮。功能单一但好用。完美的遵循 Unix 哲学中的 KISS(Keep it simple, stupid) 原则\nRunCat 官网地址: https://kyome.io/runcat/?lang=en\n安装方式: App Store 直接安装\n核心功能: 小猫可爱捏。会在状态栏显示一只奔跑的小猫，系统负载越大，跑得越快。也可以点开看一些系统资源的具体使用信息\nInputSourcePro 官网地址: https://inputsource.pro/\n安装方式:\n1 brew install --cask input-source-pro 核心功能: 为不同的程序设置不同的默认打开输入法\n文件目录定义 使用 kebab-case 风格进行命名。\n/Document /lcsk42.github.io /container /code /com.lcsk42 /com.skybeyondtech /script /jebra /navicat-premium-reset-trial 开发相关 Back-end Java 安装 jdk\n1 brew install jenv openjdk@21 openjdk@17 mvn jenv: java 版本管理 jdk：开发必备 mvn: 包管理 Front-end IntelliJ IDEA: 吃饭的软件 Navicat: 数据库连接软件 Wireshark: 网络抓包 沟通娱乐 WeChat： 国内必备 Telegram：拓宽视野 IINA：Mac 下最好的本地视频播放器 ","date":"2025-04-29T15:07:31+08:00","permalink":"https://www.lcsk42.com/post/macos-setup/","title":"Macos Setup"},{"content":"CompletableFuture 是 Java 8 引入的增强版异步编程工具，它在 Future 的基础上做了重大改进，用于更优雅、更灵活地处理异步任务、回调链式操作、组合多个异步任务等。\n为什么会冒出个 CompletableFuture 先来回答一个关键问题：为什么会有 CompletableFuture？既然 Java 专门搞了这么个新工具，肯定是因为老的方式不够好用，甚至在实际开发中会让人抓狂。\n在 Java 8 之前，我们处理异步任务主要靠 Future 接口，比如在线程池中提交一个任务，代码大概是这样的：\n1 2 Future\u0026lt;String\u0026gt; future = executor.submit(() -\u0026gt; \u0026#34;hello\u0026#34;); String result = future.get(); // 阻塞等待结果 看着挺朴素的代码，其实问题不少：\nget() 是阻塞的：任务没执行完，调用方就只能干等，完全不是我们想要的“异步” 没有回调机制：任务完成之后，不能自动触发后续操作，只能主动去问它“你好了没” 不能链式组合多个异步任务：比如 A 完成后继续执行 B，Future 根本做不到 异常处理很笨重：要靠开发者自己 try-catch，还没法像流水线一样优雅地传递异常 没法聚合多个 Future 的结果：比如等 A 和 B 都完成后再执行 C？不好意思，不支持 于是，Java 8 推出了 CompletableFuture，一次对异步能力的全面升级。从命名上就能看出它的野心：这是一个可以“被主动完成”的未来，不再是等待，而是掌控。\n它不仅支持非阻塞调用，还有完善的回调机制、链式任务组合、异常处理流转，以及多个任务的聚合能力。\n简而言之，CompletableFuture 把异步这件事，从“能用”提升到了“好用”，不止是更强大，而是更适合写出清晰、优雅、可维护的异步代码。\nCompletableFuture 的方法 CompletableFuture 对象的方法非常非常多，如何了解和记忆是个老大难了，这里推荐使用分组、对比的方式进行记忆。\n创建方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 创建一个已完成的 Future public static \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; completedFuture(U value) { } // 无返回值、默认线程池（ForkJoinPool.commonPool()） public static CompletableFuture\u0026lt;Void\u0026gt; runAsync(Runnable runnable) { } // 无返回值、自定义线程池 public static CompletableFuture\u0026lt;Void\u0026gt; runAsync(Runnable runnable, Executor executor) { } // 有返回值、默认线程池（ForkJoinPool.commonPool()） public static \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; supplyAsync(Supplier\u0026lt;U\u0026gt; supplier) { } // 有返回值、自定义线程池 public static \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; supplyAsync(Supplier\u0026lt;U\u0026gt; supplier, Executor executor) { } 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 CompletableFuture\u0026lt;String\u0026gt; completedFuture = CompletableFuture .completedFuture(\u0026#34;CompletableFuture (with the given value)\u0026#34;); CompletableFuture\u0026lt;Void\u0026gt; runAsyncFuture = CompletableFuture.runAsync(() -\u0026gt; { System.out.println(\u0026#34;Running async task (with default executor)\u0026#34;); }); CompletableFuture\u0026lt;Void\u0026gt; runAsyncFuture = CompletableFuture.runAsync(() -\u0026gt; { System.out.println(\u0026#34;Running async task with custom executor\u0026#34;); }, executor); CompletableFuture\u0026lt;String\u0026gt; supplyAsyncFuture = CompletableFuture.supplyAsync(() -\u0026gt; { return \u0026#34;Result of the computation (with default executor)\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; supplyAsyncFuture = CompletableFuture.supplyAsync(() -\u0026gt; { return \u0026#34;Result of the computation with custom executor\u0026#34;; }, executor); 结果处理对比 转换类方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 同步转换结果 public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenApply( Function\u0026lt;? super T,? extends U\u0026gt; fn) { } // 异步转换结果(默认线程池) public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenApplyAsync( Function\u0026lt;? super T,? extends U\u0026gt; fn) { } // 异步转换结果(指定线程池) public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenApplyAsync( Function\u0026lt;? super T,? extends U\u0026gt; fn, Executor executor) { } 示例：\n1 2 3 4 5 6 CompletableFuture\u0026lt;Integer\u0026gt; lengthFuture = supplyAsyncFuture.thenApply(s -\u0026gt; s.length()); CompletableFuture\u0026lt;Integer\u0026gt; lengthFuture = supplyAsyncFuture.thenApplyAsync(s -\u0026gt; s.length()); CompletableFuture\u0026lt;Integer\u0026gt; lengthFuture = supplyAsyncFuture.thenApplyAsync(s -\u0026gt; s.length(), executor); 消费类方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 同步消费结果 public CompletableFuture\u0026lt;Void\u0026gt; thenAccept(Consumer\u0026lt;? super T\u0026gt; action) { } // 异步消费结果(默认线程池) public CompletableFuture\u0026lt;Void\u0026gt; thenAcceptAsync(Consumer\u0026lt;? super T\u0026gt; action) { } // 异步消费结果(指定线程池) public CompletableFuture\u0026lt;Void\u0026gt; thenAcceptAsync(Consumer\u0026lt;? super T\u0026gt; action, Executor executor) { } // 同步执行无参操作 public CompletableFuture\u0026lt;Void\u0026gt; thenRun(Runnable action) { } // 异步执行无参操作(默认线程池) public CompletableFuture\u0026lt;Void\u0026gt; thenRunAsync(Runnable action) { } // 异步执行无参操作(指定线程池) public CompletableFuture\u0026lt;Void\u0026gt; thenRunAsync(Runnable action, Executor executor) { } 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 supplyAsyncFuture.thenAccept(result -\u0026gt; System.out.println(\u0026#34;Received: \u0026#34; + result) ); supplyAsyncFuture.thenAcceptAsync(result -\u0026gt; System.out.println(\u0026#34;Received: \u0026#34; + result) ); supplyAsyncFuture.thenAcceptAsync(result -\u0026gt; System.out.println(\u0026#34;Received: \u0026#34; + result), executor ); supplyAsyncFuture.thenRun(() -\u0026gt; System.out.println(\u0026#34;Task completed\u0026#34;) ); supplyAsyncFuture.thenRunAsync(() -\u0026gt; System.out.println(\u0026#34;Task completed\u0026#34;) ); supplyAsyncFuture.thenRunAsync(() -\u0026gt; System.out.println(\u0026#34;Task completed\u0026#34;), executor ); 组合方法对比 双 Future 组合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // 合并两个结果，并返回新的 CompletableFuture public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenCompose( Function\u0026lt;? super T, ? extends CompletionStage\u0026lt;U\u0026gt;\u0026gt; fn) { } public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenComposeAsync( Function\u0026lt;? super T, ? extends CompletionStage\u0026lt;U\u0026gt;\u0026gt; fn) { } public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; thenComposeAsync( Function\u0026lt;? super T, ? extends CompletionStage\u0026lt;U\u0026gt;\u0026gt; fn, Executor executor) { } // 消费两个 Future 的结果 public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; thenAcceptBoth( CompletionStage\u0026lt;? extends U\u0026gt; other, BiConsumer\u0026lt;? super T, ? super U\u0026gt; action) { } public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; thenAcceptBothAsync( CompletionStage\u0026lt;? extends U\u0026gt; other, BiConsumer\u0026lt;? super T, ? super U\u0026gt; action) { } public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;Void\u0026gt; thenAcceptBothAsync( CompletionStage\u0026lt;? extends U\u0026gt; other, BiConsumer\u0026lt;? super T, ? super U\u0026gt; action, Executor executor) { } // 两个都完成后执行操作 public CompletableFuture\u0026lt;Void\u0026gt; runAfterBoth(CompletionStage\u0026lt;?\u0026gt; other, Runnable action) { } public CompletableFuture\u0026lt;Void\u0026gt; runAfterBothAsync(CompletionStage\u0026lt;?\u0026gt; other, Runnable action) { } public CompletableFuture\u0026lt;Void\u0026gt; runAfterBothAsync(CompletionStage\u0026lt;?\u0026gt; other, Runnable action, Executor executor) { } 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 CompletableFuture\u0026lt;String\u0026gt; supplyAsyncFuture1 = CompletableFuture.supplyAsync(() -\u0026gt; { return \u0026#34;R1\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; supplyAsyncFuture2 = CompletableFuture.supplyAsync(() -\u0026gt; { return \u0026#34;R2\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; result = supplyAsyncFuture1.thenCombine(supplyAsyncFuture2, (r1, r2) -\u0026gt; String.format(\u0026#34;%s | %s\u0026#34;, r1, r2) ); result.thenAccept(System.out::println); supplyAsyncFuture1.thenAcceptBoth(supplyAsyncFuture2, (r1, r2) -\u0026gt; System.out.println(\u0026#34;%s | %s\u0026#34;, r1, r2) ); CompletableFuture\u0026lt;String\u0026gt; runAsyncFuture1 = CompletableFuture.runAsync(() -\u0026gt; { System.out.println(\u0026#34;run task 1\u0026#34;) }); CompletableFuture\u0026lt;String\u0026gt; runAsyncFuture2 = CompletableFuture.runAsync(() -\u0026gt; { System.out.println(\u0026#34;run task 2\u0026#34;) }); runAsyncFuture1.runAfterBoth(runAsyncFuture2, () -\u0026gt; System.out.println(\u0026#34;run task. \u0026#34;) ); 多 Future 组合 1 2 3 4 5 6 7 // 所有 Future 完成后完成 public static CompletableFuture\u0026lt;Void\u0026gt; allOf(CompletableFuture\u0026lt;?\u0026gt;... cfs) { } // 任意一个 Future 完成后完成 public static CompletableFuture\u0026lt;Object\u0026gt; anyOf(CompletableFuture\u0026lt;?\u0026gt;... cfs) { } 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 创建三个异步任务 CompletableFuture\u0026lt;String\u0026gt; task1 = CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;R1\u0026#34;); CompletableFuture\u0026lt;String\u0026gt; task2 = CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;R2\u0026#34;); CompletableFuture\u0026lt;String\u0026gt; task3 = CompletableFuture.supplyAsync(() -\u0026gt; \u0026#34;R3\u0026#34;); // 等待所有任务完成 CompletableFuture\u0026lt;Void\u0026gt; allFutures = CompletableFuture.allOf(task1, task2, task3); // 所有完成后获取结果 allFutures.thenRun(() -\u0026gt; { try { System.out.println(\u0026#34;T1 Result: \u0026#34; + task1.get()); System.out.println(\u0026#34;T2 Result: \u0026#34; + task2.get()); System.out.println(\u0026#34;T3 Result: \u0026#34; + task3.get()); } catch (Exception e) { e.printStackTrace(); } }); // 模拟不同响应时间的服务 CompletableFuture\u0026lt;String\u0026gt; fastService = CompletableFuture.supplyAsync(() -\u0026gt; { sleep(100); // 模拟100ms延迟 return \u0026#34;Fast service response\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; mediumService = CompletableFuture.supplyAsync(() -\u0026gt; { sleep(300); return \u0026#34;Medium service response\u0026#34;; }); CompletableFuture\u0026lt;String\u0026gt; slowService = CompletableFuture.supplyAsync(() -\u0026gt; { sleep(500); return \u0026#34;Slow service response\u0026#34;; }); // 获取最先响应的服务 CompletableFuture\u0026lt;Object\u0026gt; firstResponse = CompletableFuture.anyOf( fastService, mediumService, slowService ); firstResponse.thenAccept(result -\u0026gt; System.out.println(\u0026#34;The first results: \u0026#34; + result) ); // 可能输出: \u0026#34;The first results: Fast service response\u0026#34; 异常处理对比 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 捕获异常并返回默认值 public CompletableFuture\u0026lt;T\u0026gt; exceptionally( Function\u0026lt;Throwable, ? extends T\u0026gt; fn) { } // 无论成功失败都会执行 public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; handle( BiFunction\u0026lt;? super T, Throwable, ? extends U\u0026gt; fn) { } public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; handleAsync( BiFunction\u0026lt;? super T, Throwable, ? extends U\u0026gt; fn) { } public \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; handleAsync( BiFunction\u0026lt;? super T, Throwable, ? extends U\u0026gt; fn, Executor executor) { } // 无论成功失败都会执行，不影响结果 public CompletableFuture\u0026lt;T\u0026gt; whenComplete( BiConsumer\u0026lt;? super T, ? super Throwable\u0026gt; action) { } public CompletableFuture\u0026lt;T\u0026gt; whenCompleteAsync( BiConsumer\u0026lt;? super T, ? super Throwable\u0026gt; action) { } public CompletableFuture\u0026lt;T\u0026gt; whenCompleteAsync( BiConsumer\u0026lt;? super T, ? super Throwable\u0026gt; action, Executor executor) { } 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 CompletableFuture.supplyAsync(() -\u0026gt; { if (Math.random() \u0026gt; 0.5) { throw new RuntimeException(\u0026#34;Error\u0026#34;); } return \u0026#34;Success\u0026#34;; }) .exceptionally(ex -\u0026gt; { System.out.println(\u0026#34;Exception: \u0026#34; + ex.getMessage()); return \u0026#34;Recovered\u0026#34;; }) .thenAccept(System.out::println); CompletableFuture.supplyAsync(() -\u0026gt; { return \u0026#34;Result\u0026#34;; }) .handle((result, ex) -\u0026gt; { if (ex != null) { return \u0026#34;Default value\u0026#34;; } return result; }); CompletableFuture.supplyAsync(() -\u0026gt; { if (new Random().nextBoolean()) { throw new RuntimeException(\u0026#34;Error\u0026#34;); } return \u0026#34;Success\u0026#34;; }) .whenComplete((result, ex) -\u0026gt; { if (ex != null) { log.error(\u0026#34;Error\u0026#34;, ex); metrics.increment(\u0026#34;failures\u0026#34;); } else { log.info(\u0026#34;Result: {}\u0026#34;, result); metrics.increment(\u0026#34;success\u0026#34;); } }) .thenAccept(System.out::println); 总结 方法名中的 Async 后缀，代表异步执行\n参数列表中的 Executor 表示可以自定义线程池，如果不自定义，则使用默认线程池(ForkJoinPool.commonPool())\n创建阶段的两个方法：[run|supply](Async)\nrun: 无返回值 supple: 有返回值 结果处理阶段三个关键字 then[Apply|Accept|Run](Async)\napply: Function\u0026lt;T,R\u0026gt; 接收一个参数，处理后返回结果 accept: Consumer\u0026lt;T\u0026gt; 接收一个参数，不返回 run: Runnable 不接受参数，不返回 组合多个分为两类，两个组合和多个组合\n两个组合 then[Compose|AcceptBoth](Async) 和 runAfterBoth(Async)\ncompose: Function\u0026lt;T,R\u0026gt; 合并两个结果，处理后返回结果 acceptBoth: BiConsumer\u0026lt;T, U\u0026gt; 消费两个结果，不返回 runAfterBoth: Runnable 不接受参数，不返回 多个组合 [all|any]Of\nall: 所有 Future 完成后完成 any: 任意一个 Future 完成后完成 异常处理分为三部分 exceptionally handle(Async) 和 whenComplete(Async)\nexceptionally: Function\u0026lt;Throwable, T\u0026gt; 接收异常为参数，处理后返回一个值 handle: BiFunction\u0026lt;T, Throwable, U\u0026gt; 可以得到异常和结果后，重新返回一个结果 whenComplete: BiConsumer\u0026lt;T, Throwable\u0026gt; 可以得到异常和返回值，不对结果进行处理 注意： handle 和 whenComplete 比较特殊，无论是否发生异常，都会处理（类似 finally)\n","date":"2025-04-23T15:26:47+08:00","permalink":"https://www.lcsk42.com/post/completable-future/","title":"CompletableFuture"},{"content":"Software List 为了方便新电脑和重装系统时（心理洁癖，当我觉得电脑特别乱时，就特别想把所有清空重置一下，干净的电脑可以给我一种干净的感觉？）可以快速恢复环境，记录一下自己使用到的软件。\nCLI brew: The Missing Package Manager for macOS (or Linux) 1 2 # The following commands need to be executed one by one. /bin/zsh -c \u0026#34;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\u0026#34; Brew act: Run your GitHub Actions locally axel: Light UNIX download accelerator bat: Clone of cat(1) with syntax highlighting and Git integration docker: Pack, ship and run any application as a lightweight container docker-compose: Isolated development environments using Docker docker-completion: Bash, Zsh and Fish completion for Docker fzf: Command-line fuzzy finder written in Go hugo: Configurable static site generator jenv: Manage your Java environment jq: Lightweight and flexible command-line JSON processor just: Handy way to save and run project-specific commands lima: Linux virtual machines nvm: Manage multiple Node.js versions openjdk@17: Development kit for the Java programming language openjdk@21: Development kit for the Java programming language mvn: Java-based project management tmux: Terminal multiplexer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 brew install \\ act \\ axel \\ bat \\ docker \\ docker-compose \\ docker-completion \\ fzf \\ hugo \\ jenv \\ jq \\ just \\ lima \\ nvm \\ openjdk@17 \\ openjdk@21 \\ mvn \\ tmux CLI Configuration .gitconfig 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 cat \u0026gt; ~/.gitconfig \u0026lt;\u0026lt; EOF [push] default = current autoSetupRemote = true [user] name = lcsk42 email = lcsk42@gmail.com [core] pager = diff-so-fancy | less --tabs=4 -RFX [interactive] diffFilter = diff-so-fancy --patch [color] ui = true [color \u0026#34;diff-highlight\u0026#34;] oldNormal = red bold oldHighlight = red bold 52 newNormal = green bold newHighlight = green bold 22 [color \u0026#34;diff\u0026#34;] meta = 11 frag = magenta bold func = 146 bold commit = yellow bold old = red bold new = green bold whitespace = red reverse [init] defaultBranch = main EOF .gitignore_global 1 2 3 4 5 6 7 8 9 10 cat ~/.gitignore_global \u0026lt;\u0026lt; EOF *~ .DS_Store .idea .vscode .nvm target/ *.iml /out/ EOF .justfile 1 2 3 4 cat \u0026gt; ~/.justfile \u0026lt;\u0026lt; EOF default: @echo \u0026#34;\\033[31mAlready at user home directory; no recipes available.\\033[0m\u0026#34; EOF .tmux.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 cat \u0026gt; ~/.tmux.conf \u0026lt;\u0026lt; EOF # -- general ------------------------------------------------------------------- set -g default-terminal \u0026#34;screen-256color\u0026#34; # colors! setw -g xterm-keys on set -s escape-time 10 # faster command sequences set -sg repeat-time 600 # increase repeat timeout set -q -g status-utf8 on # expect UTF-8 (tmux \u0026lt; 2.2) setw -q -g utf8 on set -g history-limit 5000 # boost history # -- display ------------------------------------------------------------------- set -g base-index 1 # start windows numbering at 1 setw -g pane-base-index 1 # make pane numbering consistent with windows setw -g automatic-rename on # rename window to reflect current program set -g renumber-windows on # renumber windows when a window is closed set -g set-titles on # set terminal title set -g display-panes-time 800 # slightly longer pane indicators display time set -g display-time 1000 # slightly longer status messages display time set -g status-interval 10 # redraw status line every 10 seconds # clear both screen and history bind -n C-l send-keys C-l \\; run \u0026#39;sleep 0.1\u0026#39; \\; clear-history # activity set -g monitor-activity on set -g visual-activity off # -- nvigation ---------------------------------------------------------------- # create session bind C-c new-session # find session bind C-f command-prompt -p find-session \u0026#39;switch-client -t %%\u0026#39; # split current window horizontally bind - split-window -v # split current window vertically bind _ split-window -h # pane navigation bind -r h select-pane -L # move left bind -r j select-pane -D # move down bind -r k select-pane -U # move up bind -r l select-pane -R # move right bind \u0026gt; swap-pane -D # swap current pane with the next one bind \u0026lt; swap-pane -U # swap current pane with the previous one #pane resizing bind -r H resize-pane -L 2 bind -r J resize-pane -D 2 bind -r K resize-pane -U 2 bind -r L resize-pane -R 2 # window navigation unbind n unbind p bind -r C-h previous-window # select previous window bind -r C-l next-window # select next window bind Tab last-window # move to last active window EOF .vimrc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 cat \u0026gt; ~/.vimrc \u0026lt;\u0026lt; EOF +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ \u0026#34; Open file type detection filetype on \u0026#34; Load the corresponding plugin according to the detected different types filetype plugin on \u0026#34; Always show the status bar set laststatus=2 \u0026#34; Display the current position of the cursor set ruler \u0026#34; Turn on line number display set number \u0026#34; Highlight current row/column set cursorline \u0026#34; set cursorcolumn \u0026#34; Highlight search results set hlsearch \u0026#34; Prohibition of folding set nowrap \u0026#34; Turn on syntax highlighting syntax enable \u0026#34; Allows replacement of default schemes with the specified syntax highlighting scheme syntax on \u0026#34; Adaptive smart indentation in different languages filetype indent on \u0026#34; Extend tabs to spaces set expandtab \u0026#34; Set tabs to occupy spaces when editing set tabstop=2 \u0026#34; Set the number of spaces occupied by tabs when formatting set shiftwidth=2 \u0026#34; Let vim treat a continuous number of spaces as a tab set softtabstop=2 \u0026#34; Code folding based on indentation or grammar \u0026#34;set foldmethod=indent set foldmethod=syntax \u0026#34; Turn off folding code when starting vim set nofoldenable EOF GUI App Store Bark: Bark is a push notification tool app KeepingYouAwake: Prevents your Mac from going to sleep RunCat: The cat tells you the CPU usage of Mac by running speed Brew Cask Raycast: Control your tools with a few keystrokes iTerm2: Terminal emulator as alternative to Apple\u0026rsquo;s Terminal app Google Chrome: Web browser Wireshark: Network analyzer and capture tool - without graphical user interface IINA: Free and open-source media player Input Source Pro: Tool for multi-language users Mos: Smooths scrolling and set mouse scroll directions independently WeChat: Free messaging and calling application Discord: Voice and text chat software Telegram: Messaging app with a focus on speed and security Karabiner-ElementsKeyboard customiser OBS: Open-source software for live streaming and screen recording Visual Studio Code: Open-source code editor 1 2 3 4 5 6 7 8 9 10 11 12 13 brew install --cask \\ iterm2 \\ google-chrome \\ wireshark \\ iina \\ input-source-pro \\ mos \\ wechat \\ telegram \\ discord \\ karabiner-elements \\ obs \\ visual-studio-code GUI Configuration karabiner-elements\u0026rsquo;s Complex Modifications F1:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;description\u0026#34;: \u0026#34;Change right_command key to command+control+option+shift. (Post f19 key when pressed alone)\u0026#34;, \u0026#34;manipulators\u0026#34;: [ { \u0026#34;from\u0026#34;: { \u0026#34;key_code\u0026#34;: \u0026#34;right_command\u0026#34;, \u0026#34;modifiers\u0026#34;: { \u0026#34;optional\u0026#34;: [\u0026#34;any\u0026#34;] } }, \u0026#34;to\u0026#34;: [ { \u0026#34;key_code\u0026#34;: \u0026#34;left_shift\u0026#34;, \u0026#34;modifiers\u0026#34;: [\u0026#34;left_command\u0026#34;, \u0026#34;left_control\u0026#34;, \u0026#34;left_option\u0026#34;] } ], \u0026#34;to_if_alone\u0026#34;: [{ \u0026#34;key_code\u0026#34;: \u0026#34;f19\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;basic\u0026#34; } ] } F2:\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;description\u0026#34;: \u0026#34;Press caps_lock to activate as CTRL\u0026#34;, \u0026#34;manipulators\u0026#34;: [ { \u0026#34;from\u0026#34;: { \u0026#34;key_code\u0026#34;: \u0026#34;caps_lock\u0026#34;, \u0026#34;modifiers\u0026#34;: { \u0026#34;optional\u0026#34;: [\u0026#34;any\u0026#34;] } }, \u0026#34;to\u0026#34;: [{ \u0026#34;key_code\u0026#34;: \u0026#34;left_control\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;basic\u0026#34; } ] } ","date":"2025-03-20T14:24:22+08:00","permalink":"https://www.lcsk42.com/post/software-list/","title":"软件列表"},{"content":"什么是 MQ MQ（Message Queue，消息队列）是一种用于在分布式系统中传递消息的通信机制。它允许应用程序通过发送和接收消息来进行异步通信，常用于解耦系统组件、提高可扩展性和可靠性。\n为什么使用 MQ 解耦 异步 削峰 AMQP 和 JMS AMQP（高级消息队列协议）和 JMS（Java 消息服务）是两种常见的消息传递协议和 API，用于分布式系统中的消息通信。\nAMQP（Advanced Message Queuing Protocol） 定义：AMQP 是一个开放标准的应用层协议，用于消息中间件，支持跨平台和跨语言的消息传递。 特点： 跨平台：支持多种编程语言和操作系统。 互操作性：不同厂商的实现可以互相通信。 灵活性：支持多种消息模式，如点对点、发布/订阅。 可靠性：提供消息确认、持久化等机制，确保消息可靠传递。 应用场景：适用于需要跨平台、跨语言的高可靠性和互操作性的场景。 JMS（Java Message Service） 定义：JMS 是 Java 平台上的 API，用于消息中间件，提供消息创建、发送、接收和读取的功能。 特点： Java 专属：主要用于 Java 应用程序。 标准化：定义了通用的接口和语义，具体实现由不同厂商提供。 消息模式：支持点对点（Queue）和发布/订阅（Topic）两种模式。 事务支持：支持事务性消息传递。 应用场景：适用于 Java 应用程序，尤其是需要标准化消息传递接口的场景。 主要区别 语言支持：AMQP 是多语言的，JMS 是 Java 专属。 协议 vs API：AMQP 是协议，JMS 是 API。 互操作性：AMQP 强调不同实现的互操作性，JMS 则依赖于具体实现。 总结 AMQP：适合需要跨平台、跨语言的高可靠性和互操作性的场景。 JMS：适合 Java 应用程序，尤其是需要标准化消息传递接口的场景。 RabbitMQ 是基于 AMQP 协议开发的。\n相关概念 Message 消息。消息是不具名的，它由消息头消息体组成。\n消息体是不透明的，而消息头则由一系列可选属性组成，这些属性包括：\nrouting-key(路由键)、 priority(相对于其他消息的优先权)、 delivery-mode(指出消息可能持久性存储) 等 Publisher(P) 消息的生产者。\n也是一个向交换器发布消息的客户端应用程序。\nConsumer(C) 消息的消费者。\n表示一个从消息队列中取得消息的客户端应用程序。\nExchange(X) 交换器。用来接收生产者发送的消息并将这些消息路由给服务器中的队列。\n三种常用的交换器类型\ndirect(发布与订阅 完全匹配) fanout(广播) topic(主题，规则匹配) 命名：小写字母，使用下划线 _ 分隔不同的单词，避免使用连字符 -\n([direct|fanout|topic]_exchange_(biz_name)) 如 direct_exchange_payment\nBinding 绑定。\n用于消息队列和交换器之间的关联。\n一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。\nQueue(Q) 消息队列。用来保存消息直到发送给消费者。\n它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者链接到这个队列将其取走。\n命名：小写字母，使用下划线 _ 分隔不同的单词，应该包括描述其用途的关键字\nqueue_(biz_name) 如 queue_payment\nRouting-key 路由键。RabbitMQ 决定消息该投递到哪个队列的规则。\n队列通过路由键绑定到交换器。\n消息发送到 MQ 服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ 也会将其和绑定使用的路由键进行匹配。\n如果相匹配，消息将会投递到该队列。 如果不匹配，消息将会进入黑洞。 命名：小写字母，使用点号 . 分隔不同的路由关键字，路由键结构可以反映消息类型、来源、目的地等\nroute.(biz_name).(adv.) 如 route.payment.success\nConnection 链接。\n指 rabbit 服务器和服务建立的 TCP 链接。\nChannel 信道。\nChannel 中文叫做信道，是 TCP 里面的虚拟链接。例如：电缆相当于 TCP，信道是一个独立光纤束，一条 TCP 连接上创建多条信道是没有问题的。 TCP 一旦打开，就会创建 AMQP 信道。 无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。 Virtual Host 虚拟主机。表示一批交换器，消息队列和相关对象。\n虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在链接时指定，RabbitMQ 默认的 vhost 是 /\n命名：小写字母，使用短划线 - 或下划线 _ 分隔不同的部分\n如：/dev /production /test\nBroker 表示消息队列服务器实体。\n交换器和队列的关系 交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的路由键匹配，那么消息就会被路由到该绑定的队列中。\n也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器在通过路由键匹配分发消息到具体的队列中。路由键可以理解为匹配的规则。\nRabbitMQ 为什么需要信道，为什么不是 TCP 直接通信 TCP 的创建和销毁开销特别大。创建需要 3 次握手，销毁需要 4 次分手。 如果不用信道，那应用程序就会以 TCP 链接 Rabbit，高峰时每秒成千上万条链接会造成资源巨大的浪费，而且操作系统每秒处理 TCP 链接数也是有限制的，必定造成性能瓶颈。 信道的原理是一条线程一条通道，多条线程多条通道同用一条 TCP 链接。一条 TCP 链接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能的瓶颈。 权限(Admin) User 用户权限 总的有三个部分，分开描述\nP1 (当前登录角色) P2 (当前已存在角色) Name: 登录名 Tags: 权限 Can Access Virtual hosts: 可以访问的 host Has Password: 是否有密码 P3 (新增角色) Username: 用户名 Password: 密码，可以下拉选择 [No Password], 不推荐 Tags: 权限标签 其中用户标签（tags）用于定义用户的权限和角色。不同的标签赋予用户不同的操作权限。\nAdmin（完全控制） 权限: 允许用户执行所有管理操作。 功能: 管理用户、虚拟主机、权限、策略等，拥有最高权限。 Monitoring（查看监控信息） 权限: 允许用户查看 RabbitMQ 的状态和监控信息。 功能: 查看节点、连接、通道、队列等的状态，但不能修改配置或管理用户。 Policymaker（管理策略） 权限: 允许用户创建和管理策略（policies）。 功能: 定义队列和交换机的行为规则，如镜像队列、TTL 等，但不能管理用户或虚拟主机。 Management（访问管理界面） 权限: 允许用户访问和管理 RabbitMQ 的管理插件（Web UI 和 HTTP API）。 功能: 查看和管理队列、交换机、绑定、用户等，但不能修改配置或执行管理员操作。 Impersonator（模拟其他用户） 权限: 允许用户模拟其他用户进行操作。 功能: 主要用于调试和测试，模拟其他用户的权限执行操作。 None（仅基本操作） 权限: 无特殊权限。 功能: 用户只能执行基本的消息生产和消费操作，不能进行管理或监控。 Virtual Hosts 什么是 virtual host 可以类比数据库中的库，彼此之间做业务隔离。\n新增参数：\nName: 名称 Description: 描述信息 Tags: 分类，如 env:production, env:dev, team:frontend, team:backend Default Queue Type: 默认队列类型 (TODO: 解释不通队列的区别) Classic Quorum Stream 如何分配 Virtual Hosts 在上一小节的 User P2 部分，点击 Name 列即可进入人员信息编辑页面，在详情页面编辑即可。\n消息类型 Hello Word 最简单的模型：\n1 P -\u0026gt; Q -\u0026gt; C Worker queues 1 2 3 | -\u0026gt; C1 P -\u0026gt; Q -\u0026gt;| -\u0026gt; C2 | -\u0026gt; C3 Worker queues 模型只有一个工作队列，是一种竞争消费模式。\n同一个消息队列中绑定了多个消费者，多个消费者争抢着消费消息，可以有效的避免消息堆积问题。\nPublish/Subscribe 1 2 3 | -\u0026gt; Q1 -\u0026gt; C1 P -\u0026gt; X -\u0026gt;| | -\u0026gt; Q2 -\u0026gt; C2 发送消息的时候没有指明 routing key 或者是指明了，但是所有消费者都知道，大家都能收到消息，就像广播一样。\nRouting 1 2 3 4 5 | - error -------\u0026gt; Q1 -\u0026gt; C1 | P -\u0026gt; X(type=direct) -\u0026gt;| - info ---\u0026gt; | | - error --\u0026gt; | -\u0026gt; Q2 -\u0026gt; C2 | - warning -\u0026gt;| exchange 接收到生产者消息后，将消息交给 routing key 完全匹配的消息队列，消费者根据指定的 routing key 来消费消息。\nTopic 1 2 3 4 | - *.orange.* --- --\u0026gt; Q1 -\u0026gt; C1 | P -\u0026gt; X(type=topic) -\u0026gt;| - *.*.rabbit -\u0026gt; | | - lazy.# -----\u0026gt; | -\u0026gt; Q2 -\u0026gt; C2 类似于上方的 Routing，区别是 Topic 的 routing key 支持通配符。\nRPC 本质是服务调用了，不作为服务消息模型进行过多介绍了。\nSpringBoot 如何使用 配置类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.CustomExchange; import org.springframework.amqp.core.DirectExchange; import org.springframework.amqp.core.FanoutExchange; import org.springframework.amqp.core.HeadersExchange; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.TopicExchange; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQConfiguration { // 定义常量并报漏，方便后续 P 和 C 使用 // Exchange public static final String DIRECT_EXCHANGE_BIZ = \u0026#34;direct_exchange_biz\u0026#34;; public static final String FANOUT_EXCHANGE_BIZ = \u0026#34;fanout_exchange_biz\u0026#34;; public static final String TOPIC_EXCHANGE_BIZ = \u0026#34;topic_exchange_biz\u0026#34;; public static final String HEADERS_EXCHANGE_BIZ = \u0026#34;headers_exchange_biz\u0026#34;; public static final String CUSTOM_EXCHANGE_BIZ = \u0026#34;custom_exchange_biz\u0026#34;; // Queue public static final String QUEUE_BIZ_ALL = \u0026#34;queue_biz_all\u0026#34;; public static final String QUEUE_BIZ_SUCCESS = \u0026#34;queue_biz_success\u0026#34;; public static final String QUEUE_BIZ_FAILURE = \u0026#34;queue_biz_failure\u0026#34;; // Topic public static final String ROUTE_BIZ_ALL = \u0026#34;route.biz.*\u0026#34;; public static final String ROUTE_BIZ_SUCCESS = \u0026#34;route.biz.success\u0026#34;; public static final String ROUTE_BIZ_FAILURE = \u0026#34;route.biz.failure\u0026#34;; // Exchange =================\u0026gt; @Bean public DirectExchange directExchange() { return ExchangeBuilder.directExchange(DIRECT_EXCHANGE_BIZ).build(); } @Bean public FanoutExchange fanoutExchange() { return ExchangeBuilder.fanoutExchange(FANOUT_EXCHANGE_BIZ).build(); } @Bean public TopicExchange topicExchange() { return ExchangeBuilder.topicExchange(TOPIC_EXCHANGE_BIZ).build(); } /** * 是基于消息头部（headers）进行路由的交换机。 * 假设你有多个消费者处理不同类型的消息， * 你可以通过给每个消息添加不同的头信息（比如 messageType）， * 然后根据 messageType 来决定消息投递给哪个队列 */ @Bean public HeadersExchange headersExchange() { return ExchangeBuilder.headersExchange(HEADERS_EXCHANGE_BIZ).build(); } /** * 定义类型的交换机。 * 如果你想要实现一个根据自定义规则处理消息的交换机， * 或者你希望实现不同的路由算法， * 可以创建一个 CustomExchange， * 让它具备自己特定的处理逻辑 */ @Bean public CustomExchange customExchange() { return new CustomExchange(CUSTOM_EXCHANGE_BIZ, \u0026#34;x-custom-type\u0026#34;); } // Queue =================\u0026gt; @Bean public Queue bizAll() { return QueueBuilder.nonDurable(QUEUE_BIZ_ALL).build(); } @Bean public Queue bizSuccess() { return QueueBuilder.nonDurable(QUEUE_BIZ_SUCCESS).build(); } @Bean public Queue bizFailure() { return QueueBuilder.nonDurable(QUEUE_BIZ_FAILURE).build(); } // Binding =================\u0026gt; // 使用路由规则，将 Q 绑定到 X // BindingBuilder.bind(bizAll).to(topicExchange).with(ROUTE_BIZ_ALL) // bind: 必须，绑定的是那个消息队列 // to: 可选，默认情况下会是 AMQP_DEFAULT_EXCHANGE, 但在大多数情况下需要显式地定义交换机 // with: 可选，只有在需要进行路由（如 direct 或 topic 类型的交换机）时才是必需的， // 对于 fanout 类型的交换机，路由键是不需要的 @Bean public Binding bindingBizAllToTopicExchange(TopicExchange topicExchange, Queue bizAll) { return BindingBuilder.bind(bizAll).to(topicExchange).with(ROUTE_BIZ_ALL); } @Bean public Binding bindingBizSuccessToTopicExchange(TopicExchange topicExchange, Queue bizSuccess) { return BindingBuilder.bind(bizSuccess).to(topicExchange).with(ROUTE_BIZ_SUCCESS); } @Bean public Binding bindingBizFailureToTopicExchange(TopicExchange topicExchange, Queue bizFailure) { return BindingBuilder.bind(bizFailure).to(topicExchange).with(ROUTE_BIZ_SUCCESS); } } 消费者类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; @Slf4j @Component // 指定需要消费的 Queue 即可 @RabbitListener(queues = RabbitMQConfiguration.QUEUE_BIZ_ALL) public class RabbitConsumer { @RabbitHandler public void receive(String message) { log.info(\u0026#34;receive message: {}\u0026#34;, message); } } 生产者类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import com.lcsk42.mqrabbit.publisher.config.RabbitMQConfiguration; import lombok.RequiredArgsConstructor; import org.springframework.amqp.rabbit.connection.CorrelationData; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.stereotype.Component; import java.util.UUID; @Component @RequiredArgsConstructor public class RabbitProducer { private final RabbitTemplate rabbitTemplate; public void send(Object object) { rabbitTemplate.convertAndSend( // exchange: 如果你使用的是非默认交换机（如 Fanout、Direct 或 Topic），就需要指定交换机名称 RabbitMQConfiguration.TOPIC_EXCHANGE_BIZ, // routingKey: 如果你使用的是 Direct 或 Topic 类型的交换机， // 你就需要根据交换机的配置和消息路由规则来指定 routingKey， // 以确保消息被正确路由到对应的队列 RabbitMQConfiguration.ROUTE_BIZ_SUCCESS, // 消息对象 object, // 唯一标识 new CorrelationData(UUID.randomUUID().toString()) ); } } 可靠投递(消息丢失) 1 P -\u0026gt; MQ -\u0026gt; C 整个过程中三个节点都有可能丢失消息。针对三种情况，给出以下不同的解决方案。\nP (生产者) 丢失消息的解决方法 发送数据前开启 RabbitMQ 的事务（由于事务机制，会导致吞吐量下降，严重消耗性能，不推荐） 开启 confirm 模式（异步，推荐） 事务机制是同步的，提交之后会阻塞， confirm 机制是异步的，发送消息之后可以继续发送另一个消息， RabbitMQ 接收到消息之后会异步调用 confirm 接口通知消息收到。\n如何开启 confirm 模式：\n配置文件需要增加配置项：\n1 2 3 spring: publisher-confirm-type: correlated publisher-returns: true 消息生产者需要实现响应接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 import jakarta.annotation.PostConstruct; import lombok.RequiredArgsConstructor; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.ReturnedMessage; import org.springframework.amqp.rabbit.connection.CorrelationData; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.stereotype.Component; import java.util.UUID; @Slf4j @Component @RequiredArgsConstructor public class AckPublisher implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback { private final RabbitTemplate rabbitTemplate; @PostConstruct public void init() { rabbitTemplate.setConfirmCallback(this); rabbitTemplate.setReturnsCallback(this); } /** * ConfirmCallback 机制用于确认消息是否到达 exchange * * @param correlationData 唯一标识 * @param ack 确认结果 * @param cause 失败原因 */ @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) { // TODO: 消息入库或者警告提醒 log.error(\u0026#34;ConfirmCallback =\u0026gt; CorrelationData: {}, ack: {}, cause: {}\u0026#34;, correlationData, ack, cause); } /** * ReturnsCallback 机制用于处理一个不可路由的消息 * * @param returnedMessage 不可路由的消息 */ @Override public void returnedMessage(ReturnedMessage returnedMessage) { // TODO: 消息入库或者警告提醒 log.error(\u0026#34;ReturnsCallback =\u0026gt; ReturnedMessage: {}\u0026#34;, returnedMessage); } public void sendMessageToExchangeFail(String msg) { // 发送一个消息，发送到不存在的 exchange rabbitTemplate.convertAndSend( // 不存在的 exchange \u0026#34;exchange_unknown\u0026#34;, // 存在的 route \u0026#34;route\u0026#34;, msg, // 唯一标识 new CorrelationData(UUID.randomUUID().toString()) ); // 未到 exchange 确认 //: ConfirmCallback =\u0026gt; // CorrelationData: CorrelationData [id=82891c14-0691-4008-8425-4e4d27db3229], // ack: false, // cause: channel error; // // protocol method: #method\u0026lt;channel.close\u0026gt;( // reply-code=404, // reply-text=NOT_FOUND - no exchange \u0026#39;exchange_unknown\u0026#39; in vhost \u0026#39;/\u0026#39;, // class-id=60, // method-id=40 // ) } public void sendMessageToQueueFail(String msg) { // 发送一个消息，发送到不存在的 queue rabbitTemplate.convertAndSend( // 存在的 exchange \u0026#34;exchange\u0026#34;, // 不存在的 route \u0026#34;route_unknown\u0026#34;, msg, // 唯一标识 new CorrelationData(UUID.randomUUID().toString()) ); // exchange 确认了，但是找不到合适的路由 //: ReturnsCallback =\u0026gt; ReturnedMessage: ReturnedMessage [ // message=( // Body:\u0026#39;ack-queue\u0026#39; // MessageProperties [ // headers={spring_returned_message_correlation=c90946d5-02be-4a29-b60d -22a151436125}, // contentType=text/plain, // contentEncoding=UTF-8, // contentLength=0, // receivedDeliveryMode=PERSISTENT, // priority=0, // deliveryTag=0 // ] // ), // replyCode=312, // replyText=NO_ROUTE, // exchange=exchange, // routingKey=route_unknown // ] // //: ConfirmCallback =\u0026gt; // CorrelationData: CorrelationData [id=c90946d5-02be-4a29-b60d-22a151436125], // ack: true, // cause: null } } MQ (消息队列) 丢失消息的解决方案 创建 exchange 时候设置为持久化，exchange 和 queue 都是持久化的，那么它们之间的 binding 也是持久化的，只有两个都持久化了，才允许建立绑定。 创建 queue 时设置为持久化，这样可以保证 RabbitMQ 持久化 queue 的元数据，但是并不会持久化 queue 中的数据 发送消息时将消息的 deliveryMode 设置为持久化，此时 queue 中的消息才会持久化到磁盘 同时设置了 queue 和 message 的持久化后，RabbitMQ 挂掉再重启后，会从磁盘恢复 queue，确保数据不会丢失。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 持久化 Exchange @Bean public FanoutExchange durableExchange() { // durable: 是否持久化 // autoDelete: 自动删除，如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于临时队列 return ExchangeBuilder.fanoutExchange(\u0026#34;durable_exchange_biz\u0026#34;).durable(true).build(); } // 持久化 Queue @Bean public Queue durableQueue() { // durable: 是否持久化 return QueueBuilder.durable(\u0026#34;queue_biz_durable\u0026#34;).build(); } // 绑定 @Bean public Binding bindingDurableQueueToDurableExchange(FanoutExchange durableExchange, Queue durableQueue) { return BindingBuilder.bind(durableQueue).to(durableExchange); } // convertAndSend 不需要做操作，默认就是持久化的 // MessageProperties.deliveryMode = MessageDeliveryMode.PERSISTENT C (消费者) 丢失消息的解决方案 关闭自动 ACK, 使用手动 ACK。\n默认情况下消费者收到消息，RabbitMQ 会自动提交 ACK，之后这条消息就不会发送给消费者了。\n修改为手动 ACK，每次处理完消息，再手动 ACK 一下。这样可能会导致没有手动 ACK，消费者挂了，导致消息被重复消费，不过这种情况下做好幂等就可以了，重复消费也不会造成问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.annotation.RabbitHandler; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.amqp.support.AmqpHeaders; import org.springframework.messaging.handler.annotation.Header; import org.springframework.stereotype.Component; import java.io.IOException; import java.time.LocalDateTime; import java.util.concurrent.TimeUnit; @Slf4j @Component @RabbitListener(queues = RabbitConfiguration.DEFAULT_QUEUE) public class AckConsumer { @RabbitHandler public void receive(String message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag) { try { log.info(\u0026#34;MessageConsumer receive message: {}\u0026#34;, message); log.info(\u0026#34;MessageConsumer receive deliveryTag: {}\u0026#34;, deliveryTag); TimeUnit.SECONDS.sleep(5); channel.basicAck(deliveryTag, false); log.info(\u0026#34;Ack Success: {}\u0026#34;, LocalDateTime.now()); } catch (IOException | InterruptedException exception) { log.error(\u0026#34;Ack Failure: {}\u0026#34;, message); } } } 消费幂等 利用 SpEL 生成指纹，实现消费方业务接口幂等。\n// TODO\n消息顺序 消息积压 在大型分布式项目中，如果消费者挂了，无法消费消息，或者消费的速度赶不上生产的速度，此时就有可能出现 MQ 中挤压大量、千万级消息。\n场景：消费端服务出故障，大量消息积压在 mq 中\n解决方案：\n修复 consumer 问题，停掉当前的 consumer，重新部署修复后的 consumer，并增加数量，提升消费能力 新增专门的队列，将消息批量取出并持久化，等待过了高峰期，重新导出数据 死信队列 如果在消费消息时，如果消息出现以下几种情况：\n消息被否定确认，使用 channel.basicNack 或 channel.basicReject，并且此时requeue 属性被设置为 false。 消息在队列的存活时间超过设置的 TTL 时间。 消息队列的消息数量已经超过最大队列长度。 那么本条消息就变成了 \u0026ldquo;死信\u0026rdquo;。\n如果配置了死信队列，那么消息会被放入死信队列中 如果没有配置死信队列，那么消息将会被丢弃 如何配置死信队列 配置业务队列，绑定到业务交换机上 为业务队列配置死信交换剂和路由 为死信交换机配置死信队列 依赖文件：\n本次使用版本为 3.0.7\nspring-boot-starter-amqp: 3.0.7 spring-boot-starter-web: 3.0.7 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-amqp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 配置文件：\n1 2 3 4 5 6 spring: listener: simple: acknowledge-mode: manual default-requeue-rejected: false type: simple 配置类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.DirectExchange; import org.springframework.amqp.core.ExchangeBuilder; import org.springframework.amqp.core.FanoutExchange; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.QueueBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQDeadLetterConfiguration { // exchange public static final String FANOUT_EXCHANGE_BIZ = \u0026#34;fanout_exchange_biz\u0026#34;; public static final String DIRECT_EXCHANGE_DEAD_LETTER = \u0026#34;direct_exchange_dead-letter\u0026#34;; // queue public static final String QUEUE_BIZ_A = \u0026#34;queue_biz_a\u0026#34;; public static final String QUEUE_BIZ_B = \u0026#34;queue_biz_b\u0026#34;; public static final String QUEUE_DEAD_LETTER_A = \u0026#34;queue_dead-letter_a\u0026#34;; public static final String QUEUE_DEAD_LETTER_B = \u0026#34;queue_dead-letter_b\u0026#34;; // topic public static final String ROUTING_KEY_DEAD_LETTER_A = \u0026#34;routing-key.dead-letter.a\u0026#34;; public static final String ROUTING_KEY_DEAD_LETTER_B = \u0026#34;routing-key.dead-letter.b\u0026#34;; /** * 业务 Exchange */ @Bean public FanoutExchange bizFanoutExchange() { return ExchangeBuilder.fanoutExchange(FANOUT_EXCHANGE_BIZ).build(); } /** * 死信 Exchange （可以是任意类型[direct|topic|fanout]） */ @Bean public DirectExchange deadLetterDirectExchange() { return ExchangeBuilder.directExchange(DIRECT_EXCHANGE_DEAD_LETTER).build(); } /** * 业务队列 A */ @Bean public Queue bizAQueue() { return QueueBuilder .durable(QUEUE_BIZ_A) .deadLetterExchange(DIRECT_EXCHANGE_DEAD_LETTER) // 这里如果进行了配置，消息编程死信后，路由 key 会编程配置的值 // 如果没有进行配置，消息变成死信后，路由原来的 key 会被保留 .deadLetterRoutingKey(ROUTING_KEY_DEAD_LETTER_A) .build(); } /** * 业务队列 B */ @Bean public Queue bizBQueue() { return QueueBuilder .durable(QUEUE_BIZ_B) .deadLetterExchange(DIRECT_EXCHANGE_DEAD_LETTER) .deadLetterRoutingKey(ROUTING_KEY_DEAD_LETTER_B) .build(); } /** * 死信队列 A */ @Bean public Queue deadLetterAQueue() { return QueueBuilder.nonDurable(QUEUE_DEAD_LETTER_A).build(); } /** * 死信队列 B */ @Bean public Queue deadLetterBQueue() { return QueueBuilder.nonDurable(QUEUE_DEAD_LETTER_B).build(); } /** * bing bizFanoutExchange -\u0026gt; bizAQueue */ @Bean public Binding bindingBizAQueueToBizDirectExchange(Queue bizAQueue, FanoutExchange bizFanoutExchange) { return BindingBuilder.bind(bizAQueue).to(bizFanoutExchange); } /** * bing bizFanoutExchange -\u0026gt; bizBQueue */ @Bean public Binding bindingBizBQueueToBizDirectExchange(Queue bizBQueue, FanoutExchange bizFanoutExchange) { return BindingBuilder.bind(bizBQueue).to(bizFanoutExchange); } /** * bing deadLetterDirectExchange -\u0026gt; deadLetterAQueue */ @Bean public Binding bindingDeadLetterAQueueToDeadLetterDirectExchange(Queue deadLetterAQueue, DirectExchange deadLetterDirectExchange) { return BindingBuilder.bind(deadLetterAQueue).to(deadLetterDirectExchange).with(ROUTING_KEY_DEAD_LETTER_A); } /** * bing deadLetterDirectExchange -\u0026gt; deadLetterBQueue */ @Bean public Binding bindingDeadLetterBQueueToDeadLetterDirectExchange(Queue deadLetterBQueue, DirectExchange deadLetterDirectExchange) { return BindingBuilder.bind(deadLetterBQueue).to(deadLetterDirectExchange).with(ROUTING_KEY_DEAD_LETTER_B); } } 业务消费者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; import java.io.IOException; @Slf4j @Component public class BizReceiver { @RabbitListener(queues = RabbitMQDeadLetterConfiguration.QUEUE_BIZ_A) public void receiveA(Message message, Channel channel) throws IOException { String msg = new String(message.getBody()); log.info(\u0026#34;BizReceiver#receiveA: {}\u0026#34;, msg); boolean ack = true; Exception exception = null; try { if (msg.contains(\u0026#34;dead-letter\u0026#34;)) { throw new RuntimeException(\u0026#34;DeadLetterException\u0026#34;); } } catch (Exception e) { ack = false; exception = e; } long deliveryTag = message.getMessageProperties().getDeliveryTag(); if (ack) { channel.basicAck(deliveryTag, false); } else { log.error(\u0026#34;BizReceiver#receiveA:error: {} \u0026#34;, exception.getMessage(), exception); channel.basicNack(deliveryTag, false, false); } } @RabbitListener(queues = RabbitMQDeadLetterConfiguration.QUEUE_BIZ_B) public void receiveB(Message message, Channel channel) throws IOException { String msg = new String(message.getBody()); log.info(\u0026#34;BizReceiver#receiveB: {}\u0026#34;, msg); long deliveryTag = message.getMessageProperties().getDeliveryTag(); channel.basicAck(deliveryTag, false); } } 死信消费者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; import java.io.IOException; @Slf4j @Component public class DeadLetterReceiver { @RabbitListener(queues = RabbitMQDeadLetterConfiguration.QUEUE_DEAD_LETTER_A) public void receiveA(Message message, Channel channel) throws IOException { String msg = new String(message.getBody()); log.info(\u0026#34;DeadLetterReceiver#receiveA: {}\u0026#34;, msg); long deliveryTag = message.getMessageProperties().getDeliveryTag(); channel.basicAck(deliveryTag, false); } @RabbitListener(queues = RabbitMQDeadLetterConfiguration.QUEUE_DEAD_LETTER_B) public void receiveB(Message message, Channel channel) throws IOException { String msg = new String(message.getBody()); log.info(\u0026#34;DeadLetterReceiver#receiveB: {}\u0026#34;, msg); long deliveryTag = message.getMessageProperties().getDeliveryTag(); channel.basicAck(deliveryTag, false); } } 业务生产者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import lombok.RequiredArgsConstructor; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.stereotype.Component; @Component @RequiredArgsConstructor public class BizProducer { private final RabbitTemplate rabbitTemplate; public void send(String msg) { rabbitTemplate.convertSendAndReceive( RabbitMQDeadLetterConfiguration.FANOUT_EXCHANGE_BIZ, \u0026#34;\u0026#34;, msg); } } 为方便测试，增加 controller:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import lombok.RequiredArgsConstructor; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\u0026#34;/biz\u0026#34;) @RequiredArgsConstructor public class DeadLetterController { private final BizProducer bizProducer; @GetMapping(\u0026#34;/msg/{message}\u0026#34;) public void send(@PathVariable String message) { bizProducer.send(message); } } 测试结果：\n1 2 3 4 http://localhost:8080/biz/msg/biz-message : BizReceiver#receiveA: biz-message : BizReceiver#receiveB: biz-message 1 2 3 4 5 6 7 http://localhost:8080/biz/msg/dead-letter-message : BizReceiver#receiveB: dead-letter-message : BizReceiver#receiveA: dead-letter-message : BizReceiver#receiveA:error: DeadLetterException ... : DeadLetterReceiver#receiveA: dead-letter-message 可以看到，所有流程已经打通，bizA 消费失败后，消息到了死信交换机并转发，最终由 deadLetterA 消费。\n声明周期 业务消息正常投递到业务队列中 消费者消费业务队列的消息，处理过程中发生了异常，于是进行了 nack 或者 reject 操作 被 nack 或者 reject 的消息由 RabbitMQ 投递到死信交换机中 死信交换机将消息投入到对应的死信队列中 死信队列的消费者消费死信消息 总结来说就是死信消息只是。RabbitMQ 为我们做的一层保障。但是其实如果我们不使用死信消息，在触发异常时，将消息主动投递到另一个交换机中，然后自己做后续的处理也可以。\n死信队列应用场景 重要业务场景中，确保未被消费的消息不被丢弃。当发生异常时，不能每次都去找日志获取愿消息，然后再找运维重新投递。通过配置死信队列，可以让未正确处理的消息暂存到另一个队列中，待后续排查清楚问题后，编写对应的代码处理死信消息，会比手工恢复好太多。\n延迟队列 延迟队列，顾名思义，首先他要是个队列，其次，他要能延时，从一端进入之后，过指定的时间，从另一端可以取出。\n延迟队列应用场景 订单十分钟未支付则自动取消 新账号注册完成后三天内没有登录，发送短信提醒 用户发起退款，三天内没有被解决，通知相关运营人员 预定会议后，在预定时间前半个小时提醒各方人员参加会议 RabbitMQ 中的 TTL TTL (Time to Live) 表示一条消息或者该队列中所有消息的最大存活时间，单位是毫秒。\n也就是说如果一条消息设置了 TTL 或者进入了设置 TTL 的队列，如果在这只的时间没有被消费，则会成为 \u0026ldquo;死信\u0026rdquo;。\n如果同时设置了队列的 TTL 和消息的 TTL，则取较小的值。\n设置的第一种方法，在创建队列的时候设置队列的 x-message-ttl 属性：\n1 2 3 4 5 6 7 8 @Bean public Queue queue() { return QueueBuilder .durable() // x-message-ttl .ttl(6000) .build(); } 设置的第二种方法是针对每条消息设置单独的 TTL，如:\n1 2 3 4 5 6 7 8 rabbitTemplate.convertSendAndReceive( RabbitMQDeadLetterConfiguration.FANOUT_EXCHANGE_BIZ, \u0026#34;\u0026#34;, message -\u0026gt; { message.getMessageProperties().setExpiration(\u0026#34;6000\u0026#34;); return message; }); } 两种设置方法是有区别的：\n设置了队列的 TTL，那么一旦消息过期，就会被队列丢弃 设置了消息的 TTL，即使消息过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者前判断的，如果队列中有严重的消息积压情况，即使已经过期的消息也许也能存活很久的时间 如何使用 Rabbit 实现延时队列 延时队列，就是想要消息延时多久后被处理。\n那么 TTL 可以让消息在延时指定时间后成为死信，另一方面成为死信的消息会被投递到死信的消息队列中，那么消费者消费死信中的消息，就是希望被立即处理的消息了。\n1 2 3 P1 -\u0026gt;| | -\u0026gt; Q1(延时) -\u0026gt;| | -\u0026gt; Q1(死信) -\u0026gt; C1 |-\u0026gt; X(延时) -\u0026gt; | | -\u0026gt; X(死信) -\u0026gt;| P2 -\u0026gt;| | -\u0026gt; Q2(延时) -\u0026gt;| | -\u0026gt; Q2(死信) -\u0026gt; C2 配置类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.DirectExchange; import org.springframework.amqp.core.ExchangeBuilder; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.QueueBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQDelayedConfiguration { // exchange public static final String DIRECT_EXCHANGE_DELAY = \u0026#34;direct_exchange-delay\u0026#34;; public static final String DIRECT_EXCHANGE_DEAD_LETTER = \u0026#34;direct_exchange_dead-letter\u0026#34;; // queue public static final String QUEUE_DELAY_A = \u0026#34;queue_delay_a\u0026#34;; public static final String QUEUE_DELAY_B = \u0026#34;queue_delay_b\u0026#34;; public static final String QUEUE_DEAD_LETTER_A = \u0026#34;queue_dead-letter_a\u0026#34;; public static final String QUEUE_DEAD_LETTER_B = \u0026#34;queue_dead-letter_b\u0026#34;; // topic public static final String ROUTING_KEY_DELAY_A = \u0026#34;routing-key.delay.a\u0026#34;; public static final String ROUTING_KEY_DELAY_B = \u0026#34;routing-key.delay.b\u0026#34;; public static final String ROUTING_KEY_DEAD_LETTER_A = \u0026#34;routing-key.dead-letter.a\u0026#34;; public static final String ROUTING_KEY_DEAD_LETTER_B = \u0026#34;routing-key.dead-letter.b\u0026#34;; /** * 延迟 TTL 交换机 */ @Bean public DirectExchange delayDirectExchange() { return ExchangeBuilder.directExchange(DIRECT_EXCHANGE_DELAY).build(); } /** * 死信交换机 */ @Bean public DirectExchange deadLetterExchange() { return ExchangeBuilder.directExchange(DIRECT_EXCHANGE_DEAD_LETTER).build(); } /** * 延时队列A 1000 */ @Bean public Queue delayQueueA() { return QueueBuilder .durable(QUEUE_DELAY_A) .deadLetterExchange(DIRECT_EXCHANGE_DEAD_LETTER) .deadLetterRoutingKey(ROUTING_KEY_DEAD_LETTER_A) .ttl(10000) .build(); } /** * 延时队列B 6000 */ @Bean public Queue delayQueueB() { return QueueBuilder .durable(QUEUE_DELAY_B) .deadLetterExchange(DIRECT_EXCHANGE_DEAD_LETTER) .deadLetterRoutingKey(ROUTING_KEY_DEAD_LETTER_B) .ttl(60000) .build(); } /** * 死信队列A */ @Bean public Queue deadLetterQueueA() { return QueueBuilder .durable(QUEUE_DEAD_LETTER_A) .build(); } /** * 死信队列B */ @Bean public Queue deadLetterQueueB() { return QueueBuilder .durable(QUEUE_DEAD_LETTER_B) .build(); } // binding delayQueueA -\u0026gt; delayDirectExchange @Bean public Binding bindingDelayQueueAToDelayDirectExchange(Queue delayQueueA, DirectExchange delayDirectExchange) { return BindingBuilder.bind(delayQueueA).to(delayDirectExchange).with(ROUTING_KEY_DELAY_A); } // binding delayQueueB -\u0026gt; delayDirectExchange @Bean public Binding bindingDelayQueueBToDelayDirectExchange(Queue delayQueueB, DirectExchange delayDirectExchange) { return BindingBuilder.bind(delayQueueB).to(delayDirectExchange).with(ROUTING_KEY_DELAY_B); } // binding deadLetterQueueA -\u0026gt; deadLetterExchange @Bean public Binding bindingDeadLetterQueueAToDeadLetterExchange(Queue deadLetterQueueA, DirectExchange deadLetterExchange) { return BindingBuilder.bind(deadLetterQueueA).to(deadLetterExchange).with(ROUTING_KEY_DEAD_LETTER_A); } // binding deadLetterQueueB -\u0026gt; deadLetterExchange @Bean public Binding bindingDeadLetterQueueBToDeadLetterExchange(Queue deadLetterQueueB, DirectExchange deadLetterExchange) { return BindingBuilder.bind(deadLetterQueueB).to(deadLetterExchange).with(ROUTING_KEY_DEAD_LETTER_B); } } 死信消费者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; import java.io.IOException; import java.time.LocalDateTime; @Slf4j @Component public class DeadLetterReceiver { @RabbitListener(queues = RabbitMQDelayedConfiguration.QUEUE_DEAD_LETTER_A) public void receiveA(Message message, Channel channel) throws IOException { String msg = new String(message.getBody()); String localDateTimeNow = LocalDateTime.now().toString(); log.info(\u0026#34;DeadLetterReceiver#receiveA: {} {}\u0026#34;, localDateTimeNow, msg); long deliveryTag = message.getMessageProperties().getDeliveryTag(); channel.basicAck(deliveryTag, false); } @RabbitListener(queues = RabbitMQDelayedConfiguration.QUEUE_DEAD_LETTER_B) public void receiveB(Message message, Channel channel) throws IOException { String msg = new String(message.getBody()); String localDateTimeNow = LocalDateTime.now().toString(); log.info(\u0026#34;DeadLetterReceiver#receiveA: {} {}\u0026#34;, localDateTimeNow, msg); long deliveryTag = message.getMessageProperties().getDeliveryTag(); channel.basicAck(deliveryTag, false); } } 延迟消息生产者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import lombok.RequiredArgsConstructor; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.stereotype.Component; @Component @RequiredArgsConstructor public class DelayProducer { private final RabbitTemplate rabbitTemplate; public void sendDelay10000(String msg) { rabbitTemplate.convertSendAndReceive( RabbitMQDelayedConfiguration.DIRECT_EXCHANGE_DELAY, RabbitMQDelayedConfiguration.ROUTING_KEY_DELAY_A, msg); } public void sendDelay60000(String msg) { rabbitTemplate.convertSendAndReceive( RabbitMQDelayedConfiguration.DIRECT_EXCHANGE_DELAY, RabbitMQDelayedConfiguration.ROUTING_KEY_DELAY_B, msg); } } 为了方便测试，增加 controller:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import lombok.RequiredArgsConstructor; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.time.LocalDateTime; @RestController @RequestMapping(\u0026#34;/delay\u0026#34;) @RequiredArgsConstructor public class DelayController { private final DelayProducer delayProducer; @GetMapping(\u0026#34;/10000\u0026#34;) public void sendDelay10000() { delayProducer.sendDelay10000(LocalDateTime.now().toString()); } @GetMapping(\u0026#34;/60000\u0026#34;) public void sendDelay60000() { delayProducer.sendDelay60000(LocalDateTime.now().toString()); } } 测试结果：\n1 2 3 http://localhost:8080/delay/10000 : DeadLetterReceiver#receiveA: 2025-02-20T14:25:49.832087 2025-02-20T14:25:39.786720 1 2 3 http://localhost:8080/delay/60000 : DeadLetterReceiver#receiveA: 2025-02-20T14:27:08.159785 2025-02-20T14:26:08.139689 更进一步 上述为一个队列一个 延迟时间，如果延迟时间不同，就需要创建不同的队列，影响开发和运维，如果想要通用的话，就需要将 TTL 时间设置在消息属性中了。\n配置类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.DirectExchange; import org.springframework.amqp.core.ExchangeBuilder; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.QueueBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQDelayedConfiguration { // exchange public static final String DIRECT_EXCHANGE_DELAY = \u0026#34;direct_exchange-delay\u0026#34;; public static final String DIRECT_EXCHANGE_DEAD_LETTER = \u0026#34;direct_exchange_dead-letter\u0026#34;; // queue public static final String QUEUE_DELAY = \u0026#34;queue_delay\u0026#34;; public static final String QUEUE_DEAD_LETTER = \u0026#34;queue_dead-letter\u0026#34;; // topic public static final String ROUTING_KEY_DELAY = \u0026#34;routing-key.delay\u0026#34;; public static final String ROUTING_KEY_DEAD_LETTER = \u0026#34;routing-key.dead-letter\u0026#34;; /** * 延迟 TTL 交换机 */ @Bean public DirectExchange delayDirectExchange() { return ExchangeBuilder.directExchange(DIRECT_EXCHANGE_DELAY).build(); } /** * 死信交换机 */ @Bean public DirectExchange deadLetterExchange() { return ExchangeBuilder.directExchange(DIRECT_EXCHANGE_DEAD_LETTER).build(); } /** * 延时队列, 此时不设置队列中消息的过期时间 */ @Bean public Queue delayQueue() { return QueueBuilder .durable(QUEUE_DELAY) .deadLetterExchange(DIRECT_EXCHANGE_DEAD_LETTER) .deadLetterRoutingKey(ROUTING_KEY_DEAD_LETTER) .build(); } /** * 死信队列 */ @Bean public Queue deadLetterQueue() { return QueueBuilder .durable(QUEUE_DEAD_LETTER) .build(); } // binding delayQueue -\u0026gt; delayDirectExchange @Bean public Binding bindingDelayQueueAToDelayDirectExchange(Queue delayQueue, DirectExchange delayDirectExchange) { return BindingBuilder.bind(delayQueue).to(delayDirectExchange).with(ROUTING_KEY_DELAY); } // binding deadLetterQueue -\u0026gt; deadLetterExchange @Bean public Binding bindingDeadLetterQueueAToDeadLetterExchange(Queue deadLetterQueue, DirectExchange deadLetterExchange) { return BindingBuilder.bind(deadLetterQueue).to(deadLetterExchange).with(ROUTING_KEY_DEAD_LETTER); } } 消费者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; import java.io.IOException; import java.time.LocalDateTime; @Slf4j @Component public class DeadLetterReceiver { @RabbitListener(queues = RabbitMQDelayedConfiguration.QUEUE_DEAD_LETTER) public void receive(Message message, Channel channel) throws IOException { String msg = new String(message.getBody()); String localDateTimeNow = LocalDateTime.now().toString(); log.info(\u0026#34;DeadLetterReceiver#receiveA: {} {}\u0026#34;, localDateTimeNow, msg); long deliveryTag = message.getMessageProperties().getDeliveryTag(); channel.basicAck(deliveryTag, false); } } 生产者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import lombok.RequiredArgsConstructor; import org.springframework.amqp.core.MessageBuilder; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.stereotype.Component; import java.nio.charset.StandardCharsets; @Component @RequiredArgsConstructor public class DelayProducer { private final RabbitTemplate rabbitTemplate; public void sendDelay(String msg, String expiration) { rabbitTemplate.convertAndSend( RabbitMQDelayedConfiguration.DIRECT_EXCHANGE_DELAY, RabbitMQDelayedConfiguration.ROUTING_KEY_DELAY, MessageBuilder.withBody(msg.getBytes(StandardCharsets.UTF_8)) // 设置过期时间 .setExpiration(expiration) .build() ); } } 方便测试提供的 controller:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import lombok.RequiredArgsConstructor; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.time.LocalDateTime; @RestController @RequestMapping(\u0026#34;/delay\u0026#34;) @RequiredArgsConstructor public class DelayController { private final DelayProducer delayProducer; @GetMapping(\u0026#34;/{expiration}\u0026#34;) public void sendDelay(@PathVariable String expiration) { delayProducer.sendDelay(LocalDateTime.now().toString(), expiration); } } 测试结果：\n1 2 3 http://localhost:8080/delay/10000 : DeadLetterReceiver#receiveA: 2025-02-20T14:53:12.869353 2025-02-20T14:53:02.863495 此时看结果是正确的，但是如果同时有两个消息呢，一个消息为 20000 ,一个消息为 2000 延时：\n1 2 3 4 5 http://localhost:8080/delay/20000 http://localhost:8080/delay/2000 : DeadLetterReceiver#receiveA: 2025-02-20T14:56:45.746856 2025-02-20T14:56:25.727166 : DeadLetterReceiver#receiveA: 2025-02-20T14:56:45.748068 2025-02-20T14:56:28.251651 可以看到，第一个请求的 20s 可以正确的被消费，但是第二个 2s 的却是一只等到第一个消息被消费后才能被消费，这个就是因为在 RabbitMQ 中的 TTL 章节最后总结的。\n解决问题（插件） 如上所述，如果不能在消息粒度添加 TTL，并在设置了 TTL 之后及时死亡，那么这种设计方案就不可用。\n为了解决这个问题，需要安装一个插件 rabbitmq-delayed-message-exchange\n接下来使用插件来完成对应功能(跟上方使用死信队列没有关系了)：\n配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 import org.springframework.amqp.core.Binding; import org.springframework.amqp.core.BindingBuilder; import org.springframework.amqp.core.CustomExchange; import org.springframework.amqp.core.Queue; import org.springframework.amqp.core.QueueBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.Map; @Configuration public class RabbitMQDelayedConfiguration { // exchange public static final String CUSTOM_EXCHANGE_DELAY = \u0026#34;custom_exchange-delay\u0026#34;; // queue public static final String QUEUE_DELAY = \u0026#34;queue_delay\u0026#34;; // topic public static final String ROUTING_KEY_DELAY = \u0026#34;routing-key.delay\u0026#34;; @Bean public CustomExchange delayCustomExchange() { return new CustomExchange( CUSTOM_EXCHANGE_DELAY, \u0026#34;x-delayed-message\u0026#34;, true, false, Map.of(\u0026#34;x-delayed-type\u0026#34;, \u0026#34;direct\u0026#34;) ); } @Bean public Queue delayQueue() { return QueueBuilder.durable(QUEUE_DELAY).build(); } /** * binding delayQueue -\u0026gt; delayCustomExchange */ @Bean public Binding bindingDelayQueueToDelayCustomExchange(Queue delayQueue, CustomExchange delayCustomExchange) { return BindingBuilder.bind(delayQueue).to(delayCustomExchange).with(ROUTING_KEY_DELAY).noargs(); } } 消费者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import com.rabbitmq.client.Channel; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Component; import java.io.IOException; import java.time.LocalDateTime; @Slf4j @Component public class DelayReceiver { @RabbitListener(queues = RabbitMQDelayedConfiguration.QUEUE_DELAY) public void receive(Message message, Channel channel) throws IOException { String msg = new String(message.getBody()); String localDateTimeNow = LocalDateTime.now().toString(); log.info(\u0026#34;DeadLetterReceiver#receiveA: {} {}\u0026#34;, localDateTimeNow, msg); long deliveryTag = message.getMessageProperties().getDeliveryTag(); channel.basicAck(deliveryTag, false); } } 生产者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import lombok.RequiredArgsConstructor; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.stereotype.Component; @Component @RequiredArgsConstructor public class DelayProducer { private final RabbitTemplate rabbitTemplate; public void sendDelay(String msg, Integer delay) { rabbitTemplate.convertAndSend( RabbitMQDelayedConfiguration.CUSTOM_EXCHANGE_DELAY, RabbitMQDelayedConfiguration.ROUTING_KEY_DELAY, msg, message -\u0026gt; { message.getMessageProperties().setDelay(delay); return message; } ); } } 方便测试增加 controller:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import lombok.RequiredArgsConstructor; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.time.LocalDateTime; @RestController @RequestMapping(\u0026#34;/delay\u0026#34;) @RequiredArgsConstructor public class DelayController { private final DelayProducer delayProducer; @GetMapping(\u0026#34;/{delay}\u0026#34;) public void sendDelay(@PathVariable Integer delay) { delayProducer.sendDelay(LocalDateTime.now().toString(), delay); } } 测试结果:\n1 2 3 4 5 http://localhost:8080/delay/20000 http://localhost:8080/delay/2000 : DeadLetterReceiver#receiveA: 2025-02-21T10:04:34.030052 2025-02-21T10:04:32.003032 : DeadLetterReceiver#receiveA: 2025-02-21T10:04:49.300575 2025-02-21T10:04:29.288373 可以看到，后发送的短时间的消息先被消费了，符合业务需要。\n","date":"2025-02-18T13:42:01+08:00","permalink":"https://www.lcsk42.com/post/rabbitmq/","title":"RabbitMQ"},{"content":"分模块介绍 Spring Boot 相关知识。\nSpring Boot 初始化类的先后顺序 SpringApplication InitializingBean @PostConstruct ApplicationRunner CommandLineRunner SpringApplication 1 2 3 4 5 6 7 8 9 10 11 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class BeanDemoApplication { public static void main(String[] args) { System.out.println(\u0026#34;Before:: SpringApplication#run()\u0026#34;); SpringApplication.run(BeanDemoApplication.class, args); System.out.println(\u0026#34;After:: SpringApplication#run()\u0026#34;); } } InitializingBean InitializingBean 接口为 bean 提供了属性初始化后的处理方法，只拥有一个 afterPropertiesSet 方法，凡是继承该接口的类，在 bean 的属性初始化后都会执行该方法。\n1 2 3 4 5 package org.springframework.beans.factory; public interface InitializingBean { void afterPropertiesSet() throws Exception; } 1 2 3 4 5 6 7 8 9 10 import org.springframework.beans.factory.InitializingBean; import org.springframework.stereotype.Component; @Component public class CustomInitializingBean implements InitializingBean { @Override public void afterPropertiesSet() throws Exception { System.out.println(\u0026#34;InitializingBean#afterPropertiesSet()\u0026#34;); } } @PostConstruct 1 2 3 4 5 6 7 8 9 10 11 import org.springframework.stereotype.Component; import javax.annotation.PostConstruct; @Component public class CustomPostConstruct { @PostConstruct public void method() { System.out.println(\u0026#34;@PostConstruct -\u0026gt; method()\u0026#34;); } } ApplicationRunner 1 2 3 4 5 6 7 8 9 10 11 import org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.stereotype.Component; @Component public class CustomApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { System.out.println(\u0026#34;ApplicationRunner#run(ApplicationArguments args)\u0026#34;); } } CommandLineRunner 1 2 3 4 5 6 7 8 9 10 import org.springframework.boot.CommandLineRunner; import org.springframework.stereotype.Component; @Component public class CustomCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { System.out.println(\u0026#34;CommandLineRunner#run(String... args)\u0026#34;); } } 输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Before:: SpringApplication#run() . ____ _ __ _ _ /\\\\ / ___\u0026#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | \u0026#39;_ | \u0026#39;_| | \u0026#39;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) \u0026#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.7.6) 2025-02-14 16:02:17.808 INFO 76746 --- [ main] c.example.beandemo.BeanDemoApplication : Starting BeanDemoApplication using Java 1.8.0_442 on MacBook-Pro.local with PID 76746 2025-02-14 16:02:17.810 INFO 76746 --- [ main] c.example.beandemo.BeanDemoApplication : No active profile set, falling back to 1 default profile: \u0026#34;default\u0026#34; InitializingBean#afterPropertiesSet() @PostConstruct -\u0026gt; method() 2025-02-14 16:02:18.008 INFO 76746 --- [ main] c.example.beandemo.BeanDemoApplication : Started BeanDemoApplication in 0.334 seconds (JVM running for 0.538) ApplicationRunner#run(ApplicationArguments args) CommandLineRunner#run(String... args) After:: SpringApplication#run() Spring Boot 自动装配 什么是 Spring Boot 的自动装配 SPI（Service Provider Interface） 是一种 Java 标准机制，用于实现服务的动态发现和加载。Spring Boot 利用 SPI 机制来扩展框架功能，允许开发者通过简单的配置实现自定义逻辑。\nSpringBoot 在启动过程中会扫描外部引入的 jar 包中的 META-INF/spring.factories （自 Spring Boot 3.0 开始，位置修改为 META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports）文件，根据文件配置的类型信息加载到 Spring 容器中，并执行类中定义的各种操作。这样外部的 jar 来说，只要按照 Spring Boot 定义的标准，就能自动将自己的功能加载进 Spring Boot。\n如何实现 Spring Boot 的自动装配 核心注解 @SpringBootApplication 包含了三个注解: @EnableAutoConfiguration：启用 SpringBoot 的自动配置机制 @Configuration：允许在上下文中注册额外的 bean 或导入其他配置类 @ComponentScan：扫描被 @Component (@Service,@Controller 等)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。 @EnableAutoConfiguration 实现自动装配的核心逻辑 AutoConfigurationImportSelector 类实现了 ImportSelector 接口，也就实现了这个接口中的 selectImports 方法, 该方法获取到所有符合条件的类的全限定类名，这些类就是需要加载到 IoC 容器中的类。 方法中的 getAutoConfigurationEntry() 主要负责加载自动配置类 判断自动装配开关是否打开（spring.boot.enableautoconfiguration 配置） 用于获取 @EnableAutoConfiguration 注解中的 exclude 和 excludeName 获取需要自动装配的所有配置类，读取所有 Spring Boot Starter 下的 META-INF/spring.factories 筛选所有满足 @ConditionalOnXXX 注解的类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered { @Override // ... public String[] selectImports(AnnotationMetadata annotationMetadata) { // 1. 判断判断自动装配开关是否打开 if (!isEnabled(annotationMetadata)) { return NO_IMPORTS; } // 2. 获取所有需要装配的 bean AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations()); } // ... protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) { // 1. 判断自动装配开关是否打开 if (!isEnabled(annotationMetadata)) { return EMPTY_ENTRY; } // 2. 用于获取 EnableAutoConfiguration 注解中的 exclude 和 excludeName AnnotationAttributes attributes = getAttributes(annotationMetadata); // 3. 获取需要自动装配的所有配置类，读取 META-INF/spring.factories List\u0026lt;String\u0026gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); // 4. 筛选 是否满足 @ConditionalOnXXX configurations = removeDuplicates(configurations); Set\u0026lt;String\u0026gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = getConfigurationClassFilter().filter(configurations); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions); } // ... } Spring Boot 提供的条件注解：\n@ConditionalOnBean：当容器里有指定 Bean 的条件下@ConditionalOnMissingBean：当容器里没有指定 Bean 的情况下 @ConditionalOnSingleCandidate：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean @ConditionalOnClass：当类路径下有指定类的条件下 @ConditionalOnMissingClass：当类路径下没有指定类的条件下 @ConditionalOnProperty：指定的属性是否有指定的值 @ConditionalOnResource：类路径是否有指定的值 @ConditionalOnExpression：基于 SpEL 表达式作为判断条件 @ConditionalOnJava：基于 Java 版本作为判断条件 @ConditionalOnJndi：在 JNDI 存在的条件下差在指定的位置 @ConditionalOnNotWebApplication：当前项目不是 Web 项目的条件下 @ConditionalOnWebApplication：当前项目是 Web 项 目的条件下 如何实现一个 Spring Boot Starter 如何命名 Spring 官方提供 Starter 通常命名为 spring-boot-starter-{name} 如：\nspring-boot-starter-web spring-boot-starter-activemq 等等 Spring 官方建议非官方提供的 Starter 命名应遵守 {name}-spring-boot-starter 的格式 如：\nmybatis-spring-boot-starter 创建项目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 └── src | ├── main | │ ├── java | │ │ └── com | │ │ └── lcsk42 | │ │ └── starter | │ │ └── demospringbootstarter | | | ├── AutoConfigurationTest.java | | | ├── ServiceBean.java | │ └── resources | | └── META-INF | | └── spring.factories ├── pom.xml POM 依赖配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.11.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.lcsk42.starter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.0\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 相关类 1 2 3 4 5 public class ServiceBean { public String sayHello(String name) { return String.format(\u0026#34;Hello World, %s\u0026#34;, name); } } 1 2 3 4 5 6 7 8 @Configuration public class AutoConfigurationTest { @Bean public ServiceBean getServiceBean() { return new ServiceBean(); } } 配置文件 1 2 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ com.lcsk42.starter.demospringbootstarter.AutoConfigurationTest 事务 事务分类 Spring 支持两种事务管理方式，分别是编程式事务管理和声明式事务管理。\n编程式事务 通过 TransactionTemplate 或者 TransactionManager(PlatformTransactionManager @2.7) 手动管理事务\nTransactionTemplate 事务管理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import lombok.RequiredArgsConstructor; import org.springframework.stereotype.Service; import org.springframework.transaction.TransactionStatus; import org.springframework.transaction.support.TransactionCallbackWithoutResult; import org.springframework.transaction.support.TransactionTemplate; @Service @RequiredArgsConstructor public class TransactionDemo { private final TransactionTemplate transactionTemplate; private void testTransactionTemplate() { transactionTemplate.execute( new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) { try { // .... 业务代码 } catch (Exception e) { // 回滚 transactionStatus.setRollbackOnly(); } } } ); } } TransactionManager(PlatformTransactionManager @2.7) 事务管理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import lombok.RequiredArgsConstructor; import org.springframework.stereotype.Service; import org.springframework.transaction.PlatformTransactionManager; import org.springframework.transaction.TransactionStatus; import org.springframework.transaction.support.DefaultTransactionDefinition; @Service @RequiredArgsConstructor public class TransactionDemo { private final PlatformTransactionManager transactionManager; private void testTransactionManager() { final TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition()); try { // .... 业务代码 transactionManager.commit(status); } catch (Exception e) { transactionManager.rollback(status); } } } 声明式事务 @Transactional 的全注解方式，实际是通过 AOP 实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import lombok.RequiredArgsConstructor; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Isolation; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional; @Service @RequiredArgsConstructor public class TransactionDemo { @Transactional( propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, rollbackFor = RuntimeException.class ) public void testTransaction(){ // 业务代码 } } 事务的传播行为 规定了当一个事物方法被另一个事物方法调用的时候，如何进行事务之间的传播。\n1 2 3 4 5 6 7 8 9 @Transactional(propagation = xxx) public void methodA(){ } @Transactional(propagation = xxx) public void methodB(){ } 对应上方伪代码中的 xx，Spring 总共提供了七种事务传播行为：\n事务传播行为类型 说明 REQUIRED （最常用） 当前没有事务，就新建一个事务；如果已存在一个事务，加入到这个事务中 SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行 MANDATORY 使用当前事务，如果当前没有事务，抛出异常 REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起 NOT_SUPPORTED 以非事务方式执行，如果当前存在事务，把当前事务挂起 NEVER 以非事务方式执行，如果当前存在事务，抛出异常 NESTED 如果当前存在事务，嵌套到当前事务中运行；如果当前不存在事务，执行类似 REQUIRED 操作 针对以上的代码，给出以下几种情况(A 都是 REQUIRED)：\n情况 异常 是否会滚 说明 B(REQUIRED) A B A(是) B(是) 本质是一个事务 B(REQUIRES_NEW) A A(是) B(否) B 开启了独立事务 B(REQUIRES_NEW) B A(是) B(是) B 的异常也会被 A 的事务管理机制检测到 B(NESTED) A A(是) B(是) B(NESTED) B A(否) B(是) 事务只读 对于只有读取数据查询的事务，可以指定事务类型为 readonly，即只读事务。\n如果只执行一条数据查询，则没有必要使用事务只读 如果要执行多条数据查询，需要保证整体的读一致性,则可以使用只读事务 @Transactional 事务注解原理 @Transactional 基于 APO 的动态代理实现。\n如果目标类实现了接口，Spring 使用 JDK 动态代理 如果目标类没有实现接口，Spring 使用 CGLIB 代理 TransactionInterceptor 拦截被 @Transactional 注解标记的方法\n开启事务 在方法执行前，根据 @Transactional 的配置，调用 PlatformTransactionManager 的 getTransaction 方法开启事务。 执行业务逻辑 调用目标方法执行业务逻辑。 提交或回滚事务 如果方法执行成功，调用 commit 提交事务 如果方法抛出异常，调用 rollback 回滚事务 Spring AOP 自调用问题 如果一个方法增加了 @Transactional 注解，在别的类调用是可以生效的。\n但是如果在自己的类中使用 this 调用，则不会生效。\n这是由 AOP 的工作原理决定的，Spring AOP 使用了动态代理来实现事务的管理, 运行时为带有注解的方法生成代理对象，并在方法调用的前后实现了事务逻辑。\n如果使用 IoC 注入方式调用会走代理对象，如果使用 this 调用，则不会走代理对象。\n解决方案：\n拆分方法到不同类 通过 AopContext.currentProxy() 获取当前类的代理对象，然后通过代理对象调用方法 自注入，在自己的类中惰性注入自己 ","date":"2025-02-14T13:50:27+08:00","permalink":"https://www.lcsk42.com/post/spring-boot/","title":"Spring Boot"},{"content":"分别介绍了 Redis, ZooKeeper 和数据库实现分布式锁的相关内容。\nRedis Redission 实现加锁，并增加看门狗进行续期。\n执行 lock.lock() 进行加锁 如果设置的有过期时间，就按照设置的过期时间执行执行 Lua 脚本进行加锁，如果没有设置过期时间，默认过期时间为 internalLockLeaseTime （30s） 加锁成功 如果没有设置过期时间，机遇 Netty 的时间轮启动一个后台任务，每隔 internalLockLeaseTime / 3 (10s) 检查当前任务是否完成，如果没有完成，就将过期时间重新设置为 30s 加锁失败 订阅这个锁的 channel while 循环尝试获取锁直到成功 看门狗什么时候进行锁续期，什么时候停止续期 续期：\n加锁时，没有指定过期时间，则默认过期时间为 30s 且每隔 10s 进行锁续期操作 停止续期：\n锁被释放 续期时发生异常 执行锁续期 Lua 脚本失败 应用宕机、下线或重启后，续期任务将结束(Redission 的续期时 Netty 时间轮) lock() 和 tryLock() 有什么区别 lock 的原理是以阻塞的方式获取锁，如果获取失败则一直等待，直到获取成功 tryLock 是尝试获取锁，如果能获取直接返回 true 如果没有指定超时时间，则直接返回 false 如果指定了超时时间，在超时时间内，还会尝试获取锁，如果超过了超市时间还没有获取到，则也返回 false 如何保证主从、哨兵下的多节点问题 使用 RedLock , Redission 中有相关实现。\n大致原理是获取节点数一半以上的节点的认可，才算加锁成功。\n具体过程如下：\n获取当前时间（毫秒） 依次从 n 个节点，使用**相同的 key 和随机值（例如 UUID）**获取锁 当向 Redis 请求获取锁时，客户端应该设置一个超时时间，这个时间要远小于锁失效的时间 （例如，如果自动释放时间为 10 秒，超时时间可能在 5-50 毫秒范围内）。这可以防止客户端在尝试与宕机的 Redis 节点通信时被长时间阻塞：如果一个实例不可用，客户端应该尽快尝试与下一个实例通信 客户端计算获取锁所用的时间减去步骤 1 的时间，就获得了获取锁消耗的时间。当前仅当大多数（N/2+1）的 Redis 节点都获取到锁，并且获取锁使用的时间小于锁失效的时间，锁才算获取成功 成功获取锁后，key 的真正有效时间=TTL-锁的获取时间-时钟漂移 如果客户端由于某种原因未能获取锁（无法锁定 N/2+1 个实例或有效时间为负），它将尝试解锁所有实例（甚至是它认为自己无法锁定的实例） 存在的问题:\n使用成本较高(性能问题：setnx 和 Redission 实现的分布式锁只需要在一个节点写成功就行了，而 RedLock 需要写多个节点才算加锁成功) 并不能完全解决分布式锁的问题(严重依赖系统时间、 无法应对无持久化的节点重启、脑裂（网络分区）) Zookeeper 实现方案 创建一个锁目录 /locks，该节点为持久节点 想要获取锁的线程都在锁目录下创建一个临时顺序节点 获取锁目录下所有子节点，对子节点按自增序号从小到大排序 判断本节点是不是第一个子节点（序号最小），如果是，则获取锁成功，反之，则监听自己的上一个节点的删除事件 持有锁的线程只需要删除当前节点，就可释放锁 当自己监听的节点被删除时，监听事件触发，则回到第 3 步重新进行判断，直到获取锁 优点：\nZK 保证数据的强一致性 问题：\n性能问题：ZK 在性能方面不如 Redis 高，因为每次创建和释放锁都要创建、销毁节点，并且只能由 Leader 执行之后同步给所有的 Follower 并发问题：网络波动下，客户端与 ZK 断连，ZK 会删除临时节点，这时候其他客户端可以获取到分布式锁 MySql 使用唯一索引，使用数据插入尝试作为加锁，如果可以插入成功，则获取锁，执行业务，否则则是已经被抢占。\n可使用情况不多，不进行过多的赘述。\n","date":"2025-02-13T15:20:10+08:00","permalink":"https://www.lcsk42.com/post/distributed-lock/","title":"分布式锁"},{"content":"详细分析 Java 线程池参数、如何构建线程池，早消线程。\n线程池基础 线程池主要参数 corePoolSize(int)[\u0026gt; 0]: 核心线程池数，池中保留的线程数，即使它们处于空闲状态，除非设置了 allowCoreThreadTimeOut 为 true maximumPoolSize(int)[\u0026gt; 0]: 最大线程数，线程池中最大可创建的线程数 keepAliveTime(long)[\u0026gt; 0]: 线程存活时间，当线程数大于核心线程数时，多余的空闲线程在终止前等待新任务的最长时间 unit(TimeUnit): keepAliveTime 参数的时间单位 workQueue(BlockingQueue\u0026lt;Runnable\u0026gt;)[not null]: 用于在执行任务之前保存任务的队列 threadFactory(ThreadFactory)[not null]: 执行器创建新线程时使用的工厂 handler(RejectedExecutionHandler)[not null]: 当线程边界和队列容量达到上限时，用于处理阻塞执行的处理器 (corePoolSize)核心线程数 如果提交任务后线程还在运行，当线程数小于 corePoolSize 值时，无论线程池中的线程是否忙碌，都会创建线程，并把任务交给此新创建的线程进行处理，如果线程数少于等于 corePoolSize，那么这些线程不会回收，除非将 allowCoreThreadTimeOut 设置为 true，但一般不这么干，因为频繁地创建销毁线程会极大地增加系统调用的开销。\n计算方式：\n通过 Runtime 方法来获取当前服务器 CPU 内核数量，根据 CPU 内核数量来创建核心线程数和最大线程数。\n一般根据任务类型会有以下两种划分方式：\nCPU 密集型：核心线程数 = CPU 核心数 + 1 I/O 密集型：核心线程数 = CPU 核心数 * 2 1 2 3 4 private Integer calculateCoreNum() { int cpuCoreNum = Runtime.getRuntime().availableProcessors(); return new BigDecimal(cpuCoreNum).divide(new BigDecimal(\u0026#34;0.5\u0026#34;)).intValue(); } (maximumPoolSize)最大线程数 线程池中最大可创建的线程数，如果提交任务时队列满了且线程数未到达这个设定值，则会创建线程并执行此次提交的任务，如果提交任务时队列满了但线池数已经到达了这个值，此时说明已经超出了线池程的负载能力，就会执行拒绝策略，不能让源源不断地任务进来把线程池给压垮了吧，首先要保证线程池能正常工作。\n(handler)拒绝策略 默认有以下四种拒绝策略：\nAbortPolicy：丢弃任务并抛出异常，这也是默认策略 CallerRunsPolicy：用调用者所在的线程来执行任务，如果用的是 CallerRunsPolicy 策略，提交任务的线程（比如主线程）提交任务后并不能保证马上就返回，当触发了这个 reject 策略不得不亲自来处理这个任务 DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务 DiscardPolicy：直接丢弃任务，不抛出任何异常，这种策略只适用于不重要的任务 自定义拒绝策略：\n1 implements RejectedExecutionHandler 注意：自定义逻辑之后，需要抛出异常。\n线程执行过程 当一个任务通过 execute(Runnable) 方法欲添加到线程池时：\n如果当前线程池中的线程数量小于 corePoolSize, 即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。 如果当前线程池中的线程数量等于 corePoolSize, 但是缓冲队列 workQueue 未满，则任务被放入缓冲队列。 如果此时线程池中的线程数量大于 corePoolSize, 缓冲队列 workQueue 已满，并且线程池中的线程数量小于 maxPoolSize, 则新建线程用来处理被添加的任务。 如果此时线程池中的线程数量大于 corePoolSize, 缓冲队列 workQueue 已满，并且线程池中的线程数量等于 maxPoolSize, 那么通过 rejectedExecutionHandler 所指定的策略来处理此任务。 也就是整体优先级为： 核心线程 corePoolSize -\u0026gt; 任务队列 workQueue -\u0026gt; 最大线程 maxPoolSize -\u0026gt; rejectedExecutionHandler 拒绝策略\n为什么不允许使用 Executors 快速创建线程池 使用 Executors 快速生成的线程池没有完整的参数配置，newCachedThreadPool 方法的最大线程数设置成了 Integer.MAX_VALUE，而 newSingleThreadExecutor 方法创建 workQueue 时 LinkedBlockingQueue 未声明大小，相当于创建了无界队列，一不小心就会导致 OOM。\n快消线程池 根据线程池的执行过程，核心线程满了之后，新增的任务会被放入队列中。\n而快消线程池就是，发现池内线程大于核心线程数，不放入阻塞队列，而是创建非核心线程进行消费任务。\nTaskQueue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import lombok.Setter; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.RejectedExecutionException; import java.util.concurrent.TimeUnit; /** * 快速消费消息队列 */ public class TaskQueue\u0026lt;R extends Runnable\u0026gt; extends LinkedBlockingQueue\u0026lt;Runnable\u0026gt; { @Setter private EagerThreadPoolExecutor executor; public TaskQueue(int capacity) { super(capacity); } @Override public boolean offer(Runnable runnable) { // 获取线程池中线程数 int currentPoolThreadSize = executor.getPoolSize(); // 如果有核心线程正在空闲，将任务加入阻塞队列，由核心线程进行处理任务 if (executor.getSubmittedTaskCount() \u0026lt; currentPoolThreadSize) { return super.offer(runnable); } // 当前线程池线程数量小于最大线程数，返回 False，根据线程池源码，会创建非核心线程 if (currentPoolThreadSize \u0026lt; executor.getMaximumPoolSize()) { return false; } // 如果当前线程池数量大于最大线程数，任务加入阻塞队列 return super.offer(runnable); } public boolean retryOffer(Runnable o, long timeout, TimeUnit unit) throws InterruptedException { if (executor.isShutdown()) { throw new RejectedExecutionException(\u0026#34;Executor is shutdown!\u0026#34;); } // 如果当前线程池数量大于最大线程数，任务加入阻塞队列 return super.offer(o, timeout, unit); } } 通过获取线程池中的任务数量进行响应的操作。\nEagerThreadPoolExecutor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 import java.util.concurrent.BlockingQueue; import java.util.concurrent.RejectedExecutionException; import java.util.concurrent.RejectedExecutionHandler; import java.util.concurrent.ThreadFactory; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.AtomicInteger; /** * 快速消费线程池 */ public class EagerThreadPoolExecutor extends ThreadPoolExecutor { public EagerThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u0026lt;Runnable\u0026gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler); } private final AtomicInteger submittedTaskCount = new AtomicInteger(0); public int getSubmittedTaskCount() { return submittedTaskCount.get(); } @Override protected void afterExecute(Runnable r, Throwable t) { submittedTaskCount.decrementAndGet(); } @Override public void execute(Runnable command) { submittedTaskCount.incrementAndGet(); try { super.execute(command); } catch (RejectedExecutionException ex) { TaskQueue taskQueue = (TaskQueue) super.getQueue(); try { if (!taskQueue.retryOffer(command, 0, TimeUnit.MILLISECONDS)) { submittedTaskCount.decrementAndGet(); throw new RejectedExecutionException(\u0026#34;Queue capacity is full.\u0026#34;, ex); } } catch (InterruptedException iex) { submittedTaskCount.decrementAndGet(); throw new RejectedExecutionException(iex); } } catch (Exception ex) { submittedTaskCount.decrementAndGet(); throw ex; } } } EagerThreadPoolExecutor 继承了 ThreadPoolExecutor，在 execute() 上做了自己的逻辑处理。\n维护了一个任务数量的字段，是一个原子类，添加任务时自增，任务异常及结束时递减。\n这样就能保证 TaskQueue#offer(Runnable runnable) 做出逻辑处理\n构建线程池 Builder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import java.io.Serializable; /** * Builder 模式抽象接口 * * @param \u0026lt;T\u0026gt; */ public interface Builder\u0026lt;T\u0026gt; extends Serializable { /** * 构建方法 * * @return 构建后的对象 */ T build(); } ThreadFactoryBuilder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 import lombok.AccessLevel; import lombok.NoArgsConstructor; import javax.validation.constraints.NotNull; import java.io.Serial; import java.util.Objects; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory; import java.util.concurrent.atomic.AtomicLong; /** * 线程工厂构建器，提供灵活的线程配置选项。 * \u0026lt;p\u0026gt; * 支持设置线程名前缀、守护线程状态、优先级和未捕获异常处理器等配置。 * 采用建造者模式，支持链式调用。 * \u0026lt;/p\u0026gt; */ // 私有构造方法，只允许使用 builder() 方法创建实例。 @NoArgsConstructor(access = AccessLevel.PRIVATE) public final class ThreadFactoryBuilder implements Builder\u0026lt;ThreadFactory\u0026gt; { @Serial private static final long serialVersionUID = 1L; private ThreadFactory backingThreadFactory; private String namePrefix; private Boolean daemon; private Integer priority; private Thread.UncaughtExceptionHandler uncaughtExceptionHandler; /** * 创建新的ThreadFactoryBuilder实例。 * * @return 新的ThreadFactoryBuilder实例 */ public static ThreadFactoryBuilder builder() { return new ThreadFactoryBuilder(); } /** * 设置底层线程工厂。如果未设置，将使用 Executors.defaultThreadFactory()。 * * @param backingThreadFactory 底层线程工厂 * @return 当前构建器实例 * @throws NullPointerException 如果 backingThreadFactory 为 null */ public ThreadFactoryBuilder threadFactory(@NotNull ThreadFactory backingThreadFactory) { this.backingThreadFactory = Objects.requireNonNull(backingThreadFactory, \u0026#34;backingThreadFactory cannot be null\u0026#34;); return this; } /** * 设置线程名前缀。如果设置，线程名将为 \u0026#34;前缀_序号\u0026#34; 格式。 * * @param namePrefix 线程名前缀 * @return 当前构建器实例 */ public ThreadFactoryBuilder prefix(String namePrefix) { this.namePrefix = namePrefix; return this; } /** * 设置是否为守护线程。 * * @param daemon 是否为守护线程 * @return 当前构建器实例 */ public ThreadFactoryBuilder daemon(boolean daemon) { this.daemon = daemon; return this; } /** * 设置线程优先级。 * * @param priority 线程优先级(1-10) * @return 当前构建器实例 * @throws IllegalArgumentException 如果优先级不在 Thread.MIN_PRIORITY(1) 和 Thread.MAX_PRIORITY(10) 之间 */ public ThreadFactoryBuilder priority(int priority) { if (priority \u0026lt; Thread.MIN_PRIORITY) { throw new IllegalArgumentException(String.format(\u0026#34;Thread priority (%s) must be \u0026gt;= %s\u0026#34;, priority, Thread.MIN_PRIORITY)); } if (priority \u0026gt; Thread.MAX_PRIORITY) { throw new IllegalArgumentException(String.format(\u0026#34;Thread priority (%s) must be \u0026lt;= %s\u0026#34;, priority, Thread.MAX_PRIORITY)); } this.priority = priority; return this; } /** * 设置未捕获异常处理器。 * * @param uncaughtExceptionHandler 未捕获异常处理器 * @return 当前构建器实例 */ public ThreadFactoryBuilder uncaughtExceptionHandler(Thread.UncaughtExceptionHandler uncaughtExceptionHandler) { this.uncaughtExceptionHandler = uncaughtExceptionHandler; return this; } /** * 构建配置好的 ThreadFactory 实例。 * * @return 配置好的 ThreadFactory 实例 */ @Override public ThreadFactory build() { return build(this); } /** * 内部构建方法，根据配置创建 ThreadFactory。 * * @param builder 构建器实例 * @return 配置好的 ThreadFactory */ private static ThreadFactory build(ThreadFactoryBuilder builder) { final ThreadFactory backingThreadFactory = (null != builder.backingThreadFactory) ? builder.backingThreadFactory : Executors.defaultThreadFactory(); final String namePrefix = builder.namePrefix; final Boolean daemon = builder.daemon; final Integer priority = builder.priority; final Thread.UncaughtExceptionHandler handler = builder.uncaughtExceptionHandler; final AtomicLong count = (null == namePrefix) ? null : new AtomicLong(); return r -\u0026gt; { final Thread thread = backingThreadFactory.newThread(r); // 设置线程名称(如果配置了前缀) if (null != namePrefix) { thread.setName(namePrefix + \u0026#34;_\u0026#34; + count.getAndIncrement()); } // 设置守护线程状态(如果配置) if (null != daemon) { thread.setDaemon(daemon); } // 设置线程优先级(如果配置) if (null != priority) { thread.setPriority(priority); } // 设置未捕获异常处理器(如果配置) if (null != handler) { thread.setUncaughtExceptionHandler(handler); } return thread; }; } } ThreadPoolBuilder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 import lombok.AccessLevel; import lombok.NoArgsConstructor; import org.springframework.util.Assert; import java.math.BigDecimal; import java.util.concurrent.BlockingQueue; import java.util.concurrent.LinkedBlockingQueue; import java.util.concurrent.RejectedExecutionHandler; import java.util.concurrent.ThreadFactory; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit; /** * 线程池构建器，提供链式API配置并创建ThreadPoolExecutor实例。 * 这是一个不可变构建器，线程安全。 */ @NoArgsConstructor(access = AccessLevel.PRIVATE) public final class ThreadPoolBuilder implements Builder\u0026lt;ThreadPoolExecutor\u0026gt; { // 默认核心线程数为CPU核心数的5倍（基于20%利用率计算） private int corePoolSize = calculateCoreNum(); // 默认最大线程数为核心线程数的 1.5 倍 private int maximumPoolSize = corePoolSize + (corePoolSize \u0026gt;\u0026gt; 1); // 默认线程空闲存活时间 30 秒 private long keepAliveTime = 30_000L; // 默认时间单位为毫秒 private TimeUnit timeUnit = TimeUnit.MILLISECONDS; // 默认工作队列为无界队列，容量 4096 private BlockingQueue\u0026lt;Runnable\u0026gt; workQueue = new LinkedBlockingQueue\u0026lt;\u0026gt;(4096); // 默认拒绝策略为 AbortPolicy private RejectedExecutionHandler rejectedExecutionHandler = new ThreadPoolExecutor.AbortPolicy(); // 默认线程为非守护线程 private boolean isDaemon = false; // 线程名前缀 private String threadNamePrefix; // 线程工厂 private ThreadFactory threadFactory; /** * 创建 ThreadPoolBuilder 实例的工厂方法 * * @return 新的 ThreadPoolBuilder 实例 */ public static ThreadPoolBuilder builder() { return new ThreadPoolBuilder(); } /** * 计算默认核心线程数，基于 CPU 核心数和 20% 利用率 * * @return 计算后的核心线程数 */ private int calculateCoreNum() { int cpuCoreNum = Runtime.getRuntime().availableProcessors(); return new BigDecimal(cpuCoreNum).divide(new BigDecimal(\u0026#34;0.2\u0026#34;)).intValue(); } /** * 设置自定义线程工厂 * * @param threadFactory 线程工厂实例 * @return 当前构建器实例（链式调用） */ public ThreadPoolBuilder threadFactory(ThreadFactory threadFactory) { this.threadFactory = threadFactory; return this; } /** * 设置核心线程数 * * @param corePoolSize 核心线程数 * @return 当前构建器实例（链式调用） * @throws IllegalArgumentException 如果 corePoolSize 小于0 */ public ThreadPoolBuilder corePoolSize(int corePoolSize) { if (corePoolSize \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;Core pool size must be non-negative\u0026#34;); } this.corePoolSize = corePoolSize; return this; } /** * 设置最大线程数，如果小于当前核心线程数则自动调整核心线程数 * * @param maximumPoolSize 最大线程数 * @return 当前构建器实例（链式调用） * @throws IllegalArgumentException 如果 maximumPoolSize 小于等于 0 或小于核心线程数 */ public ThreadPoolBuilder maximumPoolSize(int maximumPoolSize) { if (maximumPoolSize \u0026lt;= 0) { throw new IllegalArgumentException(\u0026#34;Maximum pool size must be positive\u0026#34;); } this.maximumPoolSize = maximumPoolSize; if (maximumPoolSize \u0026lt; this.corePoolSize) { this.corePoolSize = maximumPoolSize; } return this; } /** * 设置线程工厂的基本属性 * * @param threadNamePrefix 线程名前缀 * @param isDaemon 是否为守护线程 * @return 当前构建器实例（链式调用） */ public ThreadPoolBuilder threadFactory(String threadNamePrefix, Boolean isDaemon) { this.threadNamePrefix = threadNamePrefix; this.isDaemon = isDaemon; return this; } /** * 设置线程空闲存活时间（使用默认时间单位毫秒） * * @param keepAliveTime 存活时间 * @return 当前构建器实例（链式调用） */ public ThreadPoolBuilder keepAliveTime(long keepAliveTime) { this.keepAliveTime = keepAliveTime; return this; } /** * 设置线程空闲存活时间和时间单位 * * @param keepAliveTime 存活时间 * @param timeUnit 时间单位 * @return 当前构建器实例（链式调用） */ public ThreadPoolBuilder keepAliveTime(long keepAliveTime, TimeUnit timeUnit) { this.keepAliveTime = keepAliveTime; this.timeUnit = timeUnit; return this; } /** * 设置拒绝策略 * * @param rejectedExecutionHandler 拒绝策略处理器 * @return 当前构建器实例（链式调用） */ public ThreadPoolBuilder rejected(RejectedExecutionHandler rejectedExecutionHandler) { this.rejectedExecutionHandler = rejectedExecutionHandler; return this; } /** * 设置工作队列 * * @param workQueue 工作队列实例 * @return 当前构建器实例（链式调用） */ public ThreadPoolBuilder workQueue(BlockingQueue\u0026lt;Runnable\u0026gt; workQueue) { this.workQueue = workQueue; return this; } /** * 构建ThreadPoolExecutor实例 * * @return 配置好的ThreadPoolExecutor实例 * @throws IllegalArgumentException 如果参数不合法或线程名前缀为空 */ @Override public ThreadPoolExecutor build() { if (threadFactory == null) { Assert.hasLength(threadNamePrefix, \u0026#34;The thread name prefix cannot be empty or an empty string.\u0026#34;); threadFactory = ThreadFactoryBuilder.builder().prefix(threadNamePrefix).daemon(isDaemon).build(); } ThreadPoolExecutor executorService; try { executorService = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, timeUnit, workQueue, threadFactory, rejectedExecutionHandler); } catch (IllegalArgumentException ex) { throw new IllegalArgumentException(\u0026#34;Error creating thread pool parameter.\u0026#34;, ex); } return executorService; } } 使用方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; import org.springframework.scheduling.annotation.EnableAsync; import java.util.concurrent.Executor; // @EnableAsync 注解可以放在配置类和启动类 // 如果简单使用，不用自己定义的线程池，放在启动类也行 // 如果使用了自定义线程池，推荐放在配置类，职责分离 @EnableAsync @Configuration public class ThreadPoolConfiguration { @Bean // 如果有多个线程池配置，需要配置一个默认的 @Primary // 如果想要 @Async 注解使用当前线程池，需要注意，名称必须是 \u0026#34;taskExecutor\u0026#34; public Executor taskExecutor() { // 最简单的创建方式，指定线程前缀即可 return ThreadPoolBuilder.builder() .threadFactory(\u0026#34;d_task_\u0026#34;, false) .build(); } } ","date":"2025-02-12T14:15:39+08:00","permalink":"https://www.lcsk42.com/post/thread-pool/","title":"Java 线程池"},{"content":"数据类型和使用场景 String 使用场景 常规数据（比如 Session、Token、序列化后的对象、图片的路径）的缓存 计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数 分布式锁(利用 SETNX key value 命令可以实现一个最简易的分布式锁) \u0026hellip; Hash 存储对象，相比于 String 序列化存储，可以少一个序列化反序列化的过程\nSorted Set 排行榜可以使用\n缓存读写策略 Cache Aside Pattern（旁路缓存模式） Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。\n写入：\n更新 db 删除 cache 读取：\n从 cache 中读取数据，读取到直接返回 如果从 cache 中读取不到数据，从 db 中读取数据，放入 cache ，然后返回 问题：\nQ：可以先删除 cache ，再更新 db 吗？\nA：不能，会有数据一致性问题。如果删除 cache， db 没有更新，又有一个请求进来了，cache 中就有旧数据了，此时更新 db 后，db 和 cache 数据不一致了。\nQ：写入过程中，先更新 db, 在 删除 cache 就可以保证没有问题了吗？\nA：不能，理论上还是会有数据一致性问题，但是概率较小，因为 cache 的写入比数据库的写入快的多。\n两个请求，req1 和 req2, 此时 cache 中没有缓存。req1 请求数据 A -\u0026gt; 同时 req2 请求更新数据 A -\u0026gt; req1 将数据放入 cache。\nRead/Write Through Pattern（读写穿透） Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。\n写入：\n先查 cache，cache 中不存在，直接更新 db cache 存在，想更新 cache，然后由 cache 自己去更新 db 读取：\n先从 cache 中读，存在则直接返回 cache 中不存在，cache 去查询 db，写入 cache 中后返回 Write Behind Pattern（异步缓存写入） Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。\n但是，两个又有很大的不同：\nRead/Write Through 是同步更新 cache 和 db Write Behind 则是只更新 cache ，不直接更新 db，而是改为异步批量的方式来更新 db 如何保证数据一致性（延迟双删） 日常使用的 Cache Aside Pattern（旁路缓存模式）并不能准确的确保数据一致性，如果一致性要求比较高，可以使用一下方案。\n实现过程：\n删除 cache 更新 db 隔一段时间再次删除 cache 其中 \u0026ldquo;3. 隔一段时间再次删除 cache\u0026rdquo; 也有多种实现方式：\n写入消息队列，利用消息队列实现二次删除（APP -写-\u0026gt; MySQL \u0026amp; APP -写-\u0026gt; MQ -删除-\u0026gt; Redis ） 订阅数据库变更日志，再操作缓存(APP -写-\u0026gt; MySQL -Binlog-\u0026gt; Canal -投递-\u0026gt; MQ -删除-\u0026gt; Redis) 问题：第二次删除的延迟时间难以确定，中间的延迟时间其实还是会有 “脏数据” 存在\nRedis 性能优化 Redis 问题 以下 3 个问题本质都是 cache 没有查询到数据，访问数据库，将数据库压崩了。\n缓存穿透 key 不合理，根本不存在 cache 中，也不存在于 db 中\n如：恶意攻击者故意制造大量非法的 key 发起请求，导致大量请求直接落到 db 中，db 中也没有相应数据。也就是大量请求最终直接落到 db 了，给 db 造成了巨大的压力。\n解决方案：\n缓存无效 key （如果数据库中查不到，就将查不到的数据也缓存到 redis 中，并设置合适的过期时间） 布隆过滤器 （可以快速判断出 key 是否存在于布隆过滤器，如果存在，执行后续查询，如果不存在，数据肯定无效，直接丢弃或者返回业务异常） 接口限流 （根据用户或者 IP 信息进行限流，对于频繁的异常访问，使用黑名单机制） 缓存击穿 key 为热点数据，存在 db 中，不存在 cache 中（通常是因为 cache 中的数据过期）\n解决办法：\n永不过期（不推荐）：设置热点数据永不过期或者过期时间比较长 提前预热（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期 加锁（看情况）：在缓存失效后，通过设置互斥锁确保只有一个请求去查询数据库并更新缓存 缓存雪崩 cache 中的数据同一时间大面积失效，大量请求直达 db\n解决办法：\n设置随机的过期时间（可选）：过期时间可以用固定时间加随机值，这样可以避免大量 key 同时实效 提前预热（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期 持久缓存（看情况）：一般不推荐缓存永不过期，但是针对关键性和变化不频繁的数据，也可以考虑这种方案 如何缓存预热 综上可的，缓存预热可以有效解决缓存击穿和缓存雪崩的情况，那么缓存预热应该如何进行呢？\n使用定时任务，如 xxl-job, 用来定时触发预热逻辑 使用消息队列，如 kafka，用来异步的进行缓存预热（将需要预热的数据放入消息队列，由缓存服务消费消息队列中的数据，将对应数据进行缓存） 三种问题的对比 缓存穿透中，请求的 key 既不存在于 cache 中，也不存在于 db 中 缓存击穿中，请求的 key 对应的是热点数据 ，该数据存在 db 中，但不存在于 cache 中（通常是因为 cache 中的那份数据已经过期） 缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期） 缓存雪崩导致的原因是 cache 中的大量或者所有数据失效 ","date":"2025-02-11T17:22:06+08:00","permalink":"https://www.lcsk42.com/post/redis/","title":"Redis"},{"content":"总结了遇到了数据库相关的知识。\n索引 MySQL 索引是提高数据库查询性能的重要工具。索引类似于书的目录，可以帮助数据库快速找到所需的数据，而不必遍历整个表。以下是有关 MySQL 索引的一些关键点和常见类型：\n索引的作用 加速查询：通过索引，MySQL 可以快速定位到所需的数据行，从而减少查询时间 确保唯一性：唯一索引（Unique Index）可以确保表中的某一列的所有值都是唯一的 优化排序和分组：索引可以优化 ORDER BY 和 GROUP BY 操作。 提高连接性能：在多表连接时，索引用于加速表之间的匹配。 索引的类型 普通索引（Index）：最基本的索引类型，没有任何限制\n1 CREATE INDEX idx_name ON table_name(column_name); 唯一索引（Unique Index）：确保索引列中的值是唯一的。\n1 CREATE UNIQUE INDEX idx_name ON table_name(column_name); 主键索引（Primary Key）：一种特殊的唯一索引，不允许有空值。\n1 2 3 4 5 CREATE TABLE table_name ( id INT NOT NULL, column_name datatype, PRIMARY KEY (id) ); 全文索引（Full-Text Index）：用于对文本进行全文搜索。\n1 CREATE FULLTEXT INDEX idx_name ON table_name(column_name); 复合索引（Composite Index）：在多个列上创建的索引。\n1 CREATE INDEX idx_name ON table_name(column1, column2); 索引的创建和管理 创建索引：使用 CREATE INDEX 或在 CREATE TABLE 语句中定义。\n1 CREATE INDEX idx_name ON table_name(column_name); 删除索引：使用 DROP INDEX 语句。\n1 DROP INDEX idx_name ON table_name; 查看索引：使用 SHOW INDEX 语句。\n1 SHOW INDEX FROM table_name; 索引的优缺点 优点：\n显著提高查询速度。 帮助维护数据的唯一性。 加快数据检索的效率。 缺点：\n占用磁盘空间。 影响插入、更新和删除操作的速度（因为需要维护索引）。 索引的最佳实践 选择性高的列上创建索引：选择性越高，索引的效率越高。 尽量避免在频繁更新的列上创建索引：减少索引维护开销。 使用覆盖索引：创建包含所有查询列的复合索引，避免回表查询。 定期维护索引：使用 ANALYZE TABLE 和 OPTIMIZE TABLE 进行索引维护。 创建索引的原则 最左前缀匹配原则，非常重要的原则，mysql 会一直向右匹配直到遇到范围查询(\u0026gt;、\u0026lt;、between、like)就停止匹配，比如 a = 1 and b = 2 and c \u0026gt; 3 and d = 4 如果建立(a, b, c, d)顺序的索引，d 是用不到索引的，如果建立(a, b, d, c)的索引则都可以用到，a, b, d 的顺序可以任意调整。 =和 in 可以乱序，比如 a = 1 and b = 2 and c = 3 建立(a, b, c)索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。 尽量选择区分度高的列作为索引，区分度的公式是 count(distinct col)/count(\\*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要 join 的字段我们都要求是 0.1 以上，即平均 1 条扫描 10 条记录。 索引列不能参与计算，保持列“干净”，比如 from_unixtime(create_time) = '2014-05-29' 就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成 create_time = unix_timestamp('2014-05-29')。 尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加(a, b)的索引，那么只需要修改原来的索引即可。 索引失效 在某些情况下，MySQL 的索引可能会失效，导致查询性能下降。以下是一些常见的索引失效的情况：\n条件不符合索引使用规则 范围查询影响后续索引：\n当一个查询中使用了范围条件（如 \u0026lt;, \u0026gt;, BETWEEN, LIKE 'abc%' 等）时，索引在范围条件之后的列将不会被使用。 1 2 3 -- 复合索引 idx_name_department(last_name, department_id) -- 只会使用 last_name 的索引，department_id 不会被使用 SELECT * FROM employees WHERE last_name \u0026gt; \u0026#39;Smith\u0026#39; AND department_id = 5; 函数操作导致索引失效：\n如果在查询条件中对索引列使用了函数或运算，索引会失效。 1 2 -- 索引不会被使用 SELECT * FROM employees WHERE LEFT(last_name, 3) = \u0026#39;Smi\u0026#39;; 数据类型不一致：\n查询条件中的数据类型与索引列的数据类型不一致时，索引可能失效。 1 2 -- 索引可能失效，因为 \u0026#39;123\u0026#39; 是字符串，而 id 是整数 SELECT * FROM employees WHERE id = \u0026#39;123\u0026#39;; 查询条件的组合问题 OR 条件影响索引使用：\n当查询中使用 OR 条件时，如果 OR 条件中的每个部分都没有单独使用索引，则整个查询不会使用索引。 1 2 -- 索引不会被使用，除非 last_name 和 department_id 上都有单独的索引 SELECT * FROM employees WHERE last_name = \u0026#39;Smith\u0026#39; OR department_id = 5; 不符合最左前缀原则：\n对于复合索引，查询条件必须包含索引的最左前缀，否则索引失效。 1 2 3 -- 复合索引 idx_name_department(last_name, department_id) -- department_id 列不会单独使用索引 SELECT * FROM employees WHERE department_id = 5; 索引选择策略和优化器影响 小表全表扫描：\n对于数据量很小的表，MySQL 优化器可能选择全表扫描，而不是使用索引。 高选择性列上的索引：\n如果索引列的选择性不高（即列中的重复值很多），优化器可能会选择不使用索引。 统计信息不准确：\n当表的数据量变化较大时，索引的统计信息可能变得不准确，需要手动更新统计信息。 1 ANALYZE TABLE employees; 其他影响索引使用的情况 覆盖索引失效：\n如果查询的列无法被索引完全覆盖（即索引无法提供所有需要的列），则覆盖索引可能失效。 1 2 3 -- 如果 idx_name_department 只是 (last_name, department_id) -- 而查询需要其他列 SELECT first_name FROM employees WHERE last_name = \u0026#39;Smith\u0026#39; AND department_id = 5; 前导模糊查询：\n使用前导通配符的模糊查询会导致索引失效。 1 2 -- 索引不会被使用 SELECT * FROM employees WHERE last_name LIKE \u0026#39;%Smith\u0026#39;; 索引例子 下面是一些示例，展示了不同情况下索引的使用与失效：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- 假设有一个复合索引 idx_name_department(last_name, department_id) -- 索引有效 SELECT * FROM employees WHERE last_name = \u0026#39;Smith\u0026#39; AND department_id = 5; -- 索引部分失效，仅 last_name 被使用 SELECT * FROM employees WHERE last_name \u0026gt; \u0026#39;Smith\u0026#39; AND department_id = 5; -- 索引失效，因为使用了函数 SELECT * FROM employees WHERE LEFT(last_name, 3) = \u0026#39;Smi\u0026#39;; -- 索引失效，因为使用了前导通配符 SELECT * FROM employees WHERE last_name LIKE \u0026#39;%Smith\u0026#39;; -- 索引失效，除非 last_name 和 department_id 上都有单独的索引 SELECT * FROM employees WHERE last_name = \u0026#39;Smith\u0026#39; OR department_id = 5; -- 索引失效，因为不符合最左前缀原则 SELECT * FROM employees WHERE department_id = 5; 锁 MySQL 锁是数据库管理系统（DBMS）中用于协调多个用户对数据库资源（如表、行）访问的一种机制。锁的主要作用是确保数据一致性和完整性，同时允许并发访问。以下是 MySQL 锁的一些关键概念和常见类型：\n锁的类型 表级锁（Table Lock）：\n读锁（共享锁，S 锁）：允许多个事务同时读取表中的数据，但任何事务在持有读锁时不能对表进行写操作。 写锁（排他锁，X 锁）：独占锁，只有获得写锁的事务可以读取和修改表中的数据，其他事务不能读或写该表。 1 2 3 4 5 6 -- 加读锁 LOCK TABLES table_name READ; -- 加写锁 LOCK TABLES table_name WRITE; -- 释放锁 UNLOCK TABLES; 行级锁（Row Lock）：\n共享锁（S 锁）：允许多个事务读取一行，但不能修改该行。 排他锁（X 锁）：独占锁，获得排他锁的事务可以读取和修改该行，其他事务不能访问该行。 行级锁是通过 InnoDB 存储引擎实现的，用于提高并发性能。\n锁的粒度 表锁（Table Lock）：锁住整张表，适用于读多写少的场景，开销较小，但并发性较差。 行锁（Row Lock）：锁住表中的某一行，适用于写操作频繁的场景，开销较大，但并发性较好。 锁的机制 自动锁定： InnoDB 存储引擎会在执行 DML 操作（如 SELECT, INSERT, UPDATE, DELETE）时自动加锁。 事务开始时，InnoDB 会自动加上必要的锁，并在事务提交或回滚时释放锁。 显式锁定： 开发者可以使用显式锁定语句来控制锁的行为，适用于需要精细控制锁的场景。 死锁 死锁的定义： 当两个或多个事务相互持有对方所需要的资源并等待对方释放，导致无法继续执行的情况称为死锁。 死锁检测和处理： InnoDB 存储引擎有内置的死锁检测机制，会自动检测并处理死锁，通过回滚其中一个事务来解除死锁。 常用锁相关语句 加锁和解锁：\n1 2 3 4 5 6 -- 加读锁（共享锁） LOCK TABLES table_name READ; -- 加写锁（排他锁） LOCK TABLES table_name WRITE; -- 解锁 UNLOCK TABLES; 事务和锁：\n1 2 3 4 5 6 -- 开始事务 START TRANSACTION; -- 提交事务并释放锁 COMMIT; -- 回滚事务并释放锁 ROLLBACK; 查看锁信息：\n1 2 -- 查看当前锁信息 SHOW ENGINE INNODB STATUS; 锁的最佳实践 尽量使用 InnoDB 存储引擎：因为 InnoDB 支持行级锁，有更高的并发性能和更强的事务支持。 控制事务大小：尽量减少单个事务中的操作数量和时间，避免长事务导致锁定时间过长。 合适的索引：确保查询使用合适的索引，以减少锁定的行数，提高锁的效率。 显式锁定：在必要时使用显式锁定，但要注意控制锁的粒度和范围，以平衡并发性和一致性。 死锁重试机制：在应用程序中实现死锁重试机制，以应对偶发的死锁情况。 锁例子 下面是一些例子，展示了 MySQL 锁的使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 -- 1. 显式表锁 LOCK TABLES employees READ; -- 加读锁 SELECT * FROM employees; UNLOCK TABLES; -- 解锁 -- 2. 使用事务和行级锁 START TRANSACTION; SELECT * FROM employees WHERE id = 1 FOR UPDATE; -- 加排他锁 UPDATE employees SET salary = salary + 1000 WHERE id = 1; COMMIT; -- 3. 死锁重试机制 DELIMITER // CREATE PROCEDURE update_salary() BEGIN DECLARE retry_count INT DEFAULT 0; DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN SET retry_count = retry_count + 1; IF retry_count \u0026lt; 3 THEN ROLLBACK; RESIGNAL; ELSE ROLLBACK; END IF; END; START TRANSACTION; UPDATE employees SET salary = salary + 1000 WHERE id = 1; COMMIT; END // DELIMITER ; 事务 事务的四大特征 原子性（Atomicity）：事务里的内容要么全部成功要么都不成功。 一致性（Consistency）：事务前后数据的完整性保持一致，如：a 给 b 转一千块，事务执行以后，a 和 b 的钱总数是一样的。 隔离性（Isolation）：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 持久性（Durability）：事务结束，数据就持久化到数据库。 并发事务问题 脏读 (Dirty Read) 脏读发生在一个事务能够读取另一个事务尚未提交的数据时。如果第二个事务回滚（撤销）了这些更改，那么第一个事务读取到的数据就变得无效或“脏”了。脏读仅在最低的隔离级别“读未提交”（Read Uncommitted）下会发生。 示例： 事务 A 更新了一行数据，但未提交。 事务 B 读取了这个更新的数据。 事务 A 回滚了更新。 事务 B 读取到的数据现在无效，因为事务 A 的更改没有最终被提交。 不可重复读 (Non-Repeatable Read) 不可重复读问题出现在一个事务在两次读取同一数据时，数据发生了变化。这种情况通常发生在隔离级别“读已提交”（Read Committed）下。 示例： 事务 A 读取了一行数据。 事务 B 更新了该行数据并提交。 事务 A 再次读取同一行数据，发现数据已经发生变化。 幻读 (Phantom Read) 幻读问题发生在一个事务执行两次相同的查询，但第二次查询返回的结果集包含了第一次查询时不存在的“幻影”行。这种情况通常发生在隔离级别“可重复读”（Repeatable Read）下，但可以在“串行化”（Serializable）级别避免。 示例： 事务 A 读取符合某个条件的多行数据。 事务 B 插入了几行满足事务 A 查询条件的新数据并提交。 事务 A 再次执行相同的查询，发现结果集中包含了新插入的行。 四种标准的事务隔离级别 在 MySQL 中，事务隔离级别定义了一个事务在读取数据时与其他并发事务的交互方式。\n读未提交 (Read Uncommitted)：在这个级别，事务可以读取其他事务未提交的数据。允许脏读、不可重复读和幻读。 读已提交 (Read Committed)：在这个级别，事务只能读取已经提交的数据。防止脏读，但允许不可重复读和幻读。 可重复读 (Repeatable Read)：在这个级别，一个事务在开始时看到的数据一致，即使其他事务在该事务执行过程中提交了数据。MySQL 的默认隔离级别是可重复读。防止脏读和不可重复读，但可能允许幻读。 串行化 (Serializable)：在这个级别，所有事务按顺序执行，完全避免并发问题。这会使系统性能下降，但可以避免“脏读”、“不可重复读”和“幻读”。 各个隔离级别之间的关系如下：\n读未提交 \u0026lt; 读已提交 \u0026lt; 可重复读 \u0026lt; 串行化\nMySQL 的默认事务隔离级别是“可重复读”，可以通过以下 SQL 命令查看和设置当前的隔离级别：\n1 2 3 4 5 6 7 8 9 10 11 -- 查看当前会话的隔离级别 SELECT @@tx_isolation; -- 设置当前会话的隔离级别 SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; -- 查看全局隔离级别 SELECT @@global.tx_isolation; -- 设置全局隔离级别 SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ; Spring Boot 中可以通过使用 @Transactional 注解指定某个方法的隔离级别。\n如：\n1 2 3 4 5 6 7 8 9 10 11 import org.springframework.transaction.annotation.Isolation; import org.springframework.transaction.annotation.Transactional; @Service public class YourService { @Transactional(isolation = Isolation.READ_COMMITTED) public void yourTransactionalMethod() { // your transactional code } } 在这个例子中，yourTransactionalMethod 方法的事务隔离级别被设置为 READ_COMMITTED。\nSpring 提供的隔离级别枚举如下，对应于标准的 SQL 隔离级别：\nIsolation.DEFAULT：使用底层数据库的默认隔离级别。 Isolation.READ_UNCOMMITTED：读未提交。 Isolation.READ_COMMITTED：读已提交。 Isolation.REPEATABLE_READ：可重复读。 Isolation.SERIALIZABLE：串行化。 乐(悲)观锁 乐观锁 (Optimistic Lock) 概念：\n乐观锁假设数据在并发环境下很少发生冲突，因此在操作数据时不加锁。乐观锁在提交更新时检查数据是否被其他事务修改，如果数据被修改，则回滚当前事务。\n特点：\n无锁操作：在读取数据时不加锁，只在提交更新时检查冲突。 冲突检测：通过比较版本号或时间戳来检测数据是否被修改。 性能较高：由于没有频繁的加锁和解锁操作，系统性能较高。 适用场景：\n数据争用不严重的场景。 读操作多于写操作的场景。 对性能要求较高的场景。 实现方式：\n乐观锁通常使用版本号或时间戳机制。例如，在数据库表中添加一个 version 字段，每次更新时检查并递增版本号。以下是一个示例：\n假设有一个 accounts 表：\n1 2 3 4 5 CREATE TABLE accounts ( id INT PRIMARY KEY, balance DECIMAL(10, 2), version INT ); 更新操作：\n1 2 3 4 5 6 BEGIN; SELECT balance, version FROM accounts WHERE id = 1; /* Perform some business logic, e.g., balance += 100 */ UPDATE accounts SET balance = balance + 100, version = version + 1 WHERE id = 1 AND version = old_version; COMMIT; 在更新时，检查 version 是否与读取时一致，如果不一致则更新失败，可以通过应用逻辑重试或报错处理。\n悲观锁 (Pessimistic Lock) 概念：\n悲观锁假设数据在并发环境下会发生冲突，因此在操作数据之前会锁定资源，以防止其他事务对数据进行修改。悲观锁通常依赖于数据库的锁机制。\n特点：\n加锁强度高：在读取或写入数据之前，先对数据进行加锁，确保在事务结束之前，其他事务不能对数据进行操作。 阻塞性：如果一个事务对数据加了悲观锁，其他尝试访问该数据的事务会被阻塞，直到锁被释放。 开销大：由于频繁的加锁和解锁操作，会增加系统开销，影响性能。 适用场景：\n数据争用严重的场景。 写操作频繁的场景。 对数据一致性要求极高的场景。 实现方式：\n在 SQL 中可以使用 SELECT ... FOR UPDATE 来实现悲观锁。例如：\n1 2 3 4 BEGIN; SELECT * FROM accounts WHERE id = 1 FOR UPDATE; /* Perform updates */ COMMIT; 乐(悲)观锁总结 悲观锁：通过加锁确保数据一致性，适用于高争用环境，但性能开销较大。 乐观锁：通过版本控制或时间戳检测数据冲突，适用于低争用环境，性能较好，但需要处理冲突。 选择使用哪种锁机制，应根据具体应用的并发情况、数据访问模式和性能需求来决定。\nMVCC（多版本并发控制） 多版本并发控制 (MVCC, Multi-Version Concurrency Control) 是一种用于数据库管理系统的并发控制机制，它允许多个事务并发地执行而不会互相阻塞，同时提供一致的读和写操作。MVCC 通过维护数据的多个版本来实现，避免了许多传统锁机制带来的性能开销。\nMVCC 的工作原理 MVCC 通过为每个数据项保存多个版本，并为每个事务分配一个唯一的时间戳或事务 ID (Transaction ID, TID)，来管理并发事务。以下是 MVCC 的主要工作原理：\n版本链： 每个数据项都有一个版本链，链中包含该数据项的所有历史版本。每个版本包含数据值和相关的元数据（如创建时间戳和删除时间戳）。 读取操作： 当事务读取数据时，它会查找与自己的时间戳匹配的最新版本。这意味着事务只会看到在其开始之前已经提交的版本，不会被其他并发事务未提交的修改所影响。 写入操作： 当事务修改数据时，它不会覆盖现有版本，而是创建一个新版本，并将其添加到版本链中。新版本会带有事务的时间戳，表明它是由该事务创建的。 提交和回滚： 当事务提交时，创建的新版本会成为可见版本。如果事务回滚，创建的新版本会被标记为无效，不会影响其他事务。 MVCC 的优点 减少锁竞争： 由于读操作不会阻塞写操作，写操作也不会阻塞读操作，MVCC 有效地减少了锁竞争，提高了系统的并发性能。 一致性读取： 事务在读取数据时，总是能够看到一致的视图，不会被其他并发事务的未提交修改所影响，避免了脏读。 提升性能： 由于读操作不需要加锁，系统的读性能得到显著提升。写操作创建新版本而不是覆盖旧版本，也提高了写操作的效率。 MVCC 处理的并发问题 避免脏读： 读操作只看到已经提交的数据版本，因此避免了读取未提交数据带来的脏读问题。 避免不可重复读： 事务在读取同一数据项时，总是能够看到一致的版本，避免了同一事务中多次读取到不同数据的问题。 幻读： MVCC 在某些数据库系统中可以避免幻读问题。通过使用 MVCC 和合适的隔离级别（如可重复读或串行化），可以确保查询结果集的一致性。 MVCC 的实现 不同数据库系统对 MVCC 的实现有所不同。以下是几种流行数据库的 MVCC 实现方式：\nPostgreSQL： PostgreSQL 使用事务 ID (XID) 和隐藏字段来实现 MVCC。每个数据行都有两个隐藏字段，分别表示创建该行的事务 ID 和删除该行的事务 ID。 MySQL (InnoDB 存储引擎)： InnoDB 使用 undo log 和事务 ID 来实现 MVCC。每个数据行都有一个隐藏的事务 ID 和回滚指针，用于指向前一个版本的数据。 Oracle： Oracle 使用回滚段来存储旧版本的数据，当需要读取旧版本时，通过回滚段获取数据的历史版本。 MVCC 总结 MVCC 是一种强大的并发控制机制，通过维护数据的多个版本，实现高效的并发事务处理。它有效地减少了锁竞争，提高了系统的性能和一致性，是现代数据库系统中广泛应用的技术。\nEXPLAIN EXPLAIN 是 MySQL 提供的一种分析工具，用于查看 SQL 查询的执行计划。它显示了查询优化器是如何执行 SQL 语句的，帮助开发人员优化查询性能。以下是 EXPLAIN 的用法和解释。\n基本用法 EXPLAIN SELECT * FROM table_name WHERE condition;\nEXPLAIN 会显示查询的执行计划，包括使用的索引、连接类型、扫描的行数等。\n输出列的含义 执行 EXPLAIN 后，结果集包含多个列，每一列都有特定的含义：\nid：查询的标识符。每个 SELECT 子句或子查询都会分配一个唯一的 id。\nselect_type：查询的类型。常见类型包括：\nSIMPLE：简单的 SELECT 查询，不包含子查询或 UNION。 PRIMARY：最外层的 SELECT 查询。 SUBQUERY：子查询中的 SELECT。 DERIVED：派生表（子查询中的 FROM 子句）。 UNION：UNION 中的第二个或后续的 SELECT 查询。 UNION RESULT：UNION 的结果集。 table：查询的表。\npartitions：查询涉及的分区（如果有）。\ntype：连接类型，表示查询中的表如何连接。连接类型的效率从高到低依次为：\nsystem：表只有一行（系统表）。 const：表最多只有一行匹配（常量）。 eq_ref：对于每个来自前一个表的行，读取一行。 ref：对于每个来自前一个表的行，读取匹配几行。 range：只检索给定范围的行，使用索引选择行。 index：全索引扫描。 ALL：全表扫描。 possible_keys：查询中可能使用的索引。\nkey：查询实际使用的索引。\nkey_len：使用的索引的长度。\nref：使用的列或常量与索引比较。\nrows：MySQL 估计要读取的行数。\nfiltered：查询条件过滤的行的百分比。\nExtra：其他信息，比如：\nUsing index：查询使用了覆盖索引。 Using where：查询使用了 WHERE 子句来过滤行。 Using temporary：查询使用了临时表。 Using filesort：查询使用了文件排序。 示例分析 简单查询 EXPLAIN SELECT * FROM employees WHERE id = 1;\n结果可能显示：\nid select_type table type possible_keys key key_len ref rows filtered Extra 1 SIMPLE employees const PRIMARY PRIMARY 4 const 1 100.00 Using where 解释：\nid 为 1，表示这是一个简单查询。 select_type 为 SIMPLE，没有子查询。 table 为 employees，表示查询的表。 type 为 const，因为 id 是主键，这是一个常量查询。 possible_keys 和 key 都是 PRIMARY，表示使用了主键索引。 rows 为 1，表示预计扫描一行。 Extra 为 Using where，表示使用了 WHERE 子句。 连接查询 EXPLAIN SELECT e.*, d.dept_name FROM employees e JOIN departments d ON e.dept_id = d.dept_id;\n结果可能显示：\nid select_type table type possible_keys key key_len ref rows filtered Extra 1 SIMPLE d ALL PRIMARY NULL NULL NULL 10 100.00 1 SIMPLE e ref dept_id dept_id 4 d.dept_id 100 100.00 Using where 解释：\n第一个 id 为 1 的行表示对 departments 表的全表扫描（type 为 ALL）。 第二个 id 为 1 的行表示对 employees 表的引用（type 为 ref），使用了 dept_id 索引。 rows 列表明 MySQL 预计从 departments 表中读取 10 行，并从 employees 表中读取 100 行。 优化建议 使用合适的索引：确保查询中使用了合适的索引，以减少扫描的行数。 避免全表扫描：尽量避免 type 为 ALL 的全表扫描，可以通过增加索引来优化。 优化连接类型：尽量使用效率较高的连接类型，如 ref、eq_ref 等。 减少临时表和文件排序：避免 Extra 列中出现 Using temporary 和 Using filesort，可以通过优化查询或增加索引来实现。 通过合理使用 EXPLAIN 分析查询执行计划，可以发现查询性能的瓶颈，并进行相应的优化。\n","date":"2025-02-11T14:50:48+08:00","permalink":"https://www.lcsk42.com/post/database-mysql/","title":"Database Mysql"},{"content":"介绍一下服务器中服务管理的方法。\n服务器服务管理 管理技术选型 在服务器服务管理中，选择合适的管理技术至关重要。当前，虚拟化技术因其高效性和灵活性，成为管理容器的首选方案。基于此，Docker 被选为运行各项服务的基础平台。Docker 不仅提供了轻量级的虚拟化环境，还能确保应用在不同环境中的一致性，极大地简化了部署和迁移过程。\n然而，直接使用 docker run 命令来运行各个服务存在一定的局限性，尤其是在服务数量增多时，难以进行有效的归类整理和统一管理。为了解决这一问题，docker-compose 被选为服务管理工具。docker-compose 允许通过一个简单的 YAML 文件定义和管理多个容器，极大地提高了服务的可维护性和可扩展性。\n关于为什么不使用 Kubernetes (k8s) 或 k3s 等更复杂的容器编排系统，主要原因在于它们的体量较大，适合大规模、高可用性的生产环境。在企业生产实践中，为了保证服务的高可用性，通常会采用多实例部署，并依赖滚动更新、自动重启等功能。然而，对于当前场景，服务的体量较小，且对高可用性的要求相对较低。更倾向于在服务出现问题时，通过及时通知和手动干预来恢复服务，而不是依赖复杂的自动化机制。因此，选择 docker-compose 不仅简化了管理流程，还降低了系统的复杂性和维护成本。\n综上所述，基于当前的需求和技术特点，使用 Docker 结合 docker-compose 是一种既高效又实用的服务器服务管理方案。\n文件夹结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 - deployment-configs |-- scripts # 用于管理服务的实用程序脚本 | |-- start-all.sh # 启动所有服务 | |-- stop-all.sh # 关闭所有服务 |-- services # 包含各个服务的配置 | |-- bark # bark 通知服务 | | |-- data # bark 数据存醋 | | |-- docker-compose.yml # bark 启动配置 | |-- mysql # mysql 数据库 | | |-- data # mysql 数据存醋 | | |-- docker-compose.yml # mysql 启动配置 | | |-- logs # mysql 日志文件位置 | | |-- my.cnf # mysql 相关配置 |-- shared # 包括环境变量和网络设置等共享配置 | |-- common.env # 通用环境变量 |-- README.md # 介绍各个服务和相关命令 提供一下脚本，可直接执行，创建响应的目录结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 # 创建根目录 mkdir -p deployment-configs # 进入根目录 cd deployment-configs # 创建 scripts 目录及其文件 mkdir -p scripts # 创建 start-all.sh 文件 touch scripts/start-all.sh # 写入以下内容到 start-all.sh 文件 cat \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; \u0026gt; scripts/start-all.sh #!/usr/bin/env bash # Start all services defined in the \u0026#39;services\u0026#39; directory echo \u0026#34;Starting all services...\u0026#34; # Loop through each service directory and bring up the service for service in services/*; do if [ -d \u0026#34;$service\u0026#34; ]; then echo \u0026#34;Starting service: $service\u0026#34; cd \u0026#34;$service\u0026#34; || continue docker-compose up -d cd - || continue fi done echo \u0026#34;All services started.\u0026#34; EOF # 创建 stop-all.sh 文件 touch scripts/stop-all.sh # 写入 stop-all.sh 内容 cat \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; \u0026gt; scripts/stop-all.sh #!/usr/bin/env bash # Stop all services defined in the \u0026#39;services\u0026#39; directory echo \u0026#34;Stopping all services...\u0026#34; # Loop through each service directory and bring down the service for service in services/*; do if [ -d \u0026#34;$service\u0026#34; ]; then echo \u0026#34;Stopping service: $service\u0026#34; cd \u0026#34;$service\u0026#34; || continue docker-compose down cd - || continue fi done echo \u0026#34;All services stopped.\u0026#34; EOF # 创建 services 目录 mkdir -p services/ # 创建 shared 目录及其文件 mkdir -p shared touch shared/common.env # 创建 README.md 文件 touch README.md cat \u0026lt;\u0026lt; \u0026#39;EOF\u0026#39; \u0026gt; README.md # Deployment Configs ## Overview This repository contains configuration files and setups for deploying services using Docker Compose. It is organized into modular directories for individual services and shared resources. ## Structure - `services/`: Contains configurations for individual services. - `shared/`: Includes shared configurations such as environment variables and network settings. - `scripts/`: Utility scripts for managing services. EOF # 设置文件权限（可选） chmod +x scripts/start-all.sh chmod +x scripts/stop-all.sh 如何保留空文件夹 在使用 Git 进行服务管理和同步时，通常不希望将 data、logs 等文件夹中的文件同步到远程仓库，因为这些文件可能包含临时数据或敏感信息。为了避免这些文件被同步，可以通过配置 .gitignore 文件来忽略它们，例如：\n1 2 3 4 **/data/* **/logs/* **/cert/* **/nginx/files/** 然而，配置忽略规则后，在推送代码到远程仓库或从远程仓库拉取代码时，这些文件夹将不会被创建。这可能导致在运行 docker-compose up -d 启动服务时出现问题，因为某些服务可能依赖这些文件夹的存在。\n为了解决这一问题，既需要避免将文件夹中的文件同步到远程仓库，又需要确保这些空文件夹能够被传输到远程并在拉取时保留，可以在每个需要保留的文件夹中添加一个 .gitignore 文件，并在其中配置规则，使其不忽略自身。具体方法如下：\n1 echo -e \u0026#39;*\\n!.gitignore\u0026#39; \u0026gt;\u0026gt; .gitignore 上述命令会在 .gitignore 文件中添加两行内容：第一行 * 表示忽略该文件夹中的所有文件，第二行 !.gitignore 表示不忽略 .gitignore 文件本身。这样，Git 会保留空文件夹及其中的 .gitignore 文件，同时忽略其他文件，从而满足服务启动时的依赖需求。\n通过这种方式，既避免了不必要文件的同步，又确保了文件夹结构的完整性。\n","date":"2025-02-04T13:00:32+08:00","permalink":"https://www.lcsk42.com/post/deployment-configs/","title":"服务器服务管理"},{"content":"介绍 Docker Compose 服务依赖和健康检查相关知识。\n概念介绍 什么是服务依赖？ 服务启动有先后顺序，B 依赖 A，如部署 Service 服务一般需要依赖 Database, 这时我们需要先启动数据库，再启动我们的应用程序。\n如何使用服务依赖？ 在 docker-compose.yml 中指定 depends_on 参数可以指定容器的启动顺序，B 服务要晚于 A 服务启动，则需要在 B 服务配置 depends_on A 服务。\n什么是健康检查？ 容器启动后，判断其是否可以正常对外提供服务，不能服务启动了是 up 状态，但是里面的服务一直在报错，这样事实上是启动有问题的，这个就是健康检查。\n如何进行健康检查？ 容器本身提供的有健康检查，可以在服务启动时，或者 Dockerfile 中指定相关参数, 不过使用更多的还是直接在 docker-compose.yml 中指定。\n服务启动时：\n1 2 3 4 5 6 7 8 9 10 --health-cmd string Command to run to check health --health-interval duration Time between running the check (ms|s|m|h) (default 0s) --health-retries int Consecutive failures needed to report unhealthy --health-start-period duration Start period for the container to initialize before starting health-retries countdown (ms|s|m|h) (default 0s) --health-timeout duration Maximum time to allow one check to Dockerfile 指定：\n1 2 3 4 5 6 7 8 9 HEALTHCHECK [OPTIONS] CMD command The options that can appear before CMD are: --interval=DURATION (default: 30s) --timeout=DURATION (default: 30s) --start-period=DURATION (default: 0s) --start-interval=DURATION (default: 5s) --retries=N (default: 3) docker-compose 方式指定:\n1 2 3 4 5 6 7 8 9 10 healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;curl\u0026#34;, \u0026#34;http://127.0.0.1:8080\u0026#34; ] # healthcheck 间隔时间 interval: 10s # 执行命令超时时间 timeout: 3s # 重试次数 retries: 5 # 容器启动多久后开始执行 healthcheck start_period: 10s 两者的结合？ 我们实际使用中遇到的情况可能是，B 服务依赖 A 服务，但是 A 服务开始启动之后，实际需要耗时一段时间（初始化数据等操作），此时如果直接启动 B 服务，就会报错，所以我们需要在 A 服务启动成功，能对外提供服务时，才开始启动 B 服务。\n1 2 3 4 5 6 7 异常情况(只使用 depends_on)：B 服务 需要访问 A 服务时，A 服务还在启动中，B 服务报错 A [-----created-----](up)[-----starting-----][-----running-----] B [-created-][-starting-][-error-] 正确情况: A 服务启动完成后，开始对外提供服务，开始启动 B 服务 A [-----created-----][-----starting-----](healthy)[-----running-----] B [-created-] [-starting-][-error-] 如何解决？ 在 A 服务中配置健康检查，在 B 服务的服务依赖中配置 A 服务的服务状态为健康。\n1 2 3 4 5 6 7 8 9 10 11 12 services: serviceA: healthcheck: test: [\u0026#39;CMD\u0026#39;, \u0026#39;curl\u0026#39;, \u0026#39;http://127.0.0.1:8080\u0026#39;] interval: 10s timeout: 3s retries: 5 start_period: 10s serviceB: depends_on: serviceA: condition: service_healthy 具体示例 请注意：此文件仅作为测试使用，无实际意义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 docker-compose down cat \u0026gt; docker-compose.yml \u0026lt;\u0026lt; EOF version: \u0026#39;3.9\u0026#39; services: mysql8: image: mysql:8 environment: - MYSQL_ROOT_PASSWORD=lucas healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;mysql\u0026#34;, \u0026#34;-u\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;-plucas\u0026#34;, \u0026#34;-e\u0026#34;, \u0026#34;select 1\u0026#34; ] interval: 10s timeout: 3s retries: 5 start_period: 10s tomcat9: image: tomcat:9 depends_on: mysql8: condition: service_healthy healthcheck: test: [ \u0026#34;CMD\u0026#34;, \u0026#34;curl\u0026#34;, \u0026#34;http://127.0.0.1:8080\u0026#34; ] interval: 10s timeout: 3s retries: 5 start_period: 10s EOF docker-compose up -d 正常启动日志 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [+] Running 0/3 ⠇ Network docker_default Created 1.9s ⠇ Container docker-mysql8-1 Waiting 1.9s ⠇ Container docker-tomcat9-1 Created [+] Running 2/3 ⠹ Network docker_default Created 11.2s ✔ Container docker-mysql8-1 Healthy 10.9s ✔ Container docker-tomcat9-1 Started 11.1s ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 33036c106e99 tomcat:9 \u0026#34;catalina.sh run\u0026#34; 16 seconds ago Up 5 seconds (health: starting) 8080/tcp docker-tomcat9-1 5f778d7b5c8d mysql:8 \u0026#34;docker-entrypoint.s…\u0026#34; 16 seconds ago Up 15 seconds (healthy) 3306/tcp, 33060/tcp docker-mysql8-1 ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 33036c106e99 tomcat:9 \u0026#34;catalina.sh run\u0026#34; 22 seconds ago Up 11 seconds (healthy) 8080/tcp docker-tomcat9-1 5f778d7b5c8d mysql:8 \u0026#34;docker-entrypoint.s…\u0026#34; 22 seconds ago Up 22 seconds (healthy) 3306/tcp, 33060/tcp docker-mysql8-1 启动过程分析 刚开始启动时，docker-mysql8-1 在 Waiting 中。等待启动后的服务检查，docker-tomcat9-1 处于 Created (容器创建了，再等待启动) docker-mysql8-1 状态为 Healthy(启动成功，健康检查正常)，此时 docker-tomcat9-1 开始启动 刚开始查看服务状态时，docker-tomcat9-1 服务的 STATUS 为 (health: starting) 过了一段时间后，docker-tomcat9-1 服务的 STATUS 变为 (health) 健康检查失败日志 我们修改 mysql 的健康检查语句，使其执行失败，查看如果健康检查失败会是什么结果\n1 2 3 4 [dependencies.bevy] docker-compose.yml - \u0026#34;-plucas\u0026#34;, + \u0026#34;-perrorpassword\u0026#34;, 1 2 3 4 5 6 7 8 9 10 11 12 [+] Running 1/3 ⠧ Network docker_default Created 50.8s ✘ Container docker-mysql8-1 Error 50.7s ⠧ Container docker-tomcat9-1 Created 50.7s dependency failed to start: container docker-mysql8-1 is unhealthy ❯ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 868b161494b0 mysql:8 \u0026#34;docker-entrypoint.s…\u0026#34; 57 seconds ago Up 57 seconds (unhealthy) 3306/tcp, 33060/tcp docker-mysql8-1 ❯ docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 52c90d95d7e9 tomcat:9 \u0026#34;catalina.sh run\u0026#34; About a minute ago Created docker-tomcat9-1 868b161494b0 mysql:8 \u0026#34;docker-entrypoint.s…\u0026#34; About a minute ago Up About a minute (unhealthy) 3306/tcp, 33060/tcp docker-mysql8-1 失败日志分析 首先启动时，docker-tomcat9-1 一直在等待，docker-mysql8-1 最终创建失败，耗时 50s (interval 10s * retries 5) 左右 使用 docker ps -a 可以查看所有的容器状态，可以看到 docker-mysql8-1 为 unhealthy, docker-tomcat9-1 为 Created 并未启动 如何查看分析错误 使用 docker 的 inspect 命令, 在 State.Health.Log 中可以看到相关错误信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 ❯ docker inspect docker-mysql8-1 [ { ... \u0026#34;State\u0026#34;: { \u0026#34;Status\u0026#34;: \u0026#34;running\u0026#34;, \u0026#34;Running\u0026#34;: true, \u0026#34;Paused\u0026#34;: false, \u0026#34;Restarting\u0026#34;: false, \u0026#34;OOMKilled\u0026#34;: false, \u0026#34;Dead\u0026#34;: false, \u0026#34;Pid\u0026#34;: 35046, \u0026#34;ExitCode\u0026#34;: 0, \u0026#34;Error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;StartedAt\u0026#34;: \u0026#34;2024-05-31T18:13:03.413731054Z\u0026#34;, \u0026#34;FinishedAt\u0026#34;: \u0026#34;0001-01-01T00:00:00Z\u0026#34;, \u0026#34;Health\u0026#34;: { \u0026#34;Status\u0026#34;: \u0026#34;unhealthy\u0026#34;, \u0026#34;FailingStreak\u0026#34;: 39, \u0026#34;Log\u0026#34;: [ { \u0026#34;Start\u0026#34;: \u0026#34;2024-06-01T02:18:54.821003238+08:00\u0026#34;, \u0026#34;End\u0026#34;: \u0026#34;2024-06-01T02:18:54.860412275+08:00\u0026#34;, \u0026#34;ExitCode\u0026#34;: 1, \u0026#34;Output\u0026#34;: \u0026#34;mysql: [Warning] Using a password on the command line interface can be insecure.\\nERROR 1045 (28000): Access denied for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; (using password: YES)\\n\u0026#34; }, { \u0026#34;Start\u0026#34;: \u0026#34;2024-06-01T02:19:04.862050738+08:00\u0026#34;, \u0026#34;End\u0026#34;: \u0026#34;2024-06-01T02:19:04.905490712+08:00\u0026#34;, \u0026#34;ExitCode\u0026#34;: 1, \u0026#34;Output\u0026#34;: \u0026#34;mysql: [Warning] Using a password on the command line interface can be insecure.\\nERROR 1045 (28000): Access denied for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; (using password: YES)\\n\u0026#34; }, { \u0026#34;Start\u0026#34;: \u0026#34;2024-06-01T02:19:14.907068839+08:00\u0026#34;, \u0026#34;End\u0026#34;: \u0026#34;2024-06-01T02:19:14.941198241+08:00\u0026#34;, \u0026#34;ExitCode\u0026#34;: 1, \u0026#34;Output\u0026#34;: \u0026#34;mysql: [Warning] Using a password on the command line interface can be insecure.\\nERROR 1045 (28000): Access denied for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; (using password: YES)\\n\u0026#34; }, { \u0026#34;Start\u0026#34;: \u0026#34;2024-06-01T02:19:24.94265745+08:00\u0026#34;, \u0026#34;End\u0026#34;: \u0026#34;2024-06-01T02:19:24.980647633+08:00\u0026#34;, \u0026#34;ExitCode\u0026#34;: 1, \u0026#34;Output\u0026#34;: \u0026#34;mysql: [Warning] Using a password on the command line interface can be insecure.\\nERROR 1045 (28000): Access denied for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; (using password: YES)\\n\u0026#34; }, { \u0026#34;Start\u0026#34;: \u0026#34;2024-06-01T02:19:34.983078462+08:00\u0026#34;, \u0026#34;End\u0026#34;: \u0026#34;2024-06-01T02:19:35.023463408+08:00\u0026#34;, \u0026#34;ExitCode\u0026#34;: 1, \u0026#34;Output\u0026#34;: \u0026#34;mysql: [Warning] Using a password on the command line interface can be insecure.\\nERROR 1045 (28000): Access denied for user \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; (using password: YES)\\n\u0026#34; } ] } }, ... } ] ","date":"2024-06-01T10:06:34+08:00","permalink":"https://www.lcsk42.com/post/docker-depend-and-health/","title":"Docker Compose 服务依赖和健康检查"},{"content":"翻译自Apache 官网 OGNL的语言指南。\nObject-Graph Navigation Language (OGNL) is an open-source Expression Language (EL) for Java, which, while using simpler expressions than the full range of those supported by the Java language, allows getting and setting properties (through defined setProperty and getProperty methods, found in JavaBeans), and execution of methods of Java classes. It also allows for simpler array manipulation.\n\u0026ndash; Wikipedia OGNL\n对象图导航语言(OGNL)是 Java 的开源表达式语言(EL)，它是所有 Java 语言支持范围中最简单的表达式，它允许获取和设置属性(通过 JavaBeans 中定义的 setProperty 和 getProperty 方法)以及执行 Java 类的方法。它还允许更简单的数组操作。\nSyntax(语法) Basic OGNL expressions are very simple. The language has become quite rich with features, but you don\u0026rsquo;t generally need to worry about the more complicated parts of the language: the simple cases have remained that way. For example, to get at the name property of an object, the OGNL expression is simply name. To get at the text property of the object returned by the headline property, the OGNL expression is headline.text.\n基础的 OGNL 表达式非常简单，虽然该语言现在的特性已经变得非常丰富，但是你通常不需要担心语言中更复杂的部分：简单的情况下跟之前是一样的。例如：要获取对象的 name 属性，OGNL 的表达式就是简单的 name。要获取 headline 属性中的文本对象，OGNL 的表达式就是 headline.text。\nWhat is a property? Roughly, an OGNL property is the same as a bean property, which means that a pair of get/set methods, or alternatively a field, defines a property (the full story is a bit more complicated, since properties differ for different kinds of objects; see below for a full explanation).\n什么是属性呢？大致来讲，OGNL 的属性跟 bean 对象的属性是完全相同的，这意味着一对 get/set 方法或者一个字段定义了一个属性(完整的情况会更加复杂，因为对象有不同类型的属性，详见下文的解释)。\nThe fundamental unit of an OGNL expression is the navigation chain, usually just called \u0026ldquo;chain.\u0026rdquo; The simplest chains consist of the following parts:\nOGNL 表达式的基本单元是导航链，简称：“链”，最简单的链由下面几部分组成：\nExpression Element Part Example Property names like the name and headline.text examples above Method Calls hashCode() to return the current object\u0026rsquo;s hash code Array Indices listeners[0] to return the first of the current object\u0026rsquo;s list of listeners 表达式元素部分 示例 属性名称 上方举例的 name 和 headline.text 方法调用 hashCode() 返回当前对象的哈希值 数组索引 listeners[0] 返回 listeners 列表中的第一个对象 All OGNL expressions are evaluated in the context of a current object, and a chain simply uses the result of the previous link in the chain as the current object for the next one. You can extend a chain as long as you like. For example, this chain:\n所有 OGNL 表达式都在当前对象的上下文中求值,链中使用前一个链的返回结果作为当前链的当前对象，也就是支持链式调用，你想把链拉多长都可以，例如，下面这条链：\n1 name.toCharArray()[0].numericValue.toString() This expression follows these steps to evaluate:\n这个表达式按照下面的步骤进行求值：\nextracts the name property of the initial, or root, object (which the user provides to OGNL through the OGNL context); calls the toCharArray() method on the resulting String; extracts the first character (the one at index 0) from the resulting array; gets the numericValue property from that character (the character is represented as a Character object, and the Character class has a method called getNumericValue()); calls toString() on the resulting Integer object. The final result of this expression is the String returned by the last toString() call. 提取初始对象或根对象(root)（用户通过 OGNL 上下文传递给 OGNL）的 name 属性 在返回的结果字符串上调用 toCharArray() 方法 从返回的结果数组中提取第一个字符（索引为 0 的字符） 从这个字符中获取 numericValue 属性(字符代表 Character 对象，Character 类有一个方法叫 getNumericValue())。 在返回结果的 Integer 对象上调用 toString() 方法。这个表达式最终的返回结果是 toString() 方法的返回的字符串。 Note that this example can only be used to get a value from an object, not to set a value. Passing the above expression to the Ognl.setValue() method would cause an InappropriateExpressionException to be thrown, because the last link in the chain is neither a property name nor an array index.\n请注意，这个示例只能用于从对象中获取值，而不能用于设置值。将上述表达式传递给 Ognl.setValue() 方法将会抛出 InappropriateExpressionException 异常，因为链中的最后一个链接并不是属性名，也不是数组索引。\nThis is enough syntax to do the vast majority of what you ever need to do.\n但是这种语法已经足够满足大多数工作所需。\nExpressions(表达式) This section outlines the details the elements of OGNL\u0026rsquo;s expressions.\n本章将详细介绍 OGNL 表达式的各种细节。\nConstants(常量) OGNL has the following kinds of constants:\nOGNL 有以下几种常量：\nString literals, as in Java (with the addition of single quotes): delimited by single- or double-quotes, with the full set of character escapes; Character literals, also as in Java: delimited by single-quotes, also with the full set of escapes; Numeric literals, with a few more kinds than Java. In addition to Java\u0026rsquo;s ints, longs, floats and doubles, OGNL lets you specify BigDecimals with a \u0026ldquo;b\u0026rdquo; or \u0026ldquo;B\u0026rdquo; suffix, and BigIntegers with an \u0026ldquo;h\u0026rdquo; or \u0026ldquo;H\u0026rdquo; suffix (think \u0026ldquo;huge\u0026rdquo;\u0026mdash;we chose \u0026ldquo;h\u0026rdquo; for BigIntegers because it does not interfere with hexadecimal digits); Boolean (true and false) literals; The null literal. 字符串字面值，如在 Java (另增加单引号)中：由单引号或双引号包裹，并且带有完整的转义集； 字符字面量，也和 Java 中一样：被单引号分割，也带有全套的转义； 数字字面值，比 Java 中多了一些类型，除了 Java 中的整型、长型、浮点数和双精度浮点数外，OGNL 还允许你指定带有 \u0026ldquo;b\u0026rdquo; 或 \u0026ldquo;b\u0026rdquo; 后缀的 BigDecimals，以及带有 \u0026ldquo;h\u0026rdquo; 或 \u0026ldquo;h\u0026rdquo; 后缀的 BigIntegers(考虑 \u0026ldquo;huge\u0026rdquo; ——我们选择 \u0026ldquo;h\u0026rdquo; 表示 BigIntegers，因为它并不会干扰十六进制数字)； 布尔(真和假)字面值； 空文字。 Referring to Properties(引用属性) OGNL treats different kinds of objects differently in its handling of property references. Maps treat all property references as element lookups or storage, with the property name as the key. Lists and arrays treat numeric properties similarly, with the property name as the index, but string properties the same way ordinary objects do. Ordinary objects (that is, all other kinds) only can handle string properties and do so by using \u0026ldquo;get\u0026rdquo; and \u0026ldquo;set\u0026rdquo; methods (or \u0026ldquo;is\u0026rdquo; and \u0026ldquo;set\u0026rdquo;), if the object has them, or a field with the given name otherwise.\nOGNL 在处理属性引用时以不同的方式对待不同类型的对象。使用属性名将所有属性映射为对象进行查找或存储。列表和数组使用同样的方式用索引(index)作为属性名处理数字属性。而处理字符串属性的方式与普通对象相同，普通对象(即所有其他类型的对象)如果有 \u0026ldquo;get\u0026rdquo; 和 \u0026ldquo;set\u0026rdquo; 方法(或 \u0026ldquo;is\u0026rdquo; 和 \u0026ldquo;set\u0026rdquo;)，则只能通过使用处理字符串属性，如果没有则使用给定的字段名称处理字符串属性。\nNote the new terminology here. Property \u0026ldquo;names\u0026rdquo; can be of any type, not just Strings. But to refer to non-String properties, you must use what we have been calling the \u0026ldquo;index\u0026rdquo; notation. For example, to get the length of an array, you can use this expression:\n注意这里的新术语。属性 \u0026ldquo;name\u0026rdquo; 可以是任何类型，而不仅仅是字符串。但是要引用非字符串属性，必须使用我们一直称为 \u0026ldquo;index\u0026rdquo; 的符号。例如，要获取一个数组的长度，你可以使用这个表达式:\n1 array.length But to get at element 0 of the array, you must use an expression like this:\n但是要获取数组的第 0 个元素，你必须使用这样的表达式:\n1 array[0] Note that Java collections have some special properties associated with them.\n注意，Java 集合有一些与之关联的特殊属性。\nIndexing(索引) As discussed above, the \u0026ldquo;indexing\u0026rdquo; notation is actually just property reference, though a computed form of property reference rather than a constant one.\n如上所述，\u0026ldquo;indexing\u0026rdquo; 表示法实际上只是属性引用，尽管是一种计算形式的属性引用，而不是常数形式。\nFor example, OGNL internally treats the \u0026ldquo;array.length\u0026rdquo; expression exactly the same as this expression:\n例如，OGNL 在内部处理 \u0026ldquo;array.length\u0026rdquo; 表达式与这个表达式完全相同:\n1 array[\u0026#34;length\u0026#34;] And this expression would have the same result (though not the same internal form):\n而这个表达式会有相同的结果(尽管内部形式不同):\n1 array[\u0026#34;len\u0026#34; + \u0026#34;gth\u0026#34;] Array and List Indexing(数组和列表索引)\nFor Java arrays and Lists indexing is fairly simple, just like in Java. An integer index is given and that element is the referrent. If the index is out of bounds of the array or List and IndexOutOfBoundsException is thrown, just as in Java.\n对于 Java 数组(arrays)和列表(Lists)来说索引(indexing)相当简单，和在 Java 中一样，给出一个整数索引就能的到元素的引用对象。如果索引超出数组或列表的边界，则抛出 IndexOutOfBoundsException 异常，也和 Java 中一样。\nJavaBeans Indexed Properties(JavaBeans 索引属性)\nJavaBeans supports the concept of Indexed properties. Specifically this means that an object has a set of methods that follow the following pattern:\nJavaBeans 也支持索引属性的概念。具体来说，这意味着一个对象会有一组遵循以下模式的方法:\npublic PropertyType[] getPropertyName(); public void setPropertyName(PropertyType[] anArray); public PropertyType getPropertyName(int index); public void setPropertyName(int index, PropertyType value); OGNL can interpret this and provide seamless access to the property through the indexing notation. References such as\nOGNL 可以解释这一点，并通过索引符号提供对属性的无缝访问。\n1 someProperty[2] are automatically routed through the correct indexed property accessor (in the above case through getSomeProperty(2) or setSomeProperty(2, value)). If there is no indexed property accessor a property is found with the name someProperty and the index is applied to that.\n诸如此类的引用会自动通过正确的索引属性访问器进行路由（在上述情况下通过 getSomeProperty(2) 或 setSomeProperty(2, value)）。 如果没有索引属性访问器，则会找到名为 someProperty 的属性，并将索引应用于该属性。\nOGNL Object Indexed Properties(OGNL 对象索引属性)\nOGNL extends the concept of indexed properties to include indexing with arbitrary objects, not just integers as with JavaBeans Indexed Properties. When finding properties as candidates for object indexing, OGNL looks for patterns of methods with the following signature:\nOGNL 扩展了索引属性的概念，包括对任意对象进行索引，而不仅仅是像 JavaBeans 索引属性那样对整数进行索引。 当查找属性作为对象索引的候选时，OGNL 会查找具有以下签名的方法模式：\npublic PropertyType getPropertyName(IndexType index); public void setPropertyName(IndexType index, PropertyType value); The PropertyType and IndexType must match each other in the corresponding set and get methods. An actual example of using Object Indexed Properties is with the Servlet API: the Session object has two methods for getting and setting arbitrary attributes:\nPropertyType 和 IndexType 在相应的 set 和 get 方法中必须相互匹配。 使用对象索引属性的一个实际示例是 Servlet API：Session 对象有两种获取和设置任意属性的方法：\n1 2 public Object getAttribute(String name); public void setAttribute(String name, Object value); An OGNL expression that can both get and set one of these attributes is:\n可以获取和设置这些属性之一的 OGNL 表达式是:\n1 session.attribute[\u0026#34;foo\u0026#34;] Calling Methods(调用方法) OGNL calls methods a little differently from the way Java does, because OGNL is interpreted and must choose the right method at run time, with no extra type information aside from the actual arguments supplied. OGNL always chooses the most specific method it can find whose types match the supplied arguments; if there are two or more methods that are equally specific and match the given arguments, one of them will be chosen arbitrarily.\nOGNL 调用方法的方式与 Java 的方式略有不同，因为 OGNL 是解释性的，并且必须在运行时选择正确的方法，除了提供的实际参数之外，没有额外的类型信息。 OGNL 总是选择它能找到的最具体的方法，其类型与提供的参数相匹配； 如果有两个或多个同样具体且与给定参数匹配的方法，则将任意选择其中之一。\nIn particular, a null argument matches all non-primitive types, and so is most likely to result in an unexpected method being called.\n特别是，空参数匹配所有非基本类型，因此很可能导致调用意外的方法。\nNote that the arguments to a method are separated by commas, and so the comma operator cannot be used unless it is enclosed in parentheses. For example,\n请注意，方法的参数是用逗号分隔的，因此不能使用逗号运算符，除非将其括在括号中。 例如，\n1 method( ensureLoaded(), name ) is a call to a 2-argument method, while\n上面是对 2 参数方法的调用，而下面的\n1 method( (ensureLoaded(), name) ) is a call to a 1-argument method.\n是对 1 参数方法的调用。\nVariable References(变量引用) OGNL has a simple variable scheme, which lets you store intermediate results and use them again, or just name things to make an expression easier to understand. All variables in OGNL are global to the entire expression. You refer to a variable using a number sign in front of its name, like this:\nOGNL 有一个简单的变量方案，它允许你存储中间结果并再次使用它们，或者只是命名事物以使表达式更易于理解。 OGNL 中的所有变量对于整个表达式都是全局的。 你可以在变量名称前面使用数字符号来引用变量，如下所示：\n1 #var OGNL also stores the current object at every point in the evaluation of an expression in the this variable, where it can be referred to like any other variable. For example, the following expression operates on the number of listeners, returning twice the number if it is more than 100, or 20 more than the number otherwise:\nOGNL 还将表达式求值中每个点的当前对象存储在 this 变量中，可以像任何其他变量一样引用它。 例如，以下表达式对侦听器的数量进行操作，如果大于 100，则返回该数字的两倍，否则返回该数字的 20：\n1 listeners.size().(#this \u0026gt; 100? 2*#this : 20+#this) OGNL can be invoked with a map that defines initial values for variables. The standard way of invoking OGNL defines the variables root (which holds the initial, or root, object), and context (which holds the Map of variables itself).\n可以使用定义变量初始值的映射来调用 OGNL。 调用 OGNL 的标准方法定义变量根(root)（保存初始或根对象(root)）和上下文（保存变量本身的映射）。\nTo assign a value to a variable explicitly, simply write an assignment statement with a variable reference on the left-hand side:\n要显式地将值赋给变量，只需在左侧写一个赋值语句并引用变量:\n1 #var = 99 Parenthetical Expressions(括号表达式) As you would expect, an expression enclosed in parentheses is evaluated as a unit, separately from any surrounding operators. This can be used to force an evaluation order different from the one that would be implied by OGNL operator precedences. It is also the only way to use the comma operator in a method argument.\n正如你所期望的那样，括在括号中的表达式作为一个单位计算，与周围的任何操作符分开。这可用于强制不同于 OGNL 操作符优先级所暗示的求值顺序。这也是在方法参数中使用逗号操作符的唯一方法。\nChained Subexpressions(链接子表达式) If you use a parenthetical expression after a dot, the object that is current at the dot is used as the current object throughout the parenthetical expression. For example,\n如果在点后使用圆括号表达式，则圆点处的当前对象将用作整个圆括号表达式中的当前对象。例如,\n1 headline.parent.(ensureLoaded(), name) traverses through the headline and parent properties, ensures that the parent is loaded and then returns (or sets) the parent\u0026rsquo;s name.\n遍历标题(headline)的父属性(parent)，确保父属性被加载(ensureLoaded())，然后返回(或设置)父属性的名称。\nTop-level expressions can also be chained in this way. The result of the expression is the right-most expression element.\n顶级表达式也可以通过这种方式链接。 表达式的结果是最右边的表达式元素。\n1 ensureLoaded(), name This will call ensureLoaded() on the root object, then get the name property of the root object as the result of the expression.\n这将在根对象(root)上调用 EnsureLoaded()，然后获取根对象(root)的 name 属性作为表达式的结果。\nCollection Construction(集合结构) Lists(列表) To create a list of objects, enclose a list of expressions in curly braces. As with method arguments, these expressions cannot use the comma operator unless it is enclosed in parentheses. Here is an example:\n要创建对象列表，请将表达式列表括在花括号中。 与方法参数一样，这些表达式不能使用逗号运算符，除非将其括在括号中。 这是一个例子：\n1 name in { null,\u0026#34;Untitled\u0026#34; } This tests whether the name property is null or equal to \u0026ldquo;Untitled\u0026rdquo;.\n这测试 name 属性是否为空(null)或等于 \u0026ldquo;Untitled\u0026rdquo;。\nThe syntax described above will create a instanceof the List interface. The exact subclass is not defined.\n上述语法将创建 List 接口的实例，其确切的子类未定义。\nNative Arrays(原生数组) Sometimes you want to create Java native arrays, such as int[] or Integer[]. OGNL supports the creation of these similarly to the way that constructors are normally called, but allows initialization of the native array from either an existing list or a given size of the array.\n有时你想要创建 Java 原生数组，例如 int[] 或 Integer[]。 OGNL 支持以类似于通常调用构造函数的方式创建这些数组，也允许从现有列表或给定大小的数组初始化本机数组。\n1 new int[] { 1, 2, 3 } This creates a new int array consisting of three integers 1, 2 and 3.\n这将创建一个由三个整数 1、2 和 3 组成的新 int 数组。\nTo create an array with all null or 0 elements, use the alternative size constructor\n要创建包含所有 null 或 0 元素的数组，请使用指定数组大小的构造函数\n1 new int[5] This creates an int array with 5 slots, all initialized to zero.\n这将创建一个具有 5 个槽(slots)的 int 数组，全部初始化为零。\nMaps(映射) Maps can also be created using a special syntax.\n映射(Maps)只能通过特殊的语法进行创建。\n1 #{ \u0026#34;foo\u0026#34; : \u0026#34;foo value\u0026#34;, \u0026#34;bar\u0026#34; : \u0026#34;bar value\u0026#34; } This creates a Map initialized with mappings for \u0026ldquo;foo\u0026rdquo; and \u0026ldquo;bar\u0026rdquo;.\n这将创建一个初始化了 \u0026ldquo;foo\u0026rdquo; 和 \u0026ldquo;bar\u0026rdquo; 两个映射关系的 Map。\nAdvanced users who wish to select the specific Map class can specify that class before the opening curly brace\n希望选择特定的 Map 类的高级用户可以在左打括号之前指定类。\n1 #@java.util.LinkedHashMap@{ \u0026#34;foo\u0026#34; : \u0026#34;foo value\u0026#34;, \u0026#34;bar\u0026#34; : \u0026#34;bar value\u0026#34; } The above example will create an instance of the JDK 1.4 class LinkedHashMap, ensuring the the insertion order of the elements is preserved.\n上面的示例将创建 JDK 1.4 类 LinkedHashMap 的实例，并且保留元素的插入顺序。\nProjecting Across Collections(跨集合投影) OGNL provides a simple way to call the same method or extract the same property from each element in a collection and store the results in a new collection. We call this \u0026ldquo;projection,\u0026rdquo; from the database term for choosing a subset of columns from a table. For example, this expression:\nOGNL 提供了一种简单的方法来调用相同的方法或从集合中的每个元素中提取相同的属性并将结果存储在新集合中。 我们将其称为\u0026quot;投影(projection)\u0026quot;，来自数据库术语，用于从表中选择列的子集。 例如，这个表达式：\n1 listeners.{delegate} returns a list of all the listeners\u0026rsquo; delegates. See the coercion section for how OGNL treats various kinds of objects as collections.\n返回所有 listeners 列表中所有的 delegate。 有关 OGNL 如何将各种类型的对象视为集合的信息，请参阅强制部分。\nDuring a projection the #this variable refers to the current element of the iteration.\n在投影期间，#this 变量引用迭代的当前元素。\n1 objects.{ #this instanceof String ? #this : #this.toString()} The above would produce a new list of elements from the objects list as string values.\n上面的代码将对象中所有属性值设置为字符串。\nSelecting From Collections(从集合中选择) OGNL provides a simple way to use an expression to choose some elements from a collection and save the results in a new collection. We call this \u0026ldquo;selection,\u0026rdquo; from the database term for choosing a subset of rows from a table. For example, this expression:\nOGNL 提供了一种简单的方法来使用表达式从集合中选择一些元素并将结果保存在新集合中。 我们将其称为 \u0026ldquo;选择(selection)\u0026quot;，来自数据库术语，用于从表中选择行的子集。 例如，这个表达式：\n1 listeners.{? #this instanceof ActionListener} returns a list of all those listeners that are instances of the ActionListener class.\n返回作为 ActionListener 类实例的所有 listener(s) 的列表。\nSelecting First Match(选择第一个匹配项) In order to get the first match from a list of matches, you could use indexing such as listeners.{? true }[0]. However, this is cumbersome because if the match does not return any results (or if the result list is empty) you will get an ArrayIndexOutOfBoundsException.\n为了从匹配列表中获取第一个匹配，你可以使用索引，例如 listeners.{? true}[0]。 然而，这很麻烦，因为如果匹配没有返回任何结果（或者结果列表为空），你将得到 ArrayIndexOutOfBoundsException 异常。\nThe selection syntax is also available to select only the first match and return it as a list. If the match does not succeed for any elements an empty list is the result.\n选择语法也可用于仅选择第一个匹配项并将其作为列表返回。 如果任何元素的匹配均未成功，则结果为空列表。\n1 objects.{^ #this instanceof String } Will return the first element contained in objects that is an instance of the String class.\n将返回对象中第一个作为 String 类实例存在的元素。\nSelecting Last Match(选择最后一个匹配项) Similar to getting the first match, sometimes you want to get the last element that matched.\n与获取第一个匹配项类似，有时您想获取最后一个匹配的元素。\n1 objects.{$ #this instanceof String } This will return the last element contained in objects that is an instanceof the String class\n将返回对象中最后一个作为 String 类实例存在的元素。\nCalling Constructors(调用构造函数) You can create new objects as in Java, with the new operator. One difference is that you must specify the fully qualified class name for classes other than those in the java.lang package.\n您可以像在 Java 中一样使用 new 运算符创建新对象。 一个区别是，您必须为 java.lang 包中的类以外的类指定全路径类名。\nThis is only true with the default ClassResolver in place. With a custom class resolver packages can be mapped in such a way that more Java-like references to classes can be made. Refer to the OGNL Developer\u0026rsquo;s Guide for details on using ClassResolver class (for example, new java.util.ArrayList(), rather than simply new ArrayList()).\n仅当使用默认的 ClassResolver 时才会出现这种情况。 如果使用自定义类解析器，也可以以这样的方式映射包，从而可以对类进行更多类似 Java 的引用。 有关使用 ClassResolver 类（例如，new java.util.ArrayList()，而不是简单的 new ArrayList()）的详细信息，请参阅 OGNL 开发人员指南。\nOGNL chooses the right constructor to call using the same procedure it uses for overloaded method calls.\nOGNL 使用与重载方法调用相同的过程来选择正确的构造函数进行调用。\nCalling Static Methods(调用静态方法) You can call a static method using the syntax @class@method(args). If you leave out class, it defaults to java.lang.Math, to make it easier to call min and max methods. If you specify the class, you must give the fully qualified name.\n您可以使用语法 @class@method(args) 调用静态方法。 如果省略 class，则它默认为 java.lang.Math，以便更轻松地调用 min 和 max 方法。 如果指定类，则必须提供全路径名称。\nIf you have an instance of a class whose static method you wish to call, you can call the method through the object as if it was an instance method.\n如果您有一个类的实例，您希望调用其静态方法，则可以通过该对象调用该方法，就像它是实例方法一样。\nIf the method name is overloaded, OGNL chooses the right static method to call using the same procedure it uses for overloaded instance methods.\n如果方法名称被重载，OGNL 将使用与重载实例方法相同的过程来选择正确的静态方法进行调用。\nGetting Static Fields(获取静态字段) You can refer to a static field using the syntax @class@field. The class must be fully qualified.\n您可以使用语法@class@field 引用静态字段。 类必须为全路径。\nExpression Evaluation(表达式求值) If you follow an OGNL expression with a parenthesized expression, without a dot in front of the parentheses, OGNL will try to treat the result of the first expression as another expression to evaluate, and will use the result of the parenthesized expression as the root object for that evaluation. The result of the first expression may be any object; if it is an AST, OGNL assumes it is the parsed form of an expression and simply interprets it; otherwise, OGNL takes the string value of the object and parses that string to get the AST to interpret.\n如果在 OGNL 表达式后跟一个带括号的表达式，并且括号前面没有点，OGNL 会使用后面的表达式对前面表达式的结果进行计算，并将使用带括号的表达式的结果作为根对象 (root)。 第一个表达式的结果可以是任何对象； 如果它是 AST，OGNL 假定它是表达式的解析形式并简单地解释它； 否则，OGNL 获取对象的字符串值并解析该字符串以获取要解释的 AST。\nFor example, this expression\n例如，这个表达式\n1 #fact(30H) looks up the fact variable, and interprets the value of that variable as an OGNL expression using the BigInteger representation of 30 as the root object. See below for an example of setting the fact variable with an expression that returns the factorial of its argument. Note that there is an ambiguity in OGNL\u0026rsquo;s syntax between this double evaluation operator and a method call. OGNL resolves this ambiguity by calling anything that looks like a method call, a method call. For example, if the current object had a fact property that held an OGNL factorial expression, you could not use this approach to call it\n查找到 fact 变量，并使用 30 类型的 BigInteger 格式进行转换，计算后将值作为根对象(root)。请参照下面的示例，该示例将参数的阶乘结果返回值设置为 fact 变量的值。 请注意，OGNL 语法中的双重求值运算符和方法调用之间存在歧义。 OGNL 通过调用任何看起来像方法调用的东西来解决这种歧义。 例如，如果当前对象有一个包含 OGNL 阶乘表达式的事实属性，则无法使用此方法来调用它\n1 fact(30H) because OGNL would interpret this as a call to the fact method. You could force the interpretation you want by surrounding the property reference by parentheses:\n因为 OGNL 会将其解释为对 fact 方法的调用。 您可以通过用括号将属性引用括起来来强制执行您想要的解释：\n1 (fact)(30H) Pseudo-Lambda Expressions(伪 Lambda 表达式) OGNL has a simplified lambda-expression syntax, which lets you write simple functions. It is not a full-blown lambda calculus, because there are no closures\u0026mdash;all variables in OGNL have global scope and extent.\nOGNL 具有简化的 lambda 表达式语法，可让您编写简单的函数。 但是它不是一个成熟的 lambda 演算，因为没有闭包——OGNL 中的所有变量都具有全局作用域和范围。\nFor example, here is an OGNL expression that declares a recursive factorial function, and then calls it:\n例如，下面是一个声明递归阶乘函数的 OGNL 表达式，然后调用它：\n1 #fact = :[#this\u0026lt;=1? 1 : #this*#fact(#this-1)], #fact(30H) The lambda expression is everything inside the brackets. The #this variable holds the argument to the expression, which is initially 30H, and is then one less for each successive call to the expression.\nlambda 表达式是括号内的所有内容。 #this 变量保存表达式的参数，最初为 30H，然后每次连续调用表达式时都会减一。\nOGNL treats lambda expressions as constants. The value of a lambda expression is the AST that OGNL uses as the parsed form of the contained expression.\nOGNL 将 lambda 表达式视为常量。 lambda 表达式的值是 OGNL 用作所包含表达式的解析形式的 AST。\nPseudo-Properties for Collections(集合的伪属性) There are some special properties of collections that OGNL makes available. The reason for this is that the collections do not follow JavaBeans patterns for method naming; therefore the size(), length(), etc. methods must be called instead of more intuitively referring to these as properties. OGNL corrects this by exposing certain pseudo-properties as if they were built-in.\nOGNL 提供了一些特殊的集合属性。 其原因是集合不遵循 JavaBeans 模式进行方法命名； 因此，必须调用 size()、length() 等方法，而不是更直观地将它们称为属性。 OGNL 通过公开某些伪属性来纠正此问题，就像它们是内置的一样。\nSpecial Collections Pseudo-Properties\nCollection Special Properties Collection (inherited by Map, List \u0026amp; Set) - size: The size of the collection - isEmpty: Evaluates to true if the collection is empty List - iterator: Evalutes to an Iterator over the List. Map - keys: Evalutes to a Set of all keys in the Map - values: Evaluates to a Collection of all values in the Map Note These properties, plus size and isEmpty, are different than the indexed form of access for Maps (i.e. someMap[\u0026ldquo;size\u0026rdquo;] gets the \u0026ldquo;size\u0026rdquo; key from the map, whereas someMap.size gets the size of the Map Set - iterator: Evalutes to an Iterator over the Set Iterator - next: Evalutes to the next object from the Iterator - hasNext: Evaluates to true if there is a next object available from the Iterator Enumeration - next: Evalutes to the next object from the Enumeration - hasNext: Evaluates to true if there is a next object available from the Enumeration\n- nextElement: Synonym for next\n- hasMoreElements: Synonym for hasNext 特殊集合伪属性\nCollection Special Properties Collection (inherited by Map, List \u0026amp; Set) - size: 集合的大小 - isEmpty: 集合如果为空，返回 true List - iterator: List 的迭代器 Map - keys: Map 中所有 key 的集合 -values: Map 中所有 value 的集合 注意 这些属性，加上 size 和 isEmpty，与 Map 访问的索引形式不同（即 someMap[\u0026ldquo;size\u0026rdquo;] 从映射中获取 \u0026ldquo;size\u0026quot;键，而 someMap.size 获取 Map 的大小 Set - iterator: Set 的迭代器 Iterator - next: 获取迭代器的下一个对象 - hasNext: 如果迭代器中有下一个对象可用，返回 true Enumeration - next: 枚举中的下一个对象 - hasNext: 如果枚举中有下一个对象，返回 true\n- nextElement: next 别名\n- hasMoreElements: hasNext 别名 Operators that differ from Java\u0026rsquo;s operators(与 Java 不同的运算符) For the most part, OGNL\u0026rsquo;s operators are borrowed from Java and work similarly to Java\u0026rsquo;s operators. See the OGNL Reference for a complete discussion. Here we describe OGNL operators that are not in Java, or that are different from Java.\n在很大程度上，OGNL 的运算符是从 Java 借用的，其工作方式与 Java 的运算符类似。 请参阅 OGNL 参考以获得完整的讨论。 这里我们描述 Java 中没有的或与 Java 不同的 OGNL 运算符。\nThe comma (,) or sequence operator. This operator is borrowed from C. The comma is used to separate two independent expressions. The value of the second of these expressions is the value of the comma expression. Here is an example: 逗号 (,) 或顺序运算符。 该运算符是从 C 借用的。逗号用于分隔两个独立的表达式。 这些表达式中第二个的值是逗号表达式的值。 这是一个例子： 1 ensureLoaded(), name When this expression is evaluated, the ensureLoaded method is called (presumably to make sure that all parts of the object are in memory), then the name property is retrieved (if getting the value) or replaced (if setting).\n当计算此表达式时，将调用 ensureLoaded 方法（大概是为了确保对象的所有部分都在内存中），然后检索 name 属性（如果获取值）或替换（如果设置）。\nList construction with curly braces ({}). You can create a list in-line by enclosing the values in curly braces, as in this example: 使用大括号 ({}) 的列表结构。 您可以通过将值括在花括号中来创建内联列表，如下例所示： 1 { null, true, false } The in operator (and not in, its negation). This is a containment test, to see if a value is in a collection. For example, in 运算符（和 not in，它的否定）。 这是一个包含测试，用于查看某个值是否在集合中。 例如，\n1 name in {null,\u0026#34;Untitled\u0026#34;} || name Setting values versus getting values(设置值与获取值) As stated before, some values that are gettable are not also settable because of the nature of the expression. For example,\n如前所述，由于表达式的性质，有些值只能获取不能设置。 例如，\n1 names[0].location is a settable expression - the final component of the expression resolves to a settable property.\n是一个可设置的表达式 - 因为表达式的最终组成部分解析为可设置的属性。\nHowever, some expressions, such as\n然而，有些表达式，比如\n1 names[0].length + 1 are not settable because they do not resolve to a settable property in an object. It is simply a computed value. If you try to evaluate this expression using any of the Ognl.setValue() methods it will fail with an InappropriateExpressionException.\n是不可设置值的表达式，因为它们无法解析为对象中的可设置属性。 它只是一个计算值。 如果您尝试使用任何 Ognl.setValue() 方法计算此表达式，它将失败并抛出 InpropertiesExpressionException。\nIt is also possible to set variables using get expressions that include the \u0026lsquo;=\u0026rsquo; operator. This is useful when a get expression needs to set a variable as a side effect of execution.\n还可以使用包含“=”运算符的 get 表达式来设置变量。 当 get 表达式需要设置变量作为执行的副作用时，这非常有用。\nCoercing Objects to Types(强转对象类型) Here we describe how OGNL interprets objects as various types. See below for how OGNL coerces objects to booleans, numbers, integers, and collections.\n这里我们描述 OGNL 如何将对象解释为各种类型。 请参阅下文，了解 OGNL 如何将对象强制转换为布尔值、数字、整数和集合。\nInterpreting Objects as Booleans(将对象转义为布尔值) Any object can be used where a boolean is required. OGNL interprets objects as booleans like this:\n任何需要布尔值的对象都可以使用。 OGNL 将对象解释为布尔值，如下所示：\nIf the object is a Boolean, its value is extracted and returned; If the object is a Number, its double-precision floating-point value is compared with zero; non-zero is treated as true, zero as false; If the object is a Character, its boolean value is true if and only if its char value is non-zero; Otherwise, its boolean value is true if and only if it is non-null. 如果对象是布尔值(Boolean)，则提取并返回其值； 如果对象是 Number，则将其双精度浮点值与零进行比较； 非零被视为 true，零被视为 false; 如果对象是一个字符(Character)，当且仅当其 char 值非零时，其布尔值为 true； 否则，当且仅当它不为空时，它的布尔值才为 true。 Interpreting Objects as Numbers(将对象转义为数字) Numerical operators try to treat their arguments as numbers. The basic primitive-type wrapper classes (Integer, Double, and so on, including Character and Boolean, which are treated as integers), and the \u0026ldquo;big\u0026rdquo; numeric classes from the java.math package (BigInteger and BigDecimal), are recognized as special numeric types. Given an object of some other class, OGNL tries to parse the object\u0026rsquo;s string value as a number.\n数值运算符尝试将其参数视为数字。 基本基元类型包装类（Integer、Double 等，包括被视为整数的 Character 和 Boolean）以及 java.math 包中的“大”数字类（BigInteger 和 BigDecimal）被识别为 特殊的数字类型。 给定某个其他类的对象，OGNL 尝试将对象的字符串值解析为数字。\nNumerical operators that take two arguments use the following algorithm to decide what type the result should be. The type of the actual result may be wider, if the result does not fit in the given type.\n采用两个参数的数值运算符使用以下算法来决定结果应该是什么类型。 如果结果不适合给定类型，则实际结果的类型可能更宽。\nIf both arguments are of the same type, the result will be of the same type if possible; If either argument is not of a recognized numeric class, it will be treated as if it was a Double for the rest of this algorithm; If both arguments are approximations to real numbers (Float, Double, or BigDecimal), the result will be the wider type; If both arguments are integers (Boolean, Byte, Character, Short, Integer, Long, or BigInteger), the result will be the wider type; If one argument is a real type and the other an integer type, the result will be the real type if the integer is narrower than \u0026ldquo;int\u0026rdquo;; BigDecimal if the integer is BigInteger; or the wider of the real type and Double otherwise. 如果两个参数的类型相同，则结果将尽可能具有相同的类型； 如果任一参数不属于可识别的数字类，则对于该算法的其余部分，它将被视为 Double； 如果两个参数都是实数的近似值（Float、Double 或 BigDecimal），则结果将是较宽的类型； 如果两个参数都是整数（Boolean、Byte、Character、Short、Integer、Long 或 BigInteger），则结果将是较宽的类型； 如果一个参数是实数类型，另一个参数是整数类型，则如果整数比“int”窄，则结果将为实数类型； 如果整数是 BigInteger，则为 BigDecimal； 或实际类型的较宽者，否则为 Double。 Interpreting Objects as Integers(将对象转义为整数) Operators that work only on integers, like the bit-shifting operators, treat their arguments as numbers, except that BigDecimals and BigIntegers are operated on as BigIntegers and all other kinds of numbers are operated on as Longs. For the BigInteger case, the result of these operators remains a BigInteger; for the Long case, the result is expressed as the same type of the arguments, if it fits, or as a Long otherwise.\n仅对整数起作用的运算符（如位移运算符）将其参数视为数字，但 BigDecimal 和 BigIntegers 作为 BigIntegers 进行操作，而所有其他类型的数字均作为 Long 进行操作。 对于 BigInteger 情况，这些运算符的结果仍然是 BigInteger； 对于 Long 情况，结果表示为相同类型的参数（如果适合），否则表示为 Long。\nInterpreting Objects as Collections(将对象转义为集合) The projection and selection operators (e1.{e2} and e1.{?e2}), and the in operator, all treat one of their arguments as a collection and walk it. This is done differently depending on the class of the argument:\n投影和选择运算符（e1.{e2} 和 e1.{?e2}）以及 in 运算符都将其参数之一视为集合并对其进行遍历。 根据参数的类别，此操作的完成方式有所不同：\nJava arrays are walked from front to back; Members of java.util.Collection are walked by walking their iterators; Members of java.util.Map are walked by walking iterators over their values; Members of java.util.Iterator and java.util.Enumeration are walked by iterating them; Members of java.lang.Number are \u0026ldquo;walked\u0026rdquo; by returning integers less than the given number starting with zero; All other objects are treated as singleton collections containing only themselves. Java 数组是从前往后走的； java.util.Collection 的成员通过遍历其迭代器来遍历； java.util.Map 的成员通过遍历迭代器对其值进行遍历； java.util.Iterator 和 java.util.Enumeration 的成员通过迭代来遍历； java.lang.Number 的成员通过返回小于从零开始的给定数字的整数来“遍历”； 所有其他对象都被视为仅包含其自身的单例集合。 ","date":"2024-03-23T09:39:46+08:00","permalink":"https://www.lcsk42.com/post/ognl-language-guide/","title":"OGNL Language Guide"},{"content":"Alibaba 开源的 Java 诊断工具 Arthas 使用记录。\n开始 1 2 3 4 5 6 7 ## 下载启动测试程序 curl -O https://arthas.aliyun.com/math-game.jar java -jar math-game.jar # 下载启动 arthas curl -O https://arthas.aliyun.com/arthas-boot.jar java -jar arthas-boot.jar 表达式核心变量 无论是匹配表达式也好、观察表达式也罢，他们核心判断变量都是围绕着一个 Arthas 中的通用通知对象 Advice 进行。\n它的简略代码结构如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Advice { private final ClassLoader loader; private final Class\u0026lt;?\u0026gt; clazz; private final ArthasMethod method; private final Object target; private final Object[] params; private final Object returnObj; private final Throwable throwExp; private final boolean isBefore; private final boolean isThrow; private final boolean isReturn; // getter/setter } 这里列一个表格来说明不同变量的含义\n变量名 变量解释 loader 本次调用类所在的 ClassLoader clazz 本次调用类的 Class 引用 method 本次调用方法反射引用 target 本次调用类的实例 params 本次调用参数列表，这是一个数组，如果方法是无参方法则为空数组 returnObj 本次调用返回的对象。当且仅当 isReturn==true 成立时候有效，表明方法调用是以正常返回的方式结束。如果当前方法无返回值 void，则值为 null throwExp 本次调用抛出的异常。当且仅当 isThrow==true 成立时有效，表明方法调用是以抛出异常的方式结束。 isBefore 辅助判断标记，当前的通知节点有可能是在方法一开始就通知，此时 isBefore==true 成立，同时 isThrow==false 和 isReturn==false，因为在方法刚开始时，还无法确定方法调用将会如何结束。 isThrow 辅助判断标记，当前的方法调用以抛异常的形式结束。 isReturn 辅助判断标记，当前的方法调用以正常返回的形式结束。 所有变量都可以在表达式中直接使用，如果在表达式中编写了不符合 OGNL 脚本语法或者引入了不在表格中的变量，则退出命令的执行；用户可以根据当前的异常信息修正 条件表达式 或 观察表达式。\n基础命令 help 查看命令帮助信息，可以查看当前 arthas 版本支持的指令，或者查看具体指令的使用说明。\n参数名称 参数说明 不接参数 查询当前 arthas 版本支持的指令以及指令描述 [name:] 查询具体指令的使用说明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 $ help NAME DESCRIPTION help Display Arthas Help auth Authenticates the current session keymap Display all the available keymap for the specified connection. sc Search all the classes loaded by JVM sm Search the method of classes loaded by JVM classloader Show classloader info jad Decompile class getstatic Show the static field of a class monitor Monitor method execution statistics, e.g. total/success/failure count, average rt, fail rate, etc. stack Display the stack trace for the specified class and method thread Display thread info, thread stack trace Trace the execution time of specified method invocation. watch Display the input/output parameter, return object, and thrown exception of specified method invocation tt Time Tunnel jvm Display the target JVM information memory Display jvm memory info. perfcounter Display the perf counter information. ognl Execute ognl expression. mc Memory compiler, compiles java files into bytecode and class files in memory. redefine Redefine classes. @see Instrumentation#redefineClasses(ClassDefinition...) retransform Retransform classes. @see Instrumentation#retransformClasses(Class...) dashboard Overview of target jvm\u0026#39;s thread, memory, gc, vm, tomcat info. dump Dump class byte array from JVM heapdump Heap dump options View and change various Arthas options cls Clear the screen reset Reset all the enhanced classes version Display Arthas version session Display current session information sysprop Display and change the system properties. sysenv Display the system env. vmoption Display, and update the vm diagnostic options. logger Print logger info, and update the logger level history Display command history cat Concatenate and print files base64 Encode and decode using Base64 representation echo write arguments to the standard output pwd Return working directory name mbean Display the mbean information grep grep command for pipes. tee tee command for pipes. profiler Async Profiler. https://github.com/jvm-profiling-tools/async-profiler vmtool jvm tool stop Stop/Shutdown Arthas server and exit the console. jfr Java Flight Recorder Command 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $ help dashboard USAGE: dashboard [-h] [-i \u0026lt;value\u0026gt;] [-n \u0026lt;value\u0026gt;] SUMMARY: Overview of target jvm\u0026#39;s thread, memory, gc, vm, tomcat info. EXAMPLES: dashboard dashboard -n 10 dashboard -i 2000 WIKI: https://arthas.aliyun.com/doc/dashboard OPTIONS: -h, --help this help -i, --interval \u0026lt;value\u0026gt; The interval (in ms) between two executions, default is 5000 ms. -n, --number-of-execution \u0026lt;value\u0026gt; The number of times this command will be executed. cls 清空当前屏幕区域。\nsession 查看当前会话的信息，显示当前绑定的 pid 以及会话 id。\n提示\n如果配置了 tunnel server，会追加打印 代理 id、tunnel 服务器的 url 以及连接状态。\n如果使用了 staturl 做统计，会追加显示 statUrl 地址。\n1 2 3 4 5 $ session Name Value -------------------------------------------------- JAVA_PID 96956 SESSION_ID 14219aff-0255-4e7d-aaa8-244061bd8277 reset 提示\n重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端 stop 时会重置所有增强过的类\n1 2 3 4 # 还原指定类 reset Test # 还原所有类 reset version 输出当前目标 Java 进程所加载的 Arthas 版本号\n1 2 $ version 3.7.2 history 打印命令历史。\n提示\n历史指令会通过一个名叫 history 的文件持久化，所以 history 指令可以查看当前 arthas 服务器的所有历史命令，而不仅只是当前次会话使用过的命令。\n参数名称 参数说明 [c:] 清空历史指令 [n:] 显示最近执行的 n 条指令 quit-stop 退出当前 Arthas 客户端，其他 Arthas 客户端不受影响。等同于 exit、logout、q 三个指令。\n提示\n只是退出当前 Arthas 客户端，Arthas 的服务器端并没有关闭，所做的修改也不会被重置。\nkeymap keymap 命令输出当前的快捷键映射表：\n快捷键 快捷键说明 命令名称 命令说明 \u0026ldquo;\\C-a\u0026rdquo; ctrl + a beginning-of-line 跳到行首 \u0026ldquo;\\C-e\u0026rdquo; ctrl + e end-of-line 跳到行尾 \u0026ldquo;\\C-f\u0026rdquo; ctrl + f forward-word 向前移动一个单词 \u0026ldquo;\\C-b\u0026rdquo; ctrl + b backward-word 向后移动一个单词 \u0026ldquo;\\e[D\u0026rdquo; 键盘左方向键 backward-char 光标向前移动一个字符 \u0026ldquo;\\e[C\u0026rdquo; 键盘右方向键 forward-char 光标向后移动一个字符 \u0026ldquo;\\e[B\u0026rdquo; 键盘下方向键 next-history 下翻显示下一个命令 \u0026ldquo;\\e[A\u0026rdquo; 键盘上方向键 previous-history 上翻显示上一个命令 \u0026ldquo;\\C-h\u0026rdquo; ctrl + h backward-delete-char 向后删除一个字符 \u0026ldquo;\\C-?\u0026rdquo; ctrl + shift + / backward-delete-char 向后删除一个字符 \u0026ldquo;\\C-u\u0026rdquo; ctrl + u undo 撤销上一个命令，相当于清空当前行 \u0026ldquo;\\C-d\u0026rdquo; ctrl + d delete-char 删除当前光标所在字符 \u0026ldquo;\\C-k\u0026rdquo; ctrl + k kill-line 删除当前光标到行尾的所有字符 \u0026ldquo;\\C-i\u0026rdquo; ctrl + i complete 自动补全，相当于敲 TAB \u0026ldquo;\\C-j\u0026rdquo; ctrl + j accept-line 结束当前行，相当于敲回车 \u0026ldquo;\\C-m\u0026rdquo; ctrl + m accept-line 结束当前行，相当于敲回车 \u0026ldquo;\\C-w\u0026rdquo; - backward-delete-word - \u0026ldquo;\\C-x\\e[3~\u0026rdquo; - backward-kill-line - \u0026ldquo;\\e\\C-?\u0026rdquo; - backward-kill-word - 任何时候 tab 键，会根据当前的输入给出提示 命令后敲 - 或 \u0026ndash; ，然后按 tab 键，可以展示出此命令具体的选项 自定义快捷键 在当前用户目录下新建 $USER_HOME/.arthas/conf/inputrc 文件，加入自定义配置。\n后台异步命令相关快捷键 ctrl + c: 终止当前命令 ctrl + z: 挂起当前命令，后续可以 bg/fg 重新支持此命令，或 kill 掉 ctrl + a: 回到行首 ctrl + e: 回到行尾\ncat 提示\n打印文件内容，和 linux 里的 cat 命令类似。\necho 提示\n打印参数，和 linux 里的 echo 命令类似。\ngrep 提示\n类似传统的 grep 命令。\ntee 提示\n类似传统的 tee 命令, 用于读取标准输入的数据，并将其内容输出成文件。\ntee 指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。\npwd 提示\n返回当前的工作目录，和 linux 命令类似\nplaintext wc options 提示\n全局开关\n名称 默认值 描述 unsafe false 是否支持对系统级别的类进行增强，打开该开关可能导致把 JVM 搞挂，请慎重选择！ dump false 是否支持被增强了的类 dump 到外部文件中，如果打开开关，class 文件会被 dump 到/${application working dir}/arthas-class-dump/目录下，具体位置详见控制台输出 batch-re-transform true 是否支持批量对匹配到的类执行 retransform 操作 json-format false 是否支持 json 化的输出 disable-sub-class false 是否禁用子类匹配，默认在匹配目标类的时候会默认匹配到其子类，如果想精确匹配，可以关闭此开关 support-default-method true 是否支持匹配到 default method， 默认会查找 interface，匹配里面的 default method。参考 #1105 在新窗口打开 save-result false 是否打开执行结果存日志功能，打开之后所有命令的运行结果都将保存到~/logs/arthas-cache/result.log 中 job-timeout 1d 异步后台任务的默认超时时间，超过这个时间，任务自动停止；比如设置 1d, 2h, 3m, 25s，分别代表天、小时、分、秒 print-parent-fields true 是否打印在 parent class 里的 filed verbose false 是否打印更多详细信息 strict true 是否启用 strict 模式 1 2 3 4 5 6 # 查看所有的 options options # 获取 option 的值 options json-format # 设置指定的 option options save-result true 提示\n默认情况下 json-format 为 false，如果希望 watch/tt 等命令结果以 json 格式输出，则可以设置 json-format 为 true。\n打开 unsafe 开关，支持 jdk package 下的类 默认情况下，watch/trace/tt/trace/monitor 等命令不支持 java.\\* package 下的类。可以设置 unsafe 为 true，则可以增强。\n1 options unsafe true 关闭 strict 模式，允许在 ognl 表达式里设置对象属性 提示\nsince 3.6.0\n对于新用户，在编写 ognl 表达式时，可能会出现误用。\n比如对于 Student，判断年龄等于 18 时，可能条件表达式会误写为 target.age=18，这个表达式实际上是把当前对象的 age 设置为 18 了。正确的写法是 target.age==18。\n为了防止出现类似上面的误用，Arthas 默认启用 strict 模式，在 ognl 表达式里，禁止更新对象的 Property 或者调用 setter 函数。\n以 MathGame 为例，会出现以下的错误提示。\n1 2 3 4 $ watch demo.MathGame primeFactors \u0026#39;target\u0026#39; \u0026#39;target.illegalArgumentCount=1\u0026#39; Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 20 ms, listenerId: 6 watch failed, condition is: target.illegalArgumentCount=1, express is: target, By default, strict mode is true, not allowed to set object properties. Want to set object properties, execute `options strict false`, visit /Users/lucaschen/logs/arthas/arthas.log for more details. 用户如果确定要在 ognl 表达式里更新对象，可以执行 options strict false，关闭 strict 模式。\n系统命令 dashboard 提示\n当前系统的实时数据面板，按 ctrl+c 退出。\n当运行在 Ali-tomcat 时，会显示当前 tomcat 的实时信息，如 HTTP 请求的 qps, rt, 错误数, 线程池信息等等。\n参数名称 参数说明 [i:] 刷新实时数据的时间间隔 (ms)，默认 5000ms [n:] 刷新实时数据的次数 数据说明 ID: Java 级别的线程 ID，注意这个 ID 不能跟 jstack 中的 nativeID 一一对应。 NAME: 线程名 GROUP: 线程组名 PRIORITY: 线程优先级, 1~10 之间的数字，越大表示优先级越高 STATE: 线程的状态 CPU%: 线程的 cpu 使用率。比如采样间隔 1000ms，某个线程的增量 cpu 时间为 100ms，则 cpu 使用率=100/1000=10% DELTA_TIME: 上次采样之后线程运行增量 CPU 时间，数据格式为秒 TIME: 线程运行总 CPU 时间，数据格式为分:秒 INTERRUPTED: 线程当前的中断位状态 DAEMON: 是否是 daemon 线程 JVM 内部线程 Java 8 之后支持获取 JVM 内部线程 CPU 时间，这些线程只有名称和 CPU 时间，没有 ID 及状态等信息（显示 ID 为-1）。 通过内部线程可以观测到 JVM 活动，如 GC、JIT 编译等占用 CPU 情况，方便了解 JVM 整体运行状况。\n当 JVM 堆(heap)/元数据(metaspace)空间不足或 OOM 时，可以看到 GC 线程的 CPU 占用率明显高于其他的线程。 当执行 trace/watch/tt/redefine 等命令后，可以看到 JIT 线程活动变得更频繁。因为 JVM 热更新 class 字节码时清除了此 class 相关的 JIT 编译结果，需要重新编译。 JVM 内部线程包括下面几种：\nJIT 编译线程: 如 C1 CompilerThread0, C2 CompilerThread0 GC 线程: 如 GC Thread0, G1 Young RemSet Sampling 其它内部线程: 如 VM Periodic Task Thread, VM Thread, Service Thread thread 提示\n查看当前线程信息，查看线程的堆栈\n参数名称 参数说明 id 线程 id [n:] 指定最忙的前 N 个线程并打印堆栈 [b] 找出当前阻塞其他线程的线程 [i \u0026lt;value\u0026gt;] 指定 cpu 使用率统计的采样间隔，单位为毫秒，默认值为 200 [\u0026ndash;all] 显示所有匹配的线程 这里的 cpu 使用率与 linux 命令 top -H -p \u0026lt;pid\u0026gt; 的线程 %CPU 类似，一段采样间隔时间内，当前 JVM 里各个线程的增量 cpu 时间与采样间隔时间的比例。\n工作原理说明：\n首先第一次采样，获取所有线程的 CPU 时间(调用的是 java.lang.management.ThreadMXBean#getThreadCpuTime() 及 sun.management.HotspotThreadMBean.getInternalThreadCpuTimes() 接口) 然后睡眠等待一个间隔时间（默认为 200ms，可以通过 -i 指定间隔时间） 再次第二次采样，获取所有线程的 CPU 时间，对比两次采样数据，计算出每个线程的增量 CPU 时间 线程 CPU 使用率 = 线程增量 CPU 时间 / 采样间隔时间 * 100% 注意\n注意： 这个统计也会产生一定的开销（JDK 这个接口本身开销比较大），因此会看到 as 的线程占用一定的百分比，为了降低统计自身的开销带来的影响，可以把采样间隔拉长一些，比如 5000 毫秒。\n提示\n另外一种查看 Java 进程的线程 cpu 使用率方法：可以使用 show-busy-java-threads 这个脚本\n1 2 # 一键展示当前最忙的前 N 个线程并打印堆栈 thread -n 3 没有线程 ID，包含 [Internal]表示为 JVM 内部线程，参考 dashboard 命令的介绍。 cpuUsage 为采样间隔时间内线程的 CPU 使用率，与 dashboard 命令的数据一致。 deltaTime 为采样间隔时间内线程的增量 CPU 时间，小于 1ms 时被取整显示为 0ms。 time 线程运行总 CPU 时间。 注意：线程栈为第二采样结束时获取，不能表明采样间隔时间内该线程都是在处理相同的任务。建议间隔时间不要太长，可能间隔时间越大越不准确。 可以根据具体情况尝试指定不同的间隔时间，观察输出结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 当没有参数时，显示第一页线程的信息 # 默认按照 CPU 增量时间降序排列，只显示第一页数据。 thread # 显示所有匹配线程信息，有时需要获取全部 JVM 的线程数据进行分析。 thread --all # thread id, 显示指定线程的运行堆栈 thread 1 # thread -b, 找出当前阻塞其他线程的线程 # 有时候我们发现应用卡住了， 通常是由于某个线程拿住了某个锁， 并且其他线程都在等待这把锁造成的。 为了排查这类问题， arthas 提供了 thread -b， 一键找出那个罪魁祸首 # **注意** # 注意， 目前只支持找出 synchronized 关键字阻塞住的线程， 如果是java.util.concurrent.Lock， 目前还不支持 thread -b # thread -i, 指定采样时间间隔 # 统计最近 1000ms 内的线程 CPU 时间 thread -i 1000 # 列出 1000ms 内最忙的 3 个线程栈 thread -n 3 -i 1000 # thread --state ，查看指定状态的线程 # NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED thread --state WAITING jvm 提示\n查看当前 JVM 信息\nTHREAD 相关:\nCOUNT: JVM 当前活跃的线程数 DAEMON-COUNT: JVM 当前活跃的守护线程数 PEAK-COUNT: 从 JVM 启动开始曾经活着的最大线程数 STARTED-COUNT: 从 JVM 启动开始总共启动过的线程次数 DEADLOCK-COUNT: JVM 当前死锁的线程数 文件描述符相关:\nMAX-FILE-DESCRIPTOR-COUNT：JVM 进程最大可以打开的文件描述符数 OPEN-FILE-DESCRIPTOR-COUNT：JVM 当前打开的文件描述符数 sysprop 提示\n查看当前 JVM 的系统属性(System Property)\n1 2 3 4 5 6 7 8 # 查看所有属性 sysprop # 查看单个属性, 支持通过TAB键自动补全 sysprop java.version # 修改单个属性 sysprop user.country CN sysenv 提示\n查看当前 JVM 的环境属性(System Environment Variables)\n1 2 3 4 5 # 查看所有环境变量 sysenv # 查看单个环境变量, 支持通过TAB键自动补全 sysenv java.version vmoption 提示\n查看，更新 VM 诊断相关的参数\n1 2 3 4 5 6 7 8 # 查看所有的 option vmoption # 查看指定的 option vmoption PrintGC # 更新指定的 option vmoption PrintGCDetails true vmtool 提示\n@since 3.5.1\nvmtool 利用 JVMTI 接口，实现查询内存对象，强制 GC 等功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # 获取对象 # 通过 --limit参数，可以限制返回值数量，避免获取超大数据时对 JVM 造成压力。默认值是 10。 vmtool --action getInstances --className java.lang.String --limit 10 # 指定 classloader name vmtool --action getInstances --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --className org.springframework.context.ApplicationContext # 指定 classloader hash #可以通过sc命令查找到加载 class 的 classloader。 sc -d org.springframework.context.ApplicationContext class-info org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext code-source file:/private/tmp/demo-arthas-spring-boot.jar!/BOOT-INF/lib/spring-boot-1.5.13.RELEASE.jar!/ name org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext ... class-loader +-org.springframework.boot.loader.LaunchedURLClassLoader@19469ea2 +-sun.misc.Launcher$AppClassLoader@75b84c92 +-sun.misc.Launcher$ExtClassLoader@4f023edb classLoaderHash 19469ea2 # 然后用-c/--classloader 参数指定： vmtool --action getInstances -c 19469ea2 --className org.springframework.context.ApplicationContext # 指定返回结果展开层数 # getInstances action 返回结果绑定到instances变量上，它是数组。 # 通过 -x/--expand 参数可以指定结果的展开层次，默认值是 1。 vmtool --action getInstances -c 19469ea2 --className org.springframework.context.ApplicationContext -x 2 # 执行表达式 # getInstances action 返回结果绑定到instances变量上，它是数组。可以通过--express参数执行指定的表达式。 vmtool --action getInstances --classLoaderClass org.springframework.boot.loader.LaunchedURLClassLoader --className org.springframework.context.ApplicationContext --express \u0026#39;instances[0].getBeanDefinitionNames()\u0026#39; # 强制 GC # 可以结合 vmoption 命令动态打开PrintGC开关 vmtool --action forceGc # interrupt 指定线程 # thread id 通过-t参数指定，可以使用 thread 命令获取。 vmtool --action interruptThread -t 1 perfcounter 提示\n查看当前 JVM 的 Perf Counter 信息\n1 2 3 perfcounter # 可以用-d参数打印更多信息： perfcounter -d jdk9 以上的应用,如果没有打印出信息，应用在启动时，加下面的参数：\n1 --add-opens java.base/jdk.internal.perf=ALL-UNNAMED --add-exports java.base/jdk.internal.perf=ALL-UNNAMED --add-opens java.management/sun.management.counter.perf=ALL-UNNAMED --add-opens java.management/sun.management.counter=ALL-UNNAMED logger 提示\n查看 logger 信息，更新 logger level\n1 2 # 更新 logger level logger --name ROOT --level debug getstatic 1 2 3 4 5 6 7 8 # 通过 getstatic 命令可以方便的查看类的静态属性。使用方法为 `getstatic class_name field_name` getstatic demo.MathGame random # 注意 hashcode 是变化的，需要先查看当前的 ClassLoader 信息，使用sc -d \u0026lt;ClassName\u0026gt;提取对应 ClassLoader 的 hashcode。 # 如果你使用-c，你需要手动输入 hashcode：-c \u0026lt;hashcode\u0026gt; getstatic -c 3d4eac69 demo.MathGame random # 对于只有唯一实例的 ClassLoader 可以通过--classLoaderClass指定 class name，使用起来更加方便： getstatic --classLoaderClass sun.misc.Launcher$AppClassLoader demo.MathGame random ognl 提示\n执行 ognl 表达式\n参数名称 参数说明 express 执行的表达式 [c:] 执行表达式的 ClassLoader 的 hashcode，默认值是 SystemClassLoader [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [x] 结果对象的展开层次，默认值 1 1 2 3 4 5 6 # 调用静态函数： ognl \u0026#39;@java.lang.System@out.println(\u0026#34;hello\u0026#34;)\u0026#39; # 获取静态类的静态字段： ognl \u0026#39;@demo.MathGame@random\u0026#39; # 执行多行表达式，赋值给临时变量，返回一个 List： $ ognl \u0026#39;#value1=@System@getProperty(\u0026#34;java.home\u0026#34;), #value2=@System@getProperty(\u0026#34;java.runtime.name\u0026#34;), {#value1, #value2}\u0026#39; arthas 中的特殊用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 查看第一个参数： watch com.taobao.container.Test test \u0026#34;params[0]\u0026#34; # 查看第一个参数的 size： watch com.taobao.container.Test test \u0026#34;params[0].size()\u0026#34; # 将结果按 name 属性投影： watch com.taobao.container.Test test \u0026#34;params[0].{ #this.name }\u0026#34; # 按条件过滤： watch com.taobao.container.Test test \u0026#34;params[0].{? #this.name == null }.size() \u0026gt; 0\u0026#34; -x 2 # 过滤后统计： watch com.taobao.container.Test test \u0026#34;params[0].{? #this.age \u0026gt; 10 }.size()\u0026#34; -x 2 # 判断字符串相等 watch com.demo.Test test \u0026#39;params[0]==\u0026#34;xyz\u0026#34;\u0026#39; # 判断 long 型 watch com.demo.Test test \u0026#39;params[0]==123456789L\u0026#39; # 子表达式求值： watch com.taobao.container.Test test \u0026#34;params[0].{? #this.age \u0026gt; 10 }.size().(#this \u0026gt; 20 ? #this - 10 : #this + 10)\u0026#34; -x 2 # 选择第一个满足条件： watch com.taobao.container.Test test \u0026#34;params[0].{^ #this.name != null}\u0026#34; -x 2 # 选择最后一个满足条件： watch com.taobao.container.Test test \u0026#34;params[0].{$ #this.name != null}\u0026#34; -x 2 # 匹配线程 \u0026amp; 正则多个类多个方法 trace -E \u0026#39;io\\.netty\\.channel\\.nio\\.NioEventLoop|io\\.netty\\.util\\.concurrent\\.SingleThreadEventExecutor\u0026#39; \u0026#39;select|processSelectedKeys|runAllTasks\u0026#39; \u0026#39;@Thread@currentThread().getName().contains(\u0026#34;IO-HTTP-WORKER-IOPool\u0026#34;)\u0026amp;\u0026amp;#cost\u0026gt;500\u0026#39; mbean 提示\n查看 Mbean 的信息\n这个命令可以便捷的查看或监控 Mbean 的属性信息。\n参数名称 参数说明 name-pattern 名称表达式匹配 attribute-pattern 属性名表达式匹配 [m] 查看元信息 [i:] 刷新属性值的时间间隔 (ms) [n:] 刷新属性值的次数 [E] 开启正则表达式匹配，默认为通配符匹配。仅对属性名有效 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 列出所有 Mbean 的名称： mbean # 查看 Mbean 的元信息： mbean -m java.lang:type=Threading # 查看 mbean 属性信息： mbean java.lang:type=Threading # mbean 的 name 支持通配符匹配： # 注意：ObjectName 的匹配规则与正常的通配符存在差异，详细参见：[javax.management.ObjectName](https://docs.oracle.com/javase/8/docs/api/javax/management/ObjectName.html?is-external=true) mbean java.lang:type=Th* # 通配符匹配特定的属性字段： mbean java.lang:type=Threading *Count # 使用 -E 命令切换为正则匹配： mbean -E java.lang:type=Threading PeakThreadCount|ThreadCount|DaemonThreadCount # 使用 -i 命令实时监控： mbean -i 1000 java.lang:type=Threading *Count # 实时监控使用 -i，使用 -n 命令执行命令的次数（默认为 100 次）： mbean -i 1000 -n 50 java.lang:type=Threading *Count heapdump 提示\ndump java heap, 类似 jmap 命令的 heap dump 功能。\n1 2 3 4 5 6 7 8 9 # dump 到指定文件 # 生成文件在arthas-output目录，可以通过浏览器下载： http://localhost:8563/arthas-output/ heapdump arthas-output/dump.hprof # 只 dump live 对象 heapdump --live /tmp/dump.hprof # dump 到临时文件 heapdump 类命令 sc 提示\n查看 JVM 已加载的类信息\n“Search-Class” 的简写，这个命令能搜索出所有已经加载到 JVM 中的 Class 信息，这个命令支持的参数有 [d]、[E]、[f] 和 [x:]。\n参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 [d] 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的 ClassLoader 等详细信息。如果一个类被多个 ClassLoader 所加载，则会出现多次 [E] 开启正则表达式匹配，默认为通配符匹配 [f] 输出当前类的成员变量信息（需要配合参数-d 一起使用） [x:] 指定输出静态变量时属性的遍历深度，默认为 0，即直接使用 toString 输出 [c:] 指定 class 的 ClassLoader 的 hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [n:] 具有详细信息的匹配类的最大数量（默认为 100） [cs \u0026lt;arg\u0026gt;] 指定 class 的 ClassLoader#toString() 返回值。长格式[classLoaderStr \u0026lt;arg\u0026gt;] 提示\nclass-pattern 支持全限定名，如 com.taobao.test.AAA，也支持 com/taobao/test/AAA 这样的格式，这样，我们从异常堆栈里面把类名拷贝过来的时候，不需要在手动把 / 替换为 . 啦。\nsc 默认开启了子类匹配功能，也就是说所有当前类的子类也会被搜索出来，想要精确的匹配，请打开 options disable-sub-class true 开关\n1 2 3 4 5 6 7 8 9 10 11 # 模糊搜索 sc demo.* # 打印类的详细信息 sc -d demo.MathGame # 打印出类的 Field 信息 sc -d -f demo.MathGame # 通过 ClassLoader#toString 查找类（前提：有一个 toString()返回值是apo的类加载器，加载的类中包含 `demo.MathGame`, `demo.MyBar`, `demo.MyFoo3` 个类） sc -cs apo *demo* sm 提示\n查看已加载类的方法信息\n“Search-Method” 的简写，这个命令能搜索出所有已经加载了 Class 信息的方法信息。\nsm 命令只能看到由当前类所声明 (declaring) 的方法，父类则无法看到。\n参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 [d] 展示每个方法的详细信息 [E] 开启正则表达式匹配，默认为通配符匹配 [c:] 指定 class 的 ClassLoader 的 hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [n:] 具有详细信息的匹配类的最大数量（默认为 100） 1 2 sm java.lang.String sm -d java.lang.String toString jad 提示\n反编译指定已加载类的源码\njad 命令将 JVM 中实际运行的 class 的 byte code 反编译成 java 代码，便于你理解业务逻辑；如需批量下载指定包的目录的 class 字节码可以参考 dump。\n在 Arthas Console 上，反编译出来的源码是带语法高亮的，阅读更方便 当然，反编译出来的 java 代码可能会存在语法错误，但不影响你进行阅读理解 参数名称 参数说明 class-pattern 类名表达式匹配 [c:] 类所属 ClassLoader 的 hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [E] 开启正则表达式匹配，默认为通配符匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 反编译java.lang.String jad java.lang.String # 反编译时只显示源代码 # 默认情况下，反编译结果里会带有 ClassLoader 信息，通过 --source-only 选项，可以只打印源代码。方便和 mc/retransform 命令结合使用 jad --source-only demo.MathGame # 反编译指定的函数 jad demo.MathGame main # 反编译时不显示行号 # --lineNumber 参数默认值为 true，显示指定为 false 则不打印行号。 jad demo.MathGame main --lineNumber false # 反编译时指定 ClassLoader # 当有多个 ClassLoader 都加载了这个类时，jad 命令会输出对应 ClassLoader 实例的 hashcode，然后你只需要重新执行 jad 命令，并使用参数 -c \u0026lt;hashcode\u0026gt; 就可以反编译指定 ClassLoader 加载的那个类了； jad org.apache.log4j.Logger # 对于只有唯一实例的 ClassLoader 还可以通过--classLoaderClass指定 class name，使用起来更加方便： # --classLoaderClass 的值是 ClassLoader 的类名，只有匹配到唯一的 ClassLoader 实例时才能工作，目的是方便输入通用命令，而-c \u0026lt;hashcode\u0026gt;是动态变化的。 mc-retransform 1 2 3 \u0026gt; **提示** \u0026gt; \u0026gt; 加载外部的.class文件，retransform jvm 已加载的类。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # retransform 指定的 .class 文件 # 加载指定的 .class 文件，然后解析出 class name，再 retransform jvm 中已加载的对应的类。每加载一个 .class 文件，则会记录一个 retransform entry. # 如果多次执行 retransform 加载同一个 class 文件，则会有多条 retransform entry. retransform /tmp/Test.class # 查看 retransform entry # TransformCount 统计在 ClassFileTransformer#transform 函数里尝试返回 entry 对应的 .class 文件的次数，但并不表明 transform 一定成功。 retransform -l # 删除指定 retransform entry # 需要指定 id： retransform -d 1 # delete retransform entry # 删除所有 retransform entry retransform --deleteAll # delete all retransform entries # 显式触发 retransform # 注意：对于同一个类，当存在多个 retransform entry 时，如果显式触发 retransform ，则最后添加的 entry 生效(id 最大的)。 retransform --classPattern demo.* # triger retransform classes retransform -c 327a647b /tmp/Test.class /tmp/Test\\$Inner.class retransform --classLoaderClass \u0026#39;sun.misc.Launcher$AppClassLoader\u0026#39; /tmp/Test.class 如果对某个类执行 retransform 之后，想消除影响，则需要 删除这个类对应的 retransform entry 重新触发 retransform 提示\n如果不清除掉所有的 retransform entry，并重新触发 retransform ，则 arthas stop 时，retransform 过的类仍然生效。\n结合 jad/mc 命令使用 1 2 3 4 5 jad --source-only com.example.demo.arthas.user.UserController \u0026gt; /tmp/UserController.java mc /tmp/UserController.java -d /tmp retransform /tmp/com/example/demo/arthas/user/UserController.class jad 命令反编译，然后可以用其它编译器，比如 vim 来修改源码 mc 命令来内存编译修改过的代码 用 retransform 命令加载新的字节码 上传 .class 文件到服务器的技巧 使用 mc 命令来编译 jad 的反编译的代码有可能失败。可以在本地修改代码，编译好后再上传到服务器上。有的服务器不允许直接上传文件，可以使用 base64 命令来绕过。\n在本地先转换.class 文件为 base64，再保存为 result.txt 1 base64 \u0026lt; Test.class \u0026gt; result.txt 到服务器上，新建并编辑 result.txt，复制本地的内容，粘贴再保存\n把服务器上的 result.txt 还原为.class\n1 base64 -d \u0026lt; result.txt \u0026gt; Test.class 用 md5 命令计算哈希值，校验是否一致 retransform 的限制\n不允许新增加 field/method 正在跑的函数，没有退出不能生效，比如下面新增加的 System.out.println，只有 run() 函数里的会生效 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class MathGame { public static void main(String[] args) throws InterruptedException { MathGame game = new MathGame(); while (true) { game.run(); TimeUnit.SECONDS.sleep(1); // 这个不生效，因为代码一直跑在 while里 System.out.println(\u0026#34;in loop\u0026#34;); } } public void run() throws InterruptedException { // 这个生效，因为run()函数每次都可以完整结束 System.out.println(\u0026#34;call run()\u0026#34;); try { int number = random.nextInt(); List\u0026lt;Integer\u0026gt; primeFactors = primeFactors(number); print(number, primeFactors); } catch (Exception e) { System.out.println(String.format(\u0026#34;illegalArgumentCount:%3d, \u0026#34;, illegalArgumentCount) + e.getMessage()); } } } mc-redefine 提示\n推荐使用 retransform 命令\ndump 提示\ndump 已加载类的 bytecode 到特定目录\ndump 命令将 JVM 中实际运行的 class 的 byte code dump 到指定目录，适用场景批量下载指定包目录的 class 字节码；如需反编译单一类、实时查看类信息，可参考 jad。\n参数名称 参数说明 class-pattern 类名表达式匹配 [c:] 类所属 ClassLoader 的 hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [d:] 设置类文件的目标目录 [E] 开启正则表达式匹配，默认为通配符匹配 1 2 3 4 5 6 7 8 9 10 11 dump java.lang.String dump demo.* dump -d /tmp/output java.lang.String # 指定 classLoader # 如果你使用 -c，你需要手动输入 hashcode：-c \u0026lt;hashcode\u0026gt; dump -c 3d4eac69 demo.* # 对于只有唯一实例的 ClassLoader 可以通过--classLoaderClass指定 class name，使用起来更加方便： dump --classLoaderClass sun.misc.Launcher$AppClassLoader demo.* classloader 提示\n查看 classloader 的继承树，urls，类加载信息\nclassloader 命令将 JVM 中所有的 classloader 的信息统计出来，并可以展示继承树，urls 等。\n可以让指定的 classloader 去 getResources，打印出所有查找到的 resources 的 url。对于 ResourceNotFoundException 比较有用。\n参数名称 参数说明 [l] 按类加载实例进行统计 [t] 打印所有 ClassLoader 的继承树 [a] 列出所有 ClassLoader 加载的类，请谨慎使用 [c:] ClassLoader 的 hashcode [classLoaderClass:] 指定执行表达式的 ClassLoader 的 class name [c: r:] 用 ClassLoader 去查找 resource [c: load:] 用 ClassLoader 去加载指定的类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 按类加载类型查看统计信息 classloader # 按类加载实例查看统计信息 classloader -l # 查看 ClassLoader 的继承树 classloader -t # 查看 URLClassLoader 实际的 urls classloader -c 3d4eac69 # 注意 hashcode 是变化的，需要先查看当前的 ClassLoader 信息，提取对应 ClassLoader 的 hashcode。 # 对于只有唯一实例的 ClassLoader 可以通过 class name 指定，使用起来更加方便： classloader --classLoaderClass sun.misc.Launcher$AppClassLoader # 使用 ClassLoader 去查找 resource classloader -c 3d4eac69 -r META-INF/MANIFEST.MF # 也可以尝试查找类的 class 文件： classloader -c 1b6d3586 -r java/lang/String.class # 使用 ClassLoader 去加载类 classloader -c 3d4eac69 --load demo.MathGame # 统计 ClassLoader 实际使用 URL 和未使用的 URL classloader --url-stat # 注意，基于 JVM 目前已加载的所有类统计，不代表 Unused URLs 可以从应用中删掉。因为可能将来需要从 Unused URLs 里加载类，或者需要加载 resources。 增强命令 monitor 提示\n方法执行监控\n对匹配 class-pattern／method-pattern／condition-express 的类、方法的调用进行监控。\nmonitor 命令是一个非实时返回命令.\n实时返回命令是输入之后立即返回，而非实时返回的命令，则是不断的等待目标 Java 进程返回信息，直到用户输入 Ctrl+C 为止。\n服务端是以任务的形式在后台跑任务，植入的代码随着任务的中止而不会被执行，所以任务关闭后，不会对原有性能产生太大影响，而且原则上，任何 Arthas 命令不会引起原有业务逻辑的改变。\n监控维度：\n监控项 说明 timestamp 时间戳 class Java 类 method 方法（构造方法、普通方法） total 调用次数 success 成功次数 fail 失败次数 rt 平均 RT fail-rate 失败率 参数：\n方法拥有一个命名参数 [c:]，意思是统计周期（cycle of output），拥有一个整型的参数值\n参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 condition-express 条件表达式 [E] 开启正则表达式匹配，默认为通配符匹配 [c:] 统计周期，默认值为 120 秒 [b] 在方法调用之前计算 condition-express [m \u0026lt;arg\u0026gt;] 指定 Class 最大匹配数量，默认值为 50。长格式为[maxMatch \u0026lt;arg\u0026gt;]。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $ monitor -c 5 demo.MathGame primeFactors Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 94 ms. timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2018-12-03 19:06:38 demo.MathGame primeFactors 5 1 4 1.15 80.00% timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2018-12-03 19:06:43 demo.MathGame primeFactors 5 3 2 42.29 40.00% timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2018-12-03 19:06:48 demo.MathGame primeFactors 5 3 2 67.92 40.00% timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2018-12-03 19:06:53 demo.MathGame primeFactors 5 2 3 0.25 60.00% timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2018-12-03 19:06:58 demo.MathGame primeFactors 1 1 0 0.45 0.00% timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2018-12-03 19:07:03 demo.MathGame primeFactors 2 2 0 3182.72 0.00% 指定 Class 最大匹配数量 1 2 3 4 5 6 7 8 9 10 $ monitor -c 1 -m 1 demo.MathGame primeFactors Press Q or Ctrl+C to abort. Affect(class count:1 , method count:1) cost in 384 ms, listenerId: 6. timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2022-12-25 21:12:58 demo.MathGame primeFactors 1 1 0 0.18 0.00% timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2022-12-25 21:12:59 demo.MathGame primeFactors 0 0 0 0.00 0.00% 计算条件表达式过滤统计结果(方法执行完毕之后) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 monitor -c 5 demo.MathGame primeFactors \u0026#34;params[0] \u0026lt;= 2\u0026#34; Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 19 ms, listenerId: 5 timestamp class method total success fail avg-rt(ms) fail-rate ----------------------------------------------------------------------------------------------- 2020-09-02 09:42:36 demo.MathGame primeFactors 5 3 2 0.09 40.00% timestamp class method total success fail avg-rt(ms) fail-rate ---------------------------------------------------------------------------------------------- 2020-09-02 09:42:41 demo.MathGame primeFactors 5 2 3 0.11 60.00% timestamp class method total success fail avg-rt(ms) fail-rate ---------------------------------------------------------------------------------------------- 2020-09-02 09:42:46 demo.MathGame primeFactors 5 1 4 0.06 80.00% timestamp class method total success fail avg-rt(ms) fail-rate ---------------------------------------------------------------------------------------------- 2020-09-02 09:42:51 demo.MathGame primeFactors 5 1 4 0.12 80.00% timestamp class method total success fail avg-rt(ms) fail-rate ---------------------------------------------------------------------------------------------- 2020-09-02 09:42:56 demo.MathGame primeFactors 5 3 2 0.15 40.00% 计算条件表达式过滤统计结果(方法执行完毕之前) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 monitor -b -c 5 com.test.testes.MathGame primeFactors \u0026#34;params[0] \u0026lt;= 2\u0026#34; Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 21 ms, listenerId: 4 timestamp class method total success fail avg-rt(ms) fail-rate ---------------------------------------------------------------------------------------------- 2020-09-02 09:41:57 demo.MathGame primeFactors 1 0 1 0.10 100.00% timestamp class method total success fail avg-rt(ms) fail-rate ---------------------------------------------------------------------------------------------- 2020-09-02 09:42:02 demo.MathGame primeFactors 3 0 3 0.06 100.00% timestamp class method total success fail avg-rt(ms) fail-rate ---------------------------------------------------------------------------------------------- 2020-09-02 09:42:07 demo.MathGame primeFactors 2 0 2 0.06 100.00% timestamp class method total success fail avg-rt(ms) fail-rate ---------------------------------------------------------------------------------------------- 2020-09-02 09:42:12 demo.MathGame primeFactors 1 0 1 0.05 100.00% timestamp class method total success fail avg-rt(ms) fail-rate ---------------------------------------------------------------------------------------------- 2020-09-02 09:42:17 demo.MathGame primeFactors 2 0 2 0.10 100.00% watch 提示\n函数执行数据观测\n让你能方便的观察到指定函数的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。\nwatch 的参数比较多，主要是因为它能在 4 个不同的场景观察对象\n参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 函数名表达式匹配 express 观察表达式，默认值：{params, target, returnObj} condition-express 条件表达式 [b] 在函数调用之前观察 [e] 在函数异常之后观察 [s] 在函数返回之后观察 [f] 在函数结束之后(正常返回和异常返回)观察 [E] 开启正则表达式匹配，默认为通配符匹配 [x:] 指定输出结果的属性遍历深度，默认为 1，最大值是 4 [m \u0026lt;arg\u0026gt;] 指定 Class 最大匹配数量，默认值为 50。长格式为[maxMatch \u0026lt;arg\u0026gt;]。 这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写 \u0026quot;{params,returnObj}\u0026quot;，只要是一个合法的 ognl 表达式，都能被正常支持。\n观察的维度也比较多，主要体现在参数 advice 的数据结构上。Advice 参数最主要是封装了通知节点的所有信息。请参考表达式核心变量中关于该节点的描述。\nwatch 命令定义了 4 个观察事件点，即 -b 函数调用前，-e 函数异常后，-s 函数返回后，-f 函数结束后 4 个观察事件点 -b、-e、-s 默认关闭，-f 默认打开，当指定观察点被打开后，在相应事件点会对观察表达式进行求值并输出 这里要注意 函数入参 和 函数出参 的区别，有可能在中间被修改导致前后不一致，除了 -b 事件点 params 代表函数入参外，其余事件都代表函数出参 当使用 -b 时，由于观察事件点是在函数调用前，此时返回值或异常均不存在 在 watch 命令的结果里，会打印出 location 信息。location 有三种可能值：AtEnter，AtExit，AtExceptionExit。对应函数入口，函数正常 return，函数抛出异常。 观察函数调用返回时的参数、this 对象和返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 观察表达式，默认值是{params, target, returnObj} $ watch demo.MathGame primeFactors -x 2 Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 32 ms, listenerId: 5 method=demo.MathGame.primeFactors location=AtExceptionExit ts=2021-08-31 15:22:57; [cost=0.220625ms] result=@ArrayList[ @Object[][ @Integer[-179173], ], @MathGame[ random=@Random[java.util.Random@31cefde0], illegalArgumentCount=@Integer[44], ], null, ] method=demo.MathGame.primeFactors location=AtExit ts=2021-08-31 15:22:58; [cost=1.020982ms] result=@ArrayList[ @Object[][ @Integer[1], ], @MathGame[ random=@Random[java.util.Random@31cefde0], illegalArgumentCount=@Integer[44], ], @ArrayList[ @Integer[2], @Integer[2], @Integer[26947], ], ] 上面的结果里，说明函数被执行了两次，第一次结果是 location=AtExceptionExit，说明函数抛出异常了，因此 returnObj 是 null 在第二次结果里是 location=AtExit，说明函数正常返回，因此可以看到 returnObj 结果是一个 ArrayList 指定 Class 最大匹配数量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ watch demo.MathGame primeFactors -m 1 Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 302 ms, listenerId: 3 method=demo.MathGame.primeFactors location=AtExceptionExit ts=2022-12-25 19:58:41; [cost=0.222419ms] result=@ArrayList[ @Object[][isEmpty=false;size=1], @MathGame[demo.MathGame@3bf400], null, ] method=demo.MathGame.primeFactors location=AtExceptionExit ts=2022-12-25 19:58:51; [cost=0.046928ms] result=@ArrayList[ @Object[][isEmpty=false;size=1], @MathGame[demo.MathGame@3bf400], null, ] 观察函数调用入口的参数和返回值 1 2 3 4 5 6 7 8 9 10 $ watch demo.MathGame primeFactors \u0026#34;{params,returnObj}\u0026#34; -x 2 -b Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 50 ms. ts=2018-12-03 19:23:23; [cost=0.0353ms] result=@ArrayList[ @Object[][ @Integer[-1077465243], ], null, ] # 对比前一个例子，返回值为空（事件点为函数执行前，因此获取不到返回值） 同时观察函数调用前和函数返回后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 $ watch demo.MathGame primeFactors \u0026#34;{params,target,returnObj}\u0026#34; -x 2 -b -s -n 2 Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 46 ms. ts=2018-12-03 19:29:54; [cost=0.01696ms] result=@ArrayList[ @Object[][ @Integer[1], ], @MathGame[ random=@Random[java.util.Random@522b408a], illegalArgumentCount=@Integer[13038], ], null, ] ts=2018-12-03 19:29:54; [cost=4.277392ms] result=@ArrayList[ @Object[][ @Integer[1], ], @MathGame[ random=@Random[java.util.Random@522b408a], illegalArgumentCount=@Integer[13038], ], @ArrayList[ @Integer[2], @Integer[2], @Integer[2], @Integer[5], @Integer[5], @Integer[73], @Integer[241], @Integer[439], ], ] 参数里 -n 2，表示只执行两次 这里输出结果中，第一次输出的是函数调用前的观察表达式的结果，第二次输出的是函数返回后的表达式的结果 结果的输出顺序和事件发生的先后顺序一致，和命令中 -s -b 的顺序无关 调整-x 的值，观察具体的函数参数值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 $ watch demo.MathGame primeFactors \u0026#34;{params,target}\u0026#34; -x 3 Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 58 ms. ts=2018-12-03 19:34:19; [cost=0.587833ms] result=@ArrayList[ @Object[][ @Integer[1], ], @MathGame[ random=@Random[ serialVersionUID=@Long[3905348978240129619], seed=@AtomicLong[3133719055989], multiplier=@Long[25214903917], addend=@Long[11], mask=@Long[281474976710655], DOUBLE_UNIT=@Double[1.1102230246251565E-16], BadBound=@String[bound must be positive], BadRange=@String[bound must be greater than origin], BadSize=@String[size must be non-negative], seedUniquifier=@AtomicLong[-3282039941672302964], nextNextGaussian=@Double[0.0], haveNextNextGaussian=@Boolean[false], serialPersistentFields=@ObjectStreamField[][isEmpty=false;size=3], unsafe=@Unsafe[sun.misc.Unsafe@2eaa1027], seedOffset=@Long[24], ], illegalArgumentCount=@Integer[13159], ], ] -x 表示遍历深度，可以调整来打印具体的参数和结果内容，默认值是 1。 -x 最大值是 4，防止展开结果占用太多内存。用户可以在 ognl 表达式里指定更具体的 field。 条件表达式的例子 1 2 3 4 5 6 7 8 $ watch demo.MathGame primeFactors \u0026#34;{params[0],target}\u0026#34; \u0026#34;params[0]\u0026lt;0\u0026#34; Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 68 ms. ts=2018-12-03 19:36:04; [cost=0.530255ms] result=@ArrayList[ @Integer[-18178089], @MathGame[demo.MathGame@41cf53f9], ] # 只有满足条件的调用，才会有响应。 观察异常信息的例子 1 2 3 4 5 6 7 8 9 10 11 $ watch demo.MathGame primeFactors \u0026#34;{params[0],throwExp}\u0026#34; -e -x 2 Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 62 ms. ts=2018-12-03 19:38:00; [cost=1.414993ms] result=@ArrayList[ @Integer[-1120397038], java.lang.IllegalArgumentException: number is: -1120397038, need \u0026gt;= 2 at demo.MathGame.primeFactors(MathGame.java:46) at demo.MathGame.run(MathGame.java:24) at demo.MathGame.main(MathGame.java:16) , ] -e表示抛出异常时才触发 express 中，表示异常信息的变量是 throwExp 按照耗时进行过滤 1 2 3 4 5 6 7 8 9 10 11 12 $ watch demo.MathGame primeFactors \u0026#39;{params, returnObj}\u0026#39; \u0026#39;#cost\u0026gt;200\u0026#39; -x 2 Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 66 ms. ts=2018-12-03 19:40:28; [cost=2112.168897ms] result=@ArrayList[ @Object[][ @Integer[1], ], @ArrayList[ @Integer[5], @Integer[428379493], ], ] #cost\u0026gt;200 (单位是 ms)表示只有当耗时大于 200ms 时才会输出，过滤掉执行时间小于 200ms 的调用 观察当前对象中的属性 如果想查看函数运行前后，当前对象中的属性，可以使用 target 关键字，代表当前对象\n1 2 3 4 5 6 7 $ watch demo.MathGame primeFactors \u0026#39;target\u0026#39; Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 52 ms. ts=2018-12-03 19:41:52; [cost=0.477882ms] result=@MathGame[ random=@Random[java.util.Random@522b408a], illegalArgumentCount=@Integer[13355], ] 然后使用 target.field_name 访问当前对象的某个属性\n1 2 3 4 5 $ watch demo.MathGame primeFactors \u0026#39;target.illegalArgumentCount\u0026#39; Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 67 ms. ts=2018-12-03 20:04:34; [cost=131.303498ms] result=@Integer[8] ts=2018-12-03 20:04:35; [cost=0.961441ms] result=@Integer[8] 获取类的静态字段、调用类的静态函数的例子 1 2 3 4 5 6 7 8 9 10 watch demo.MathGame * \u0026#39;{params,@demo.MathGame@random.nextInt(100)}\u0026#39; -v -n 1 -x 2 [arthas@6527]$ watch demo.MathGame * \u0026#39;{params,@demo.MathGame@random.nextInt(100)}\u0026#39; -n 1 -x 2 Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 5) cost in 34 ms, listenerId: 3 ts=2021-01-05 21:35:20; [cost=0.173966ms] result=@ArrayList[ @Object[][ @Integer[-138282], ], @Integer[89], ] 注意这里使用 Thread.currentThread().getContextClassLoader() 加载,使用精确 classloader ognl 更好。\n排除掉指定的类 提示\nwatch/trace/monitor/stack/tt 命令都支持 --exclude-class-pattern 参数\n使用 --exclude-class-pattern 参数可以排除掉指定的类，比如：\n1 watch javax.servlet.Filter * --exclude-class-pattern com.demo.TestFilter 不匹配子类 默认情况下 watch/trace/monitor/stack/tt 命令都会匹配子类。如果想不匹配，可以通过全局参数关掉。\n1 options disable-sub-class true 使用 -v 参数打印更多信息 提示\nwatch/trace/monitor/stack/tt 命令都支持 -v 参数\n当命令执行之后，没有输出结果。有两种可能：\n匹配到的函数没有被执行 条件表达式结果是 false 但用户区分不出是哪种情况。\n使用 -v 选项，则会打印 Condition express 的具体值和执行结果，方便确认。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ watch -v -x 2 demo.MathGame print \u0026#39;params\u0026#39; \u0026#39;params[0] \u0026gt; 100000\u0026#39; Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 29 ms, listenerId: 11 Condition express: params[0] \u0026gt; 100000 , result: false Condition express: params[0] \u0026gt; 100000 , result: false Condition express: params[0] \u0026gt; 100000 , result: true ts=2020-12-02 22:38:56; [cost=0.060843ms] result=@Object[][ @Integer[200033], @ArrayList[ @Integer[200033], ], ] Condition express: params[0] \u0026gt; 100000 , result: true ts=2020-12-02 22:38:57; [cost=0.052877ms] result=@Object[][ @Integer[123047], @ArrayList[ @Integer[29], @Integer[4243], ], ] trace 提示\n方法内部调用路径，并输出方法路径上的每个节点上耗时\ntrace 命令能主动搜索 class-pattern／method-pattern 对应的方法调用路径，渲染和统计整个调用链路上的所有性能开销和追踪调用链路。\n参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 condition-express 条件表达式 [E] 开启正则表达式匹配，默认为通配符匹配 [n:] 命令执行次数 #cost 方法执行耗时 [m \u0026lt;arg\u0026gt;] 指定 Class 最大匹配数量，默认值为 50。长格式为[maxMatch \u0026lt;arg\u0026gt;]。 这里重点要说明的是条件表达式，条件表达式的构成主要由 ognl 表达式组成，所以你可以这样写 \u0026quot;params[0]\u0026lt;0\u0026quot;，只要是一个合法的 ognl 表达式，都能被正常支持。\n很多时候我们只想看到某个方法的 rt 大于某个时间之后的 trace 结果，现在 Arthas 可以按照方法执行的耗时来进行过滤了，例如 trace \\*StringUtils isBlank '#cost\u0026gt;100' 表示当执行时间超过 100ms 的时候，才会输出 trace 的结果。\n提示\nwatch/stack/trace 这个三个命令都支持 #cost\n注意事项:\ntrace 能方便的帮助你定位和发现因 RT 高而导致的性能问题缺陷，但其每次只能跟踪一级方法的调用链路。 3.3.0 版本后，可以使用动态 Trace 功能，不断增加新的匹配类，参考下面的示例。 目前不支持 trace java.lang.Thread getName ，考虑到不是非常必要场景，且修复有一定难度，因此当前暂不修复 trace 函数 1 2 3 4 5 6 7 8 9 10 $ trace demo.MathGame run Press Q or Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 28 ms. `---ts=2019-12-04 00:45:08;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 `---[0.617465ms] demo.MathGame:run() `---[0.078946ms] demo.MathGame:primeFactors() #24 [throws Exception] `---ts=2019-12-04 00:45:09;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 `---[1.276874ms] demo.MathGame:run() `---[0.03752ms] demo.MathGame:primeFactors() #24 [throws Exception] 结果里的 #24，表示在 run 函数里，在源文件的第 24 行调用了primeFactors()函数。\n指定 Class 匹配的最大数量 1 2 3 4 5 6 7 8 9 10 $ trace demo.MathGame run -m 1 Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 412 ms, listenerId: 4 `---ts=2022-12-25 21:00:00;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@b4aac2 `---[0.762093ms] demo.MathGame:run() `---[30.21% 0.230241ms] demo.MathGame:primeFactors() #46 [throws Exception] `---ts=2022-12-25 21:00:10;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@b4aac2 `---[0.315298ms] demo.MathGame:run() `---[13.95% 0.043995ms] demo.MathGame:primeFactors() #46 [throws Exception] trace 次数限制 如果方法调用的次数很多，那么可以用 -n 参数指定捕捉结果的次数。比如下面的例子里，捕捉到一次调用就退出命令。\n1 2 3 4 5 6 7 8 9 trace demo.MathGame run -n 1 Press Q or Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 20 ms. `---ts=2019-12-04 00:45:53;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 `---[0.549379ms] demo.MathGame:run() +---[0.059839ms] demo.MathGame:primeFactors() #24 `---[0.232887ms] demo.MathGame:print() #25 Command execution times exceed limit: 1, so command will exit. You can set it with -n option. 包含 jdk 的函数 --skipJDKMethod \u0026lt;value\u0026gt; skip jdk method trace, default value true. 默认情况下，trace 不会包含 jdk 里的函数调用，如果希望 trace jdk 里的函数，需要显式设置 --skipJDKMethod false。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $ trace --skipJDKMethod false demo.MathGame run Press Q or Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 60 ms. `---ts=2019-12-04 00:44:41;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 `---[1.357742ms] demo.MathGame:run() +---[0.028624ms] java.util.Random:nextInt() #23 +---[0.045534ms] demo.MathGame:primeFactors() #24 [throws Exception] +---[0.005372ms] java.lang.StringBuilder:\u0026lt;init\u0026gt;() #28 +---[0.012257ms] java.lang.Integer:valueOf() #28 +---[0.234537ms] java.lang.String:format() #28 +---[min=0.004539ms,max=0.005778ms,total=0.010317ms,count=2] java.lang.StringBuilder:append() #28 +---[0.013777ms] java.lang.Exception:getMessage() #28 +---[0.004935ms] java.lang.StringBuilder:toString() #28 `---[0.06941ms] java.io.PrintStream:println() #28 `---ts=2019-12-04 00:44:42;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 `---[3.030432ms] demo.MathGame:run() +---[0.010473ms] java.util.Random:nextInt() #23 +---[0.023715ms] demo.MathGame:primeFactors() #24 [throws Exception] +---[0.005198ms] java.lang.StringBuilder:\u0026lt;init\u0026gt;() #28 +---[0.006405ms] java.lang.Integer:valueOf() #28 +---[0.178583ms] java.lang.String:format() #28 +---[min=0.011636ms,max=0.838077ms,total=0.849713ms,count=2] java.lang.StringBuilder:append() #28 +---[0.008747ms] java.lang.Exception:getMessage() #28 +---[0.019768ms] java.lang.StringBuilder:toString() #28 `---[0.076457ms] java.io.PrintStream:println() #28 根据调用耗时过滤 1 2 3 4 5 6 7 8 $ trace demo.MathGame run \u0026#39;#cost \u0026gt; 10\u0026#39; Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 41 ms. `---ts=2018-12-04 01:12:02;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 `---[12.033735ms] demo.MathGame:run() +---[0.006783ms] java.util.Random:nextInt() +---[11.852594ms] demo.MathGame:primeFactors() `---[0.05447ms] demo.MathGame:print() 只会展示耗时大于 10ms 的调用路径，有助于在排查问题的时候，只关注异常情况\n是不是很眼熟，没错，在 JProfiler 等收费软件中你曾经见识类似的功能，这里你将可以通过命令就能打印出指定调用路径。 友情提醒下，trace 在执行的过程中本身是会有一定的性能开销，在统计的报告中并未像 JProfiler 一样预先减去其自身的统计开销。所以这统计出来有些许的不准，渲染路径上调用的类、方法越多，性能偏差越大。但还是能让你看清一些事情的。 [12.033735ms] 的含义，12.033735 的含义是：当前节点在当前步骤的耗时，单位为毫秒 [0,0,0ms,11]xxx:yyy() [throws Exception]，对该方法中相同的方法调用进行了合并，0,0,0ms,11 表示方法调用耗时，min,max,total,count；throws Exception 表明该方法调用中存在异常返回 这里存在一个统计不准确的问题，就是所有方法耗时加起来可能会小于该监测方法的总耗时，这个是由于 Arthas 本身的逻辑会有一定的耗时 trace 多个类或者多个函数 trace 命令只会 trace 匹配到的函数里的子调用，并不会向下 trace 多层。因为 trace 是代价比较贵的，多层 trace 可能会导致最终要 trace 的类和函数非常多。\n可以用正则表匹配路径上的多个类和函数，一定程度上达到多层 trace 的效果。\n1 trace -E com.test.ClassA|org.test.ClassB method1|method2|method3 trace 时间不准确 比如下面的结果里：0.705196 \u0026gt; (0.152743 + 0.145825)\n1 2 3 4 5 6 7 $ trace demo.MathGame run -n 1 Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 66 ms, listenerId: 1 `---ts=2021-02-08 11:27:36;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@232204a1 `---[0.705196ms] demo.MathGame:run() +---[0.152743ms] demo.MathGame:primeFactors() #24 `---[0.145825ms] demo.MathGame:print() #25 那么其它的时间消耗在哪些地方？\n没有被 trace 到的函数。比如 java.\\* 下的函数调用默认会忽略掉。通过增加 --skipJDKMethod false 参数可以打印出来。 1 2 3 4 5 6 7 8 9 10 11 12 13 $ trace demo.MathGame run --skipJDKMethod false Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 35 ms, listenerId: 2 `---ts=2021-02-08 11:27:48;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@232204a1 `---[0.810591ms] demo.MathGame:run() +---[0.034568ms] java.util.Random:nextInt() #23 +---[0.119367ms] demo.MathGame:primeFactors() #24 [throws Exception] +---[0.017407ms] java.lang.StringBuilder:\u0026lt;init\u0026gt;() #28 +---[0.127922ms] java.lang.String:format() #57 +---[min=0.01419ms,max=0.020221ms,total=0.034411ms,count=2] java.lang.StringBuilder:append() #57 +---[0.021911ms] java.lang.Exception:getMessage() #57 +---[0.015643ms] java.lang.StringBuilder:toString() #57 `---[0.086622ms] java.io.PrintStream:println() #57 非函数调用的指令消耗。比如 i++, getfield 等指令。 在代码执行过程中，JVM 可能出现停顿，比如 GC，进入同步块等。 stack 提示\n输出当前方法被调用的调用路径\n很多时候我们都知道一个方法被执行，但这个方法被执行的路径非常多，或者你根本就不知道这个方法是从那里被执行了，此时你需要的是 stack 命令。\n参数名称 参数说明 class-pattern 类名表达式匹配 method-pattern 方法名表达式匹配 condition-express 条件表达式 [E] 开启正则表达式匹配，默认为通配符匹配 [n:] 执行次数限制 [m \u0026lt;arg\u0026gt;] 指定 Class 最大匹配数量，默认值为 50。长格式为[maxMatch \u0026lt;arg\u0026gt;]。 这里重点要说明的是观察表达式，观察表达式的构成主要由 ognl 表达式组成，所以你可以这样写 \u0026quot;{params,returnObj}\u0026quot;，只要是一个合法的 ognl 表达式，都能被正常支持。\n观察的维度也比较多，主要体现在参数 advice 的数据结构上。Advice 参数最主要是封装了通知节点的所有信息。\nstack - run 1 2 3 4 5 6 $ stack demo.MathGame primeFactors Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 36 ms. ts=2018-12-04 01:32:19;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 @demo.MathGame.run() at demo.MathGame.main(MathGame.java:16) 指定 Class 最大匹配数量 1 2 3 4 5 6 7 $ stack demo.MathGame primeFactors -m 1 Press Q or Ctrl+C to abort. Affect(class count:1 , method count:1) cost in 561 ms, listenerId: 5. ts=2022-12-25 21:07:07;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@b4aac2 @demo.MathGame.primeFactors() at demo.MathGame.run(MathGame.java:46) at demo.MathGame.main(MathGame.java:38) 据条件表达式来过滤 1 2 3 4 5 6 7 8 9 10 11 12 $ stack demo.MathGame primeFactors \u0026#39;params[0]\u0026lt;0\u0026#39; -n 2 Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 30 ms. ts=2018-12-04 01:34:27;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 @demo.MathGame.run() at demo.MathGame.main(MathGame.java:16) ts=2018-12-04 01:34:30;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 @demo.MathGame.run() at demo.MathGame.main(MathGame.java:16) Command execution times exceed limit: 2, so command will exit. You can set it with -n option. 据执行时间来过滤 1 2 3 4 5 6 $ stack demo.MathGame primeFactors \u0026#39;#cost\u0026gt;5\u0026#39; Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 35 ms. ts=2018-12-04 01:35:58;thread_name=main;id=1;is_daemon=false;priority=5;TCCL=sun.misc.Launcher$AppClassLoader@3d4eac69 @demo.MathGame.run() at demo.MathGame.main(MathGame.java:16) tt 提示\n方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测\nwatch 虽然很方便和灵活，但需要提前想清楚观察表达式的拼写，这对排查问题而言要求太高，因为很多时候我们并不清楚问题出自于何方，只能靠蛛丝马迹进行猜测。\n这个时候如果能记录下当时方法调用的所有入参和返回值、抛出的异常会对整个问题的思考与判断非常有帮助。\n于是乎，TimeTunnel 命令就诞生了。\n注意事项:\ntt 命令的实现是：把函数的入参/返回值等，保存到一个 Map\u0026lt;Integer, TimeFragment\u0026gt; 里，默认的大小是 100。 tt 相关功能在使用完之后，需要手动释放内存，否则长时间可能导致 OOM。退出 arthas 不会自动清除 tt 的缓存 map。 记录调用 对于一个最基本的使用来说，就是记录下当前方法的每次调用环境现场。\n1 2 3 4 5 6 7 8 9 10 $ tt -t demo.MathGame primeFactors Press Ctrl+C to abort. Affect(class-cnt:1 , method-cnt:1) cost in 66 ms. INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD ------------------------------------------------------------------------------------------------------------------------------------- 1000 2018-12-04 11:15:38 1.096236 false true 0x4b67cf4d MathGame primeFactors 1001 2018-12-04 11:15:39 0.191848 false true 0x4b67cf4d MathGame primeFactors 1002 2018-12-04 11:15:40 0.069523 false true 0x4b67cf4d MathGame primeFactors 1003 2018-12-04 11:15:41 0.186073 false true 0x4b67cf4d MathGame primeFactors 1004 2018-12-04 11:15:42 17.76437 true false 0x4b67cf4d MathGame 指定 Class 最大匹配数量 1 2 3 4 5 6 7 $ tt -t -m 1 demo.MathGame primeFactors Press Q or Ctrl+C to abort. Affect(class count:1 , method count:1) cost in 130 ms, listenerId: 1. INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD ------------------------------------------------------------------------------------------------------------------------------------- 1000 2022-12-25 19:41:45 2.629929 true false 0x3bf400 MathGame primeFactors 1001 2022-12-25 19:41:55 0.146161 false true 0x3bf400 MathGame 命令参数解析\n-t tt 命令有很多个主参数，-t 就是其中之一。这个参数的表明希望记录下类 *Test 的 print 方法的每次执行情况。\n-n 3 当你执行一个调用量不高的方法时可能你还能有足够的时间用 CTRL+C 中断 tt 命令记录的过程，但如果遇到调用量非常大的方法，瞬间就能将你的 JVM 内存撑爆。\n此时你可以通过 -n 参数指定你需要记录的次数，当达到记录次数时 Arthas 会主动中断 tt 命令的记录过程，避免人工操作无法停止的情况。\n-m 1 通过 -m 参数指定 Class 匹配的最大数量，防止匹配到的 Class 数量太多导致 JVM 挂起，默认值是 50 表格字段说明\n表格字段 字段解释 INDEX 时间片段记录编号，每一个编号代表着一次调用，后续 tt 还有很多命令都是基于此编号指定记录操作，非常重要。 TIMESTAMP 方法执行的本机时间，记录了这个时间片段所发生的本机时间 COST(ms) 方法执行的耗时 IS-RET 方法是否以正常返回的形式结束 IS-EXP 方法是否以抛异常的形式结束 OBJECT 执行对象的 hashCode()，注意，曾经有人误认为是对象在 JVM 中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体 CLASS 执行的类名 METHOD 执行的方法名 条件表达式 不知道大家是否有在使用过程中遇到以下困惑\nArthas 似乎很难区分出重载的方法 我只需要观察特定参数，但是 tt 却全部都给我记录了下来 条件表达式也是用 OGNL 来编写，核心的判断对象依然是 Advice 对象。除了 tt 命令之外，watch、trace、stack 命令也都支持条件表达式。\n解决方法重载\n1 tt -t *Test print params.length==1 通过制定参数个数的形式解决不同的方法签名，如果参数个数一样，你还可以这样写\n1 tt -t *Test print \u0026#39;params[1] instanceof Integer\u0026#39; 解决指定参数\n1 tt -t *Test print params[0].mobile==\u0026#34;13989838402\u0026#34; 构成条件表达式的 Advice 对象\n前边看到了很多条件表达式中，都使用了 params[0]，有关这个变量的介绍，请参考表达式核心变量\n检索调用记录 当你用 tt 记录了一大片的时间片段之后，你希望能从中筛选出自己需要的时间片段，这个时候你就需要对现有记录进行检索。\n假设我们有这些记录\n1 2 3 4 5 6 7 8 9 10 11 $ tt -l INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD ------------------------------------------------------------------------------------------------------------------------------------- 1000 2018-12-04 11:15:38 1.096236 false true 0x4b67cf4d MathGame primeFactors 1001 2018-12-04 11:15:39 0.191848 false true 0x4b67cf4d MathGame primeFactors 1002 2018-12-04 11:15:40 0.069523 false true 0x4b67cf4d MathGame primeFactors 1003 2018-12-04 11:15:41 0.186073 false true 0x4b67cf4d MathGame primeFactors 1004 2018-12-04 11:15:42 17.76437 true false 0x4b67cf4d MathGame primeFactors 9 1005 2018-12-04 11:15:43 0.4776 false true 0x4b67cf4d MathGame primeFactors Affect(row-cnt:6) cost in 4 ms. 我需要筛选出 primeFactors 方法的调用信息\n1 2 3 4 5 6 7 8 9 10 11 $ tt -s \u0026#39;method.name==\u0026#34;primeFactors\u0026#34;\u0026#39; INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD ------------------------------------------------------------------------------------------------------------------------------------- 1000 2018-12-04 11:15:38 1.096236 false true 0x4b67cf4d MathGame primeFactors 1001 2018-12-04 11:15:39 0.191848 false true 0x4b67cf4d MathGame primeFactors 1002 2018-12-04 11:15:40 0.069523 false true 0x4b67cf4d MathGame primeFactors 1003 2018-12-04 11:15:41 0.186073 false true 0x4b67cf4d MathGame primeFactors 1004 2018-12-04 11:15:42 17.76437 true false 0x4b67cf4d MathGame primeFactors 9 1005 2018-12-04 11:15:43 0.4776 false true 0x4b67cf4d MathGame primeFactors Affect(row-cnt:6) cost in 607 ms. 你需要一个 -s 参数。同样的，搜索表达式的核心对象依旧是 Advice 对象。\n查看调用信息 对于具体一个时间片的信息而言，你可以通过 -i 参数后边跟着对应的 INDEX 编号查看到他的详细信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $ tt -i 1003 INDEX 1003 GMT-CREATE 2018-12-04 11:15:41 COST(ms) 0.186073 OBJECT 0x4b67cf4d CLASS demo.MathGame METHOD primeFactors IS-RETURN false IS-EXCEPTION true PARAMETERS[0] @Integer[-564322413] THROW-EXCEPTION java.lang.IllegalArgumentException: number is: -564322413, need \u0026gt;= 2 at demo.MathGame.primeFactors(MathGame.java:46) at demo.MathGame.run(MathGame.java:24) at demo.MathGame.main(MathGame.java:16) Affect(row-cnt:1) cost in 11 ms. 重做一次调用 当你稍稍做了一些调整之后，你可能需要前端系统重新触发一次你的调用，此时得求爷爷告奶奶的需要前端配合联调的同学再次发起一次调用。而有些场景下，这个调用不是这么好触发的。\ntt 命令由于保存了当时调用的所有现场信息，所以我们可以自己主动对一个 INDEX 编号的时间片自主发起一次调用，从而解放你的沟通成本。此时你需要 -p 参数。通过 --replay-times 指定 调用次数，通过 --replay-interval 指定多次调用间隔(单位 ms, 默认 1000ms)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $ tt -i 1004 -p RE-INDEX 1004 GMT-REPLAY 2018-12-04 11:26:00 OBJECT 0x4b67cf4d CLASS demo.MathGame METHOD primeFactors PARAMETERS[0] @Integer[946738738] IS-RETURN true IS-EXCEPTION false COST(ms) 0.186073 RETURN-OBJ @ArrayList[ @Integer[2], @Integer[11], @Integer[17], @Integer[2531387], ] Time fragment[1004] successfully replayed. Affect(row-cnt:1) cost in 14 ms. 你会发现结果虽然一样，但调用的路径发生了变化，由原来的程序发起变成了 Arthas 自己的内部线程发起的调用了。\n观察表达式 -w, --watch-express 观察时空隧道使用 ognl 表达式\n使用表达式核心变量中所有变量作为已知条件编写表达式。\n1 2 3 4 5 6 7 8 9 [arthas@10718]$ tt -t demo.MathGame run -n 5 Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 56 ms, listenerId: 1 INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1000 2021-01-08 21:54:17 0.901091 true false 0x7699a589 MathGame run [arthas@10718]$ tt -w \u0026#39;target.illegalArgumentCount\u0026#39; -x 1 -i 1000 @Integer[60] Affect(row-cnt:1) cost in 7 ms. 获取类的静态字段、调用类的静态方法\n1 2 3 4 5 6 7 8 [arthas@10718]$ tt -t demo.MathGame run -n 5 Press Q or Ctrl+C to abort. Affect(class count: 1 , method count: 1) cost in 56 ms, listenerId: 1 INDEX TIMESTAMP COST(ms) IS-RET IS-EXP OBJECT CLASS METHOD ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1000 2021-01-08 21:54:17 0.901091 true false 0x7699a589 MathGame run [arthas@10718]$ tt -w \u0026#39;@demo.MathGame@random.nextInt(100)\u0026#39; -x 1 -i 1000 @Integer[46] 注意这里使用 com.taobao.arthas.core.advisor.Advice#getLoader 加载,使用精确 classloader ognl 更好。\n需要强调的点\nThreadLocal 信息丢失 很多框架偷偷的将一些环境变量信息塞到了发起调用线程的 ThreadLocal 中，由于调用线程发生了变化，这些 ThreadLocal 线程信息无法通过 Arthas 保存，所以这些信息将会丢失。\n一些常见的 CASE 比如：鹰眼的 TraceId 等。\n引用的对象 需要强调的是，tt 命令是将当前环境的对象引用保存起来，但仅仅也只能保存一个引用而已。如果方法内部对入参进行了变更，或者返回的对象经过了后续的处理，那么在 tt 查看的时候将无法看到当时最准确的值。这也是为什么 watch 命令存在的意义。\n通过索引删除指定的 tt 记录 1 tt -d 1001 清除所有的 tt 记录 1 tt --delete-all profiler 提示\n使用 async-profiler 生成火焰图\nprofiler 命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。\nprofiler 命令基本运行结构是 profiler action [actionArg]\n参数名称 参数说明 action 要执行的操作 actionArg 属性名模式 [i:] 采样间隔（单位：ns）（默认值：10'000'000，即 10 ms） [f:] 将输出转储到指定路径 [d:] 运行评测指定秒 [e:] 要跟踪哪个事件（cpu, alloc, lock, cache-misses 等），默认是 cpu 启动 profiler 1 profiler start 提示\n默认情况下，生成的是 cpu 的火焰图，即 event 为 cpu。可以用\u0026ndash;event 参数来指定。\n获取已采集的 sample 的数量 1 2 $ profiler getSamples 23 查看 profiler 状态 1 2 $ profiler status [cpu] profiling is running for 4 seconds 可以查看当前 profiler 在采样哪种 event 和采样时间。\n停止 profiler 1 2 3 4 5 # 默认情况下，结果文件是html格式，也可以用--format参数指定： $ profiler stop --format html profiler output file: /tmp/test/arthas-output/20211207-111550.html OK # 或者在--file参数里用文件名指名格式。比如--file /tmp/result.html 。 profiler 支持的 events 1 2 3 4 5 # 在不同的平台，不同的 OS 下面，支持的 events 各有不同。可以使用命令查看： profiler list # 可以用--event参数指定要采样的事件，比如对alloc事件进入采样： profiler start --event alloc 恢复采样 1 profiler resume start 和 resume 的区别是：start 是新开始采样，resume 会保留上次 stop 时的数据。\n通过执行 profiler getSamples 可以查看 samples 的数量来验证。\n使用 execute 来执行复杂的命令 比如开始采样：\n1 profiler execute \u0026#39;start,framebuf=5000000\u0026#39; 停止采样，并保存到指定文件里：\n1 profiler execute \u0026#39;stop,file=/tmp/result.html\u0026#39; 查看所有支持的 action 1 2 $ profiler actions Supported Actions: [resume, dumpCollapsed, getSamples, start, list, execute, version, stop, load, dumpFlat, actions, dumpTraces, status] 查看版本 1 2 3 $ profiler version Async-profiler 1.6 built on Sep 9 2019 Copyright 2019 Andrei Pangin 配置 framebuf 参数 如果遇到生成的火焰图有 [frame_buffer_overflow]，则需要增大 framebuf（默认值是 1'000'000），可以显式配置，比如：\n1 profiler start --framebuf 5000000 配置 include/exclude 来过滤数据 如果应用比较复杂，生成的内容很多，想只关注部分数据，可以通过 include/exclude 来过滤。比如\n1 profiler start --include \u0026#39;java/*\u0026#39; --include \u0026#39;demo/*\u0026#39; --exclude \u0026#39;*Unsafe.park*\u0026#39; include/exclude 都支持设置多个值 ，但是需要配置在命令行的最后。\n指定执行时间 比如，希望 profiler 执行 300 秒自动结束，可以用 -d/--duration 参数指定：\n1 profiler start --duration 300 生成 jfr 格式结果 注意，jfr 只支持在 start 时配置。如果是在 stop 时指定，则不会生效。\n1 profiler start --file /tmp/test.jfr file 参数支持一些变量：\n时间戳： \u0026ndash;file /tmp/test-%t.jfr 进程 ID： \u0026ndash;file /tmp/test-%p.jfr 生成的结果可以用支持 jfr 格式的工具来查看。比如：\nJDK Mission Control JProfiler jfr 提示\nJava Flight Recorder (JFR) 是一种用于收集有关正在运行的 Java 应用程序的诊断和分析数据的工具。它集成到 Java 虚拟机 (JVM) 中，几乎不会造成性能开销，因此即使在负载较重的生产环境中也可以使用。\njfr 命令支持在程序动态运行过程中开启和关闭 JFR 记录。 记录收集有关 event 的数据。事件在特定时间点发生在 JVM 或 Java 应用程序中。每个事件都有一个名称、一个时间戳和一个可选的有效负载。负载是与事件相关的数据，例如 CPU 使用率、事件前后的 Java 堆大小、锁持有者的线程 ID 等。\njfr 命令基本运行结构是 jfr cmd [actionArg]\n注意： JDK8 的 8u262 版本之后才支持 jfr\n参数名称 参数说明 cmd 要执行的操作 支持的命令【start，status，dump，stop】 actionArg 属性名模式 [n:] 记录名称 [r:] 记录 id 值 [dumponexit:] 程序退出时，是否要 dump 出 .jfr 文件，默认为 false [d:] 延迟多久后启动 JFR 记录，支持带单位配置，eg: 60s, 2m, 5h, 3d. 不带单位就是秒，默认无延迟 [duration:] JFR 记录持续时间，支持单位配置，不带单位就是秒，默认一直记录 [s:] 采集 Event 的详细配置文件，默认是 default.jfc 位于 $JAVA_HOME/lib/jfr/default.jfc [f:] 将输出转储到指定路径 [maxage:] 缓冲区数据最大文件记录保存时间，支持单位配置，不带单位就是秒，默认是不限制 [maxsize:] 缓冲区的最大文件大小，支持单位配置， 不带单位是字节，m 或者 M 代表 MB，g 或者 G 代表 GB。 [state:] jfr 记录状态 启动 JFR 记录 1 2 $ jfr start Started recording 1. No limit specified, using maxsize=250MB as default. 提示\n默认情况下，开启的是默认参数的 jfr 记录\n启动 jfr 记录，指定记录名，记录持续时间，记录文件保存路径。\n1 2 3 $ jfr start -n myRecording --duration 60s -f /tmp/myRecording.jfr Started recording 2. The result will be written to: /tmp/myRecording.jfr 查看 JFR 记录状态 默认是查看所有 JFR 记录信息\n1 2 3 $ jfr status Recording: recording=1 name=Recording-1 (running) Recording: recording=2 name=myRecording duration=PT1M (closed) 查看指定记录 id 的记录信息\n1 2 $ jfr status -r 1 Recording: recording=1 name=Recording-1 (running) 查看指定状态的记录信息\n1 2 $ jfr status --state closed Recording: recording=2 name=myRecording duration=PT1M (closed) dump jfr 记录 jfr dump 会输出从开始到运行该命令这段时间内的记录到 JFR 文件，且不会停止 jfr 的记录 指定记录输出路径\n1 2 3 $ jfr dump -r 1 -f /tmp/myRecording1.jfr Dump recording 1, The result will be written to: /tmp/myRecording1.jfr 不指定文件输出路径，默认是保存到 arthas-output 目录下\n1 2 3 $ jfr dump -r 1 Dump recording 1, The result will be written to: /tmp/test/arthas-output/20220819-200915.jfr 停止 jfr 记录 不指定记录输出路径，默认是保存到 arthas-output 目录下\n1 2 3 $ jfr stop -r 1 Stop recording 1, The result will be written to: /tmp/test/arthas-output/20220819-202049.jfr 注意一条记录只能停止一次。\n也可以指定记录输出路径。\n通过浏览器查看 arthas-output 下面 JFR 记录的结果 默认情况下，arthas 使用 8563 端口，则可以打开： http://localhost:8563/arthas-output/ 查看到 arthas-output 目录下面的 JFR 记录结果。\n生成的结果可以用支持 jfr 格式的工具来查看。比如：\nJDK Mission Control ","date":"2024-03-22T09:39:46+08:00","permalink":"https://www.lcsk42.com/post/arthas/","title":"Arthas"},{"content":"UML 类图解析和对应的 PlantUML 效果实现。\n可见性 符号 可见性 范围 + public 所有类可见 # protected 该类子孙可见 - private 类本身可见 ~ package 同一包生命其他类可见 关系 关系 英文 关系强弱 泛化 Generalization 6 实现 Realization 5 组合 Composition 4 聚合 Aggregation 3 关联 Association 2 依赖 Dependency 1 关系符号基础 类图关系的符号由三部分组成：箭头、线条和箭尾：\n箭头形状有两种，分别为箭头和三角箭头:\n线条形状有两种，分别为实线和虚线:\n箭尾形状有三种，分别为点、空心菱形和实心菱形:\n符号优先级 整体：箭头 \u0026gt; 箭尾 \u0026gt; 线条\n箭头：三角箭头 \u0026gt; 箭头\n箭尾：实心菱形 \u0026gt; 空心菱形 \u0026gt; 点\n线条：实线 \u0026gt; 虚线\n组合 关系 英文 三角箭头 + 实线 泛化 Generalization 三角箭头 + 虚线 实现 Realization 实心菱形 + 实线 组合 Composition 实心菱形 + 虚线 聚合 Aggregation 箭头 + 实线 关联 Association 箭头 + 虚线 依赖 Dependency 关系解析 泛化（继承） Generalization 1 ClassA \u0026lt;|-- ClassB 箭头指向：三角箭头 + 实线，表示继承一个基类，ClassB 继承 ClassA 泛化关系：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为\n实现 Realization 1 2 interface InterfaceA InterfaceA \u0026lt;|.. ClassC 箭头指向: 三角箭头 + 虚线,箭头指向接口，表示 C 类实线接口定义 实线关系: 类与接口的关系，表示类实现了接口的所有特征和行为\n组合 Composition 1 Department --* Company 箭头方向: 实心菱形 + 实线，菱形指向整体 组合关系: 整体和部分的关系，部分不能离开整体而单独存在\n聚合 Aggregation 1 Wheel --o Car 箭头方向: 空心菱形 + 实线, 菱形指向整体 聚合关系: 是整体和部分的关系，部分可以离开整体单独存在\n关联 Association 1 2 3 ClassAA \u0026lt;-- ClassBB ClassAAA -- ClassBBB ClassAAAA \u0026lt;--\u0026gt; ClassBBBB 箭头方向：箭头 + 实线,指向被拥有着 关联关系：拥有关系，一个类知道另一个类的特征和行为 PS: 分为单向关联和双向关联，双向关联可以两个箭头，也可以不要箭头\n依赖 Dependency 1 ClassAAAAA \u0026lt;.. ClassBBBBB 箭头方向：箭头 + 虚线，指向被使用者 依赖关系：使用关系，一个类的实现需要另一个类的协助\nPlantUML 效果：\n代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @startuml class Dummy { +field1 #field2 -field3 ~field4 +method1() #method2() -method3() ~method4() } package \u0026#34;Generalization\u0026#34; \u0026lt;\u0026lt;Rectangle\u0026gt;\u0026gt;{ ClassA \u0026lt;|-- ClassB } package \u0026#34;Realization\u0026#34; \u0026lt;\u0026lt;Rectangle\u0026gt;\u0026gt;{ interface InterfaceA InterfaceA \u0026lt;|.. ClassC } package \u0026#34;Composition\u0026#34; \u0026lt;\u0026lt;Rectangle\u0026gt;\u0026gt;{ Department --* Company } package \u0026#34;Aggregation\u0026#34; \u0026lt;\u0026lt;Rectangle\u0026gt;\u0026gt;{ Wheel --o Car } package \u0026#34;Association\u0026#34; \u0026lt;\u0026lt;Rectangle\u0026gt;\u0026gt;{ ClassAA \u0026lt;-- ClassBB ClassAAA -- ClassBBB ClassAAAA \u0026lt;--\u0026gt; ClassBBBB } package \u0026#34;Dependency\u0026#34; \u0026lt;\u0026lt;Rectangle\u0026gt;\u0026gt;{ ClassAAAAA \u0026lt;.. ClassBBBBB } @enduml ","date":"2024-03-20T10:17:02+08:00","permalink":"https://www.lcsk42.com/post/uml-class/","title":"UML Class"},{"content":"23 种设计模式。\n整理自 Java Design Patterns, 去除了代码实现部分，方便快速回顾。\n总览 设计模式分为三种类型，共 23 种：\n创建型模式(Creational Pattern)：\n工厂模式(Factory Method) 5 抽象工厂模式(Abstract Factory) 5 单例模式(Singleton) 4 建造者模式(Builder) 2 原型模式(Prototype) 3 结构型模式(Structural Pattern)：\n外观模式(Facade) 5 适配器模式(Adapter) 4 组合模式(Composite) 4 代理模式(Proxy) 4 桥接模式(Bridge) 3 装饰模式(Decorator) 3 享元模式(Flyweight) 1 行为型模式(Behavioral Pattern)：\n迭代器模式(Iterator) 5 观察者模式(Observer) 5 策略模式(Strategy) 4 命令模式(Command) 4 模版方法模式(Template Method) 3 状态模式(State) 3 责任链模式(Chain of Responsibility) 3 中介者模式(Mediator) 2 备忘录模式(Memento) 2 解释器模式(Interpreter) 1 访问者模式(Visitor) 1 创建型模式 对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。\n创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When) 等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。\n工厂模式 详细地址: Java Design Patterns\n工厂模式 - 目的 为创建一个对象定义一个接口，但是让子类决定实例化哪个类。工厂方法允许类将实例化延迟到子类。\n工厂模式 - 解释 真实世界例子\n铁匠生产武器。精灵需要精灵武器，而兽人需要兽人武器。根据客户来召唤正确类型的铁匠。\n通俗的说\n它为类提供了一种把实例化的逻辑委托给子类的方式。\n维基百科上说\n在基于类的编程中，工厂方法模式是一种创建型设计模式用来解决创建对象的问题，而不需要指定将要创建对象的确切类。这是通过调用工厂方法创建对象来完成的，而不是通过调用构造器。该工厂方法在接口中指定并由子类实现，或者在基类实现并可以选择由子类重写。\n工厂模式 - 适用性 使用工厂方法模式当\n一个类无法预料它所要必须创建的对象的类 一个类想要它的子类来指定它要创建的对象 类将责任委派给几个帮助子类中的一个，而你想定位了解是具体之中的哪一个 工厂模式 - 使用 java.util.Calendar java.util.ResourceBundle java.text.NumberFormat java.nio.charset.Charset java.net.URLStreamHandlerFactory java.util.EnumSet javax.xml.bind.JAXBContext 抽象工厂模式 详细地址: Java Design Patterns\n抽象工厂模式 - 目的 提供一个用于创建相关对象家族的接口，而无需指定其具体类。\n抽象工厂模式 - 解释 真实世界例子\n要创建一个王国，我们需要具有共同主题的对象。精灵王国需要精灵国王、精灵城堡和精灵军队，而兽人王国需要兽人国王、兽人城堡和兽人军队。王国中的对象之间存在依赖关系。\n通俗的说\n工厂的工厂； 一个将单个但相关/从属的工厂分组在一起而没有指定其具体类别的工厂。\n维基百科上说\n抽象工厂模式提供了一种封装一组具有共同主题的单个工厂而无需指定其具体类的方法\n抽象工厂模式 - 适用性 在以下情况下使用抽象工厂模式\n该系统应独立于其产品的创建，组成和表示方式 系统应配置有多个产品系列之一 相关产品对象系列旨在一起使用，你需要强制执行此约束 你想提供产品的类库，并且只想暴露它们的接口，而不是它们的实现。 从概念上讲，依赖项的生存期比使用者的生存期短。 你需要一个运行时值来构建特定的依赖关系 你想决定在运行时从系列中调用哪种产品。 你需要提供一个或更多仅在运行时才知道的参数，然后才能解决依赖关系。 当你需要产品之间的一致性时 在向程序添加新产品或产品系列时，您不想更改现有代码。 示例场景\n在运行时在 FileSystemAcmeService ，DatabaseAcmeService 或 NetworkAcmeService 中选择并调用一个 单元测试用例的编写变得更加容易 适用于不同操作系统的 UI 工具 抽象工厂模式 - 后果 Java 中的依赖注入会隐藏服务类的依赖关系，这些依赖关系可能导- 致运行时错误，而这些错误在编译时会被捕获。 虽然在创建预定义对象时模式很好，但是添加新对象可能会很困难。 由于引入了许多新的接口和类，因此代码变得比应有的复杂。 抽象工厂模式 - 使用 javax.xml.parsers.DocumentBuilderFactory javax.xml.transform.TransformerFactory javax.xml.xpath.XPathFactory 单例模式 详细地址: Java Design Patterns\n单例模式 - 目的 确保一个类只有一个实例，并为其提供一个全局访问点。\n单例模式 - 解释 情境示例\n巫师们之在一个象牙塔中学习他们的魔法，并且始终使用同一座附魔的象牙塔。 这里的象牙塔是一个单例对象。\n通俗来说\n对于一个特定的类，确保只会创建一个对象。\n维基百科说\n在软件工程中，单例模式是一种软件设计模式，它将类的实例化限制为一个对象。当系统中只需要一个对象来协调各种操作时，这种模式非常有用。\n单例模式 - 适用性 当满足以下情况时，使用单例模式：\n确保一个类只有一个实例，并且客户端能够通过一个众所周知的访问点访问该实例。 唯一的实例能够被子类扩展, 同时客户端不需要修改代码就能使用扩展后的实例。 一些典型的单例模式用例包括：\nlogging 类 管理与数据库的链接 文件管理器（File manager） 单例模式 - 使用 java.lang.Runtime#getRuntime() java.awt.Desktop#getDesktop() java.lang.System#getSecurityManager() 建造者模式 详细地址: Java Design Patterns\n建造者模式 - 目的 将复杂对象的构造与其表示分开，以便同一构造过程可以创建不同的表示。\n建造者模式 - 解释 现实世界例子\n想象一个角色扮演游戏的角色生成器。最简单的选择是让计算机为你创建角色。但是如果你想选择一些像专业，性别，发色等角色细节时，这个角色生成就变成了一个渐进的过程。当所有选择完成时，该过程也将完成。\n用通俗的话说\n允许你创建不同口味的对象同时避免构造器污染。当一个对象可能有几种口味，或者一个对象的创建涉及到很多步骤时会很有用。\n维基百科说\n建造者模式是一种对象创建的软件设计模式，旨在为伸缩构造器反模式寻找一个解决方案。\n建造者模式 - 适用性 使用建造者模式当\n创建复杂对象的算法应独立于组成对象的零件及其组装方式 构造过程必须允许所构造的对象具有不同的表示形式 建造者模式 - 使用 java.lang.StringBuilder java.nio.ByteBuffer as well as similar buffers such as FloatBuffer, IntBuffer and so on. java.lang.StringBuffer All implementations of java.lang.Appendable Apache Camel builders Apache Commons Option.Builder 原型模式 结构型模式 结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。\n结构型模式可以分为类结构型模式和对象结构型模式：\n类结构型模式关心类的组合，由多个类可以组合成一个更大的 系统，在类结构型模式中一般只存在继承关系和实现关系。 - 对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。\n外观模式 详细地址: Java Design Patterns\n外观模式 - 目的 为一个子系统中的一系列接口提供一个统一的接口。外观定义了一个更高级别的接口以便子系统更容易使用。\n外观模式 - 解释 真实世界的例子\n一个金矿是怎么工作的？“嗯，矿工下去然后挖金子！”你说。这是你所相信的因为你在使用一个金矿对外提供的一个简单接口，在内部它要却要做很多事情。这个简单的接口对复杂的子系统来说就是一个外观。\n用通俗的话说\n外观模式为一个复杂的子系统提供一个简单的接口。\n维基百科说\n外观是为很大体量的代码（比如类库）提供简单接口的一种对象。\n外观模式 - 适用性 使用外观模式当\n你想为一个复杂的子系统提供一个简单的接口。随着子系统的发展，它们通常会变得更加复杂。多数模式在应用时会导致更多和更少的类。这使子系统更可重用，更易于自定义，但是对于不需要自定义它的客户来说，使用它也变得更加困难。 外观可以提供子系统的简单默认视图，足以满足大多数客户端的需求。只有需要更多可定制性的客户才需要查看外观外的东西（原子系统提供的接口）。 客户端与抽象的实现类之间存在许多依赖关系。 引入外观以使子系统与客户端和其他子系统分离，从而提高子系统的独立性和可移植性。 您想对子系统进行分层。 使用外观来定义每个子系统级别的入口点。 如果子系统是相关的，则可以通过使子系统仅通过其外观相互通信来简化它们之间的依赖性。 适配器模式 详细地址: Java Design Patterns\n适配器模式 - 目的 将一个接口转换成另一个客户所期望的接口。适配器让那些本来因为接口不兼容的类可以合作无间。\n适配器模式 - 解释 现实世界例子\n考虑有这么一种情况，在你的存储卡中有一些照片，你想将其传到你的电脑中。为了传送数据，你需要某种能够兼容你电脑接口的适配器以便你的储存卡能连上你的电脑。在这种情况下，读卡器就是一个适配器。 另一个例子就是注明的电源适配器；三脚插头不能插在两脚插座上，需要一个电源适配器来使其能够插在两脚插座上。 还有一个例子就是翻译官，他翻译一个人对另一个人说的话。\n用直白的话来说\n适配器模式让你可以把不兼容的对象包在适配器中，以让其兼容其他类。\n维基百科中说\n在软件工程中，适配器模式是一种可以让现有类的接口把其作为其他接口来使用的设计模式。它经常用来使现有的类和其他类能够工作并且不用修改其他类的源代码。\n适配器模式 - 应用 使用适配器模式当\n你想使用一个已有类，但是它的接口不能和你需要的所匹配 你需要创建一个可重用类，该类与不相关或不可预见的类进行协作，即不一定具有兼容接口的类 你需要使用一些现有的子类，但是子类化他们每一个的子类来进行接口的适配是不现实的。一个对象适配器可以适配他们父类的接口。 大多数使用第三方类库的应用使用适配器作为一个在应用和第三方类库间的中间层来使应用和类库解耦。如果必须使用另一个库，则只需使用一个新库的适配器而无需改变应用程序的代码。 适配器模式 - 后果 类和对象适配器有不同的权衡取舍。一个类适配器\n适配被适配者到目标接口，需要保证只有一个具体的被适配者类。作为结果，当我们想适配一个类和它所有的子类时，类适配器将不会起作用。 可以让适配器重写一些被适配者的行为，因为适配器是被适配者的子类。 只引入了一个对象，并且不需要其他指针间接访问被适配者。 对象适配器\n一个适配器可以和许多被适配者工作，也就是被适配者自己和所有它的子类。适配器同时可以为所有被适配者添加功能。 覆盖被适配者的行为变得更难。需要子类化被适配者然后让适配器引用这个子类不是被适配者。 适配器模式 - 使用 java.util.Arrays#asList() java.util.Collections#list() java.util.Collections#enumeration() javax.xml.bind.annotation.adapters.XMLAdapter 组合模式 详细地址: Java Design Patterns\n组合模式 -目的 将对象组合成树结构以表示部分整体层次结构。 组合可以使客户统一对待单个对象和组合对象。\n组合模式 - 解释 真实世界例子\n每个句子由单词组成，单词又由字符组成。这些对象中的每一个都是可打印的，它们可以在它们之前或之后打印一些内容，例如句子始终以句号结尾，单词始终在其前面有空格。\n通俗的说\n组合模式使客户能够以统一的方式对待各个对象。\n维基百科说\n在软件工程中，组合模式是一种分区设计模式。组合模式中，一组对象将像一个对象的单独实例一样被对待。组合的目的是将对象“组成”树状结构，以表示部分整体层次结构。实现组合模式可使客户统一对待单个对象和组合对象。\n组合模式 - 适用性 使用组合模式当\n你想要表示对象的整体层次结构 你希望客户能够忽略组合对象和单个对象之间的差异。 客户将统一对待组合结构中的所有对象。 组合模式 - 使用 java.awt.Container and java.awt.Component Apache Wicket component tree, see Component and MarkupContainer 代理模式 详细地址: Java Design Patterns\n代理模式 - 目的 为另一个对象提供代理或占位符以控制对其的访问。\n代理模式 - 解释 真实世界例子\n想象有一个塔，当地的巫师去那里学习他们的法术。象牙塔只能够通过代理来进入以此来保证只有首先 3 个巫师才能进入。这里的代理就代表的塔的功能并添加访问控制。\n通俗的说\n使用代理模式，一个类代表另一个类的功能。\n维基百科说\n在最一般的形式上，代理是一个类，它充当与其他对象的接口。代理是客户端调用的包装器或代理对象，以访问后台的实际服务对象。代理本身可以简单地转发到真实对象，也可以提供其他逻辑。在代理中，可以提供额外的功能，例如在对实对象的操作占用大量资源时进行缓存，或者在对实对象的操作被调用之前检查前提条件。\n代理模式 - 适用性 代理适用于需要比简单指针更广泛或更复杂的对象引用的情况。这是代理模式适用的几种常见情况。\n远程代理为不同地址空间中的对象提供了本地代表。 虚拟代理根据需要创建昂贵的对象。 保护代理控制对原始对象的访问。当对象有不同的接入权限时保护代理很有用。 代理模式 - 典型用例 对象的访问控制 懒加载 实现日志记录 简化网络连接 对象的访问计数 代理模式 - 使用 java.lang.reflect.Proxy Apache Commons Proxy Mocking frameworks Mockito, Powermock, EasyMock 桥接模式 详细地址: Java Design Patterns\n桥接模式 - 目的 将抽象与其实现分离，以便二者可以独立变化。\n桥接模式 - 解释 真实世界例子\n考虑一下你拥有一种具有不同附魔的武器，并且应该允许将具有不同附魔的不同武器混合使用。 你会怎么做？ 为每个附魔创建每种武器的多个副本，还是只是创建单独的附魔并根据需要为武器设置它？ 桥接模式使您可以进行第二次操作。\n通俗的说\n桥接模式是一个更推荐组合而不是继承的模式。将实现细节从一个层次结构推送到具有单独层次结构的另一个对象。\n维基百科说\n桥接模式是软件工程中使用的一种设计模式，旨在“将抽象与其实现分离，从而使两者可以独立变化”\n桥接模式 - 适用性 使用桥接模式当\n你想永久性的避免抽象和他的实现之间的绑定。有可能是这种情况，当实现需要被选择或者在运行时切换。 抽象和他们的实现应该能通过写子类来扩展。这种情况下，桥接模式让你可以组合不同的抽象和实现并独立的扩展他们。 对抽象的实现的改动应当不会对客户产生影响；也就是说，他们的代码不必重新编译。 你有种类繁多的类。这样的类层次结构表明需要将一个对象分为两部分。Rumbaugh 使用术语“嵌套归纳”来指代这种类层次结构。 你想在多个对象间分享一种实现（可能使用引用计数），这个事实应该对客户隐藏。一个简单的示例是 Coplien 的 String 类，其中多个对象可以共享同一字符串表示形式 装饰模式 详细地址: Java Design Patterns\n装饰模式 - 目的 动态的为对象附加额外的职责。装饰器为子类提供了灵活的替代方案，以扩展功能。\n装饰模式 - 解释 真实世界例子\n附近的山丘上住着一个愤怒的巨魔。通常它是徒手的，但有时它有武器。为了武装巨魔不必创建新的巨魔，而是用合适的武器动态的装饰它。\n通俗的说\n装饰者模式让你可以在运行时通过把对象包装进一个装饰类对象中来动态的改变一个对象的行为。\n维基百科说\n在面向对象的编程中，装饰器模式是一种设计模式，它允许将行为静态或动态地添加到单个对象中，而不会影响同一类中其他对象的行为。装饰器模式通常对于遵守单一责任原则很有用，因为它允许将功能划分到具有唯一关注领域的类之间。\n装饰模式 - 适用性 使用装饰者\n动态透明地向单个对象添加职责，即不影响其他对象 对于可以撤销的责任 当通过子类化进行扩展是不切实际的。有时可能会有大量的独立扩展，并且会产生大量的子类来支持每种组合。 否则类定义可能被隐藏或无法用于子类化。 装饰模式 - 使用 java.io.InputStream, java.io.OutputStream, java.io.Reader and java.io.Writer java.util.Collections#synchronizedXXX() java.util.Collections#unmodifiableXXX() java.util.Collections#checkedXXX() 享元模式 行为型模式 行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。\n行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。\n通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。\n行为型模式分为类行为型模式和对象行为型模式两种：\n类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。 对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。\n迭代器模式 详细地址: Java Design Patterns\n迭代器模式 - 目的 提供一种在不暴露其基础表示的情况下顺序访问聚合对象的元素的方法。\n迭代器模式 - 解释 真实世界例子\n百宝箱包含一组魔法物品。有多种物品，例如戒指，药水和武器。可以使用藏宝箱提供的迭代器按类型浏览商品。\n通俗地说\n容器可以提供与表示形式无关的迭代器接口，以提供对元素的访问。\n维基百科说\n在面向对象的编程中，迭代器模式是一种设计模式，其中迭代器用于遍历容器并访问容器的元素。\n迭代器模式 - 适用性 以下情况使用迭代器模式\n在不暴露其内部表示的情况下访问聚合对象的内容 为了支持聚合对象的多种遍历方式 提供一个遍历不同聚合结构的统一接口 迭代器模式 - 使用 java.util.Iterator java.util.Enumeration 观察者模式 详细地址: Java Design Patterns\n观察者模式 - 目的 定义一种一对多的对象依赖关系这样当一个对象改变状态时，所有依赖它的对象都将自动通知或更新。\n观察者模式 - 解释 真实世界例子\n在遥远的土地上生活着霍比特人和兽人的种族。他们都是户外生活的人所以他们密切关注天气的变化。可以说他们不断地关注着天气。\n通俗的说\n注册成为一个观察者以接收对象状态的改变。\n维基百科说\n观察者模式是这样的一种软件设计模式：它有一个被称为主题的对象，维护着一个所有依赖于它的依赖者清单，也就是观察者清单，当主题的状态发生改变时，主题通常会调用观察者的方法来自动通知观察者们。\n观察者模式 - 应用 在下面任何一种情况下都可以使用观察者模式\n当抽象具有两个方面时，一个方面依赖于另一个方面。将这些方面封装在单独的对象中，可以使你分别进行更改和重用 当一个对象的改变的同时需要改变其他对象，同时你又不知道有多少对象需要改变时 当一个对象可以通知其他对象而无需假设这些对象是谁时。换句话说，你不想让这些对象紧耦合。 典型用例\n一个对象的改变导致其他对象的改变 观察者模式 - 使用 java.util.Observer java.util.EventListener javax.servlet.http.HttpSessionBindingListener RxJava 策略模式 详细地址: Java Design Patterns\n策略模式 - 目的 定义一个家族算法，并封装好其中每一个，使它们可以互相替换。策略模式使算法的变化独立于使用它的客户。\n策略模式 - 解释 现实世界例子\n屠龙是一项危险的职业。有经验将会使它变得简单。经验丰富的屠龙者对不同类型的龙有不同的战斗策略。\n直白点说\n策略模式允许在运行时选择最匹配的算法。\n维基百科上说\n在程序编程领域，策略模式（又叫政策模式）是一种启用在运行时选择算法的行为型软件设计模式。\n策略模式 - 应用 使用策略模式当\n许多相关的类只是行为不同。策略模式提供了一种为一种类配置多种行为的能力。 你需要一种算法的不同变体。比如，你可能定义反应不用时间空间权衡的算法。当这些算法的变体使用类的层次结构来实现时就可以使用策略模式。 一个算法使用的数据客户不应该对其知晓。使用策略模式来避免暴露复杂的，特定于算法的数据结构。 一个类定义了许多行为，这些行为在其操作中展现为多个条件语句。移动相关的条件分支到它们分别的策略类中来代替这些条件语句。 命令模式 详细地址: Java Design Patterns\n命令模式 - 目的 将请求封装为对象，从而使你可以将具有不同请求的客户端参数化，队列或记录请求，并且支持可撤销操作。\n命令模式 - 解释 真实世界例子\n有一个巫师在地精上施放咒语。咒语在地精上一一执行。第一个咒语使地精缩小，第二个使他不可见。然后巫师将咒语一个个的反转。这里的每一个咒语都是一个可撤销的命令对象。\n用通俗的话说\n用命令对象的方式存储请求以在将来时可以执行它或撤销它。\n维基百科说\n在面向对象编程中，命令模式是一种行为型设计模式，它把在稍后执行的一个动作或触发的一个事件所需要的所有信息封装到一个对象中。\n命令模式 - 适用性 使用命令模式当你想\n通过操作将对象参数化。您可以使用回调函数（即，已在某处注册以便稍后调用的函数）以过程语言表示这种参数化。命令是回调的一种面向对象替代方案。 在不同的时间指定，排队和执行请求。一个命令对象的生存期可以独立于原始请求。如果请求的接收方可以以地址空间无关的方式来表示，那么你可以将请求的命令对象传输到其他进程并在那里执行请求。 支持撤销。命令的执行操作可以在命令本身中存储状态以反转其效果。命令接口必须有添加的反执行操作，该操作可以逆转上一次执行调用的效果。执行的命令存储在历史列表中。无限撤消和重做通过分别向后和向前遍历此列表来实现，分别调用 unexecute 和 execute。 支持日志记录更改，以便在系统崩溃时可以重新应用它们。通过使用加载和存储操作扩展命令接口，你可以保留更改的永久日志。从崩溃中恢复涉及从磁盘重新加载记录的命令，并通过执行操作重新执行它们。 通过原始的操作来构建一个以高级操作围绕的系统。这种结构在支持事务的信息系统中很常见。事务封装了一组数据更改。命令模式提供了- 一种对事务进行建模的方法。命令具有公共接口，让你以相同的方式调用所有事务。该模式还可以通过新的事务来轻松扩展系统。 命令模式 - 典型用例 保留请求历史 实现回调功能 实现撤销功能 命令模式 - 使用 java.lang.Runnable org.junit.runners.model.Statement Netflix Hystrix javax.swing.Action 模版方法模式 详细地址: Java Design Patterns\n模版方法模式 - 目的 在一个操作中定义算法的骨架，将某些步骤推迟到子类。模板方法允许子类重新定义算法的某些步骤，而无需更改算法的结构。\n模版方法模式 - 解释 真实世界例子\n偷东西的一般步骤是相同的。 首先，选择目标，然后以某种方式使其迷惑，最后，你偷走了该物品。然而这些步骤有很多实现方式。\n通俗的说\n模板方法模式在父类中列出一般的步骤然后让具体的子类定义实现细节。\n维基百科说\n在面向对象的编程中，模板方法是 Gamma 等人确定的行为设计模式之一。在《设计模式》一书中。模板方法是父类中一个方法，通常是一个抽象父类，根据许多高级步骤定义了操作的骨架。这些步骤本身由与模板方法在同一类中的其他帮助程序方法实现。\n模版方法模式 - 适用性 使用模板方法模式可以\n一次性实现一个算法中不变的部分并将其留给子类来实现可能变化的行为。 子类之间的共同行为应分解并集中在一个共同类中，以避免代码重复。如 Opdyke 和 Johnson 所描述的，这是“重构概括”的一个很好的例子。你首先要确定现有代码中的差异，然后将差异拆分为新的操作。最后，将不同的代码替换为调用这些新操作之一的模板方法。 控制子类扩展。您可以定义一个模板方法，该方法在特定点调用“ 钩子”操作，从而仅允许在这些点进行扩展 模版方法模式 - 使用 javax.servlet.GenericServlet.init:\nMethod GenericServlet.init(ServletConfig config) calls the parameterless method GenericServlet.init() which is intended to be overridden in subclasses.\nMethod GenericServlet.init(ServletConfig config) is the template method in this example.\n状态模式 详细地址: Java Design Patterns\n状态模式 - 目的 允许对象在内部状态改变时改变它的行为。对象看起来好像修改了它的类。\n状态模式 - 解释 真实世界例子\n当在长毛象的自然栖息地观察长毛象时，似乎它会根据情况来改变自己的行为。它开始可能很平静但是随着时间推移当它检测到威胁时它会对周围的环境感到愤怒和危险。\n通俗的说\n状态模式允许对象改变它的行为。\n维基百科说\n状态模式是一种允许对象在内部状态改变时改变它的行为的行为型设计模式。这种模式接近于有限状态机的概念。状态模式可以被理解为策略模式，它能够通过调用在模式接口中定义的方法来切换策略。\n状态模式 - 适用性 在以下两种情况下，请使用 State 模式\n对象的行为取决于它的状态，并且它必须在运行时根据状态更改其行为。 根据对象状态的不同，操作有大量的条件语句。此状态通常由一个或多个枚举常量表示。通常，几个操作将包含此相同的条件结构。状态模式把条件语句的分支分别放入单独的类中。这样一来，你就可以将对象的状态视为独立的对象，该对象可以独立于其他对象而变化。 状态模式 - 使用 javax.faces.lifecycle.Lifecycle#execute() controlled by FacesServlet, the behavior is dependent on current phase of lifecycle. JDiameter - Diameter State Machine 责任链模式 详细地址: Java Design Patterns\n责任链模式 - 目的 通过给多个对象一个处理请求的机会，避免请求的发送者和它的接收者耦合。串联接收对象并在链条中传递请求直到一个对象处理它。\n责任链模式 - 解释 真实世界例子\n兽王大声命令他的军队。最近响应的是指挥官，然后是军官，然后是士兵。指挥官，军官，士兵这里就形成了一个责任链。\n通俗的说\n它帮助构建一串对象。请求从一个对象中进入并结束然后进入到一个个对象中直到找到合适的处理器。\n维基百科说\n在面向对象设计中，责任链模式是一种由源命令对象和一系列处理对象组成的设计模式。每个处理对象包含了其定义的可处理的命令对象类型的逻辑。剩下的会传递给链条中的下一个处理对象。\n责任链模式 - 适用性 使用责任链模式当\n多于一个对象可能要处理请求，并且处理器并不知道一个优先级。处理器应自动确定。 你想对多个对象之一发出请求而无需明确指定接收者 处理请求的对象集合应该被动态指定时 责任链模式 - 使用 java.util.logging.Logger#log() Apache Commons Chain javax.servlet.Filter#doFilter() 中介者模式 备忘录模式 解释器模式 详细地址: Java Design Patterns\n解释器模式 - 目的 给定一种语言，请定义其语法的表示形式，以及使用该表示形式来解释该语言中的句子的解释器。\n解释器模式 - 适用性 有一种要解释的语言时，请使用解释器模式，并且可以将语言中的语句表示为抽象语法树。解释器模式在以下情况下效果最佳\n语法很简单。 对于复杂的语法，语法的类层次结构变得庞大且难以管理。 在这种情况下，解析器生成器之类的工具是更好的选择。 他们可以在不构建抽象语法树的情况下解释表达式，这可以节省空间并可能节省时间 效率不是关键问题。 通常，最有效的解释器不是通过直接解释解析树来实现的，而是先将其转换为另一种形式。 例如，正则表达式通常会转换为状态机。 但是即使这样，翻译器也可以通过解释器模式实现，因此该模式仍然适用。 解释器模式 - 使用 java.util.Pattern java.text.Normalizer All subclasses of java.text.Format javax.el.ELResolver 访问者模式 详细地址: Java Design Patterns\n访问者模式 - 目的 表示要在对象结构的元素上执行的操作。访问者可让你定义新操作，而无需更改其所操作元素的类。\n访问者模式 - 解释 真实世界例子\n考虑有一个带有军队单位的树形结构。指挥官下有两名中士，每名中士下有三名士兵。基于这个层级结构实现访问者模式，我们可以轻松创建与指挥官，中士，士兵或所有人员互动的新对象\n通俗的说\n访问者模式定义可以在数据结构的节点上执行的操作。\n维基百科说\n在面向对象的程序设计和软件工程中，访问者设计模式是一种将算法与操作对象的结构分离的方法。这种分离的实际结果是能够在不修改结构的情况下向现有对象结构添加新操作。\n访问者模式 - 适用性 使用访问者模式当\n对象结构包含许多具有不同接口的对象类，并且你希望根据这些对象的具体类对这些对象执行操作。 需要对对象结构中的对象执行许多不同且不相关的操作，并且你想避免使用这些操作“污染”它们的类。 访问者可以通过在一个类中定义相关操作来将它们保持在一起。当许多应用程序共享对象结构时，请使用访问者模式将操作仅放在需要它们的那些应用程序中 定义对象结构的类很少变化，但是你经常想在结构上定义新的操作。更改对象结构类需要重新定义所有访问者的接口，这可能会导致成本高昂。如果对象结构类经常更改，则最好在这些类中定义操作。 访问者模式 - 使用 Apache Wicket component tree, see MarkupContainer javax.lang.model.element.AnnotationValue and AnnotationValueVisitor javax.lang.model.element.Element and Element Visitor java.nio.file.FileVisitor ","date":"2024-02-17T15:01:09+08:00","permalink":"https://www.lcsk42.com/post/design-patterns/","title":"Design Patterns"},{"content":"JMH is a Java harness for building, running, and analysing nano/micro/milli/macro benchmarks written in Java and other languages targeting the JVM.\nJMH 是一个 Java 工具，用于构建、运行和分析用 Java 和其他针对 JVM 的语言编写的纳/微米/毫/宏观基准测试。\nJMH 基础概念 Iteration: Iteration 是 JMH 进行测试的最小单位，包含一组 Invocations。 Invocation: 一次 Benchmark 方法调用。 Operation: Benchmark 方法中，被测量操作的执行。如果被测试的操作在 Benchmark 方法中循环执行，可以使用 @OperationsPerInvocation 表明循环次数，使测试结果为单次 Operation 的性能。 Warmup: 在实际进行 Benchmark 前先进行预热。因为某个函数被调用多次之后，JIT 会对其进行编译，通过预热可以使测量结果更加接近真实情况。 如何开始 JMH 在 JDK 12 中已经被包含，低版本则需要自己在 Maven 中进行引入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;jmh.version\u0026gt;1.27\u0026lt;/jmh.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.openjdk.jmh\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jmh-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jmh.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.openjdk.jmh\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jmh-generator-annprocess\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${jmh.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 相关注解 Warmup 1 2 @Warmup(iterations = -1, time = -1, timeUnit = TimeUnit.SECONDS, batchSize = -1) public class BenchmarkTest {} iterations: 预热多少轮。 time: 预热时间。 timeUnit: 时间单位，默认 秒。 batchSize: 指定每次操作调用多少次方法。 对应输出中的以下部分：\n1 2 3 4 5 # Warmup Iteration 1: 3359571890.253 ops/s # Warmup Iteration 2: 3410327185.841 ops/s # Warmup Iteration 3: 3397921599.396 ops/s # Warmup Iteration 4: 3435385874.666 ops/s # Warmup Iteration 5: 3418061628.223 ops/s Measurement 1 2 @Measurement(iterations = -1, time = -1, timeUnit = TimeUnit.SECONDS, batchSize = -1) public class BenchmarkTest {} iterations: 执行多少轮。 time: 执行时间。 timeUnit: 时间单位，默认 秒。 batchSize: 指定每次操作调用多少次方法。 Measurement 和 Warmup 的参数是一样的。不同于预热，它指的是真正的迭代次数。\n对应输出中的以下部分：\n1 2 3 4 5 Iteration 1: 3439847797.303 ops/s Iteration 2: 3450228067.947 ops/s Iteration 3: 3440088656.138 ops/s Iteration 4: 3427225995.315 ops/s Iteration 5: 3455433144.375 ops/s BenchmarkMode 1 2 @BenchmarkMode(Mode.All) public class BenchmarkTest {} 基准测试类型:\nThroughput: Throughput, ops/time (吞吐量，单位时间内执行的次数) AverageTime: Average time, time/op（平均时间，一次执行需要的单位时间，其实是吞吐量的倒数） SampleTime: Sampling time（是基于采样的执行时间，采样频率由 JMH 自动控制，同时结果中也会统计出 p90、p95 的时间） SingleShotTime: Single shot invocation time （只运行一次，把 Warmup 次数设为 0，可以用于测试冷启动时的性能） All: All benchmark modes （所有模式） Fork 1 2 @Fork(1) public class BenchmarkTest {} 值一般设置为 1，表示使用一个进程进行测试。如果大于 1，则会启用新的进程进行测试。\n值的注意的是，可以使用 jvmArgs,jvmArgsPrepend,jvmArgsAppend 来传递 JVM 相关的参数。\nThreads 1 2 @Threads(Threads.MAX) public class BenchmarkTest {} @Fork 是面向进程的，而 @Threads 是面向线程的。指定了这个注解以后，将会开启并行测试。\n如果设置了 Threads.MAX ，将会使用和处理机器核数相同的线程数。\nOutputTimeUnit 1 2 @OutputTimeUnit(TimeUnit.MICROSECONDS) public class BenchmarkTest {} 指定基准测试结果的时间类型。可以选择秒、毫秒、微秒等。\nState 1 2 @State(Scope.Thread) public class BenchmarkTest {} 指定了在类中变量的作用范围。可以用 Scope 参数用来表示该状态的共享范围。\nScope 有三个参数：\nBenchmark：表示变量的作用范围是某个基准测试类。 Thread：每个线程一份副本，如果配置了 Threads 注解，则每个 Thread 都拥有一份变量，它们互不影响。 Group：联系 @Group 注解，在同一个 Group 里，将会共享同一个变量实例。 Param 1 2 3 4 5 6 7 8 9 10 11 12 public class BenchmarkTest { @Param({\u0026#34;1\u0026#34;, \u0026#34;31\u0026#34;, \u0026#34;65\u0026#34;, \u0026#34;101\u0026#34;, \u0026#34;103\u0026#34;}) public int arg; @Param({\u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;16\u0026#34;, \u0026#34;32\u0026#34;}) public int certainty; @Benchmark public boolean bench() { return BigInteger.valueOf(arg).isProbablePrime(certainty); } } 属性注解，简单来说就是测试的时候将设置的各种值分别带入。\n需要注意的是，如果你设置了非常多的参数，这些参数将执行多次，通常会运行很长时间。\n比如参数 x 共 m 个，参数 y 共 n 个，那么总共要执行 m*n 次。\nGroup GroupThreads 1 2 3 4 5 6 7 public class BenchmarkTest { @Group(\u0026#34;group1\u0026#34;) @GroupThreads(1) public void test() {} } @Group 注解只能加在方法上，用来把测试方法进行归类。\n如果单个测试文件中方法很多，需要将其归类，则可以使用这个注解。\n与之关联的 @GroupThreads 注解，会在这个归类的基础上，再进行一些线程方面的设置。\nSetup TearDown 1 2 3 4 5 6 7 8 9 public class BenchmarkTest { @Setup(Level.Trial) public void init() {} @TearDown(Level.Trial) public void destory() {} } Setup 用于基准测试前的初始化动作,TearDown 用于基准测试后的动作,可以用来做一些全局的配置。\n这两个注解，同样有一个 Level 值，标明了方法运行的时机，它有三个取值。\nTrial：默认的级别。也就是 Benchmark 级别。 Iteration：每次迭代都会运行。 Invocation：每次方法调用都会运行，这个是粒度最细的。 Benchmark 1 2 3 4 5 public class BenchmarkTest { @Benchmark public void test() {} } 方法级注解，表示该方法是需要进行 benchmark 的对象，用法和 JUnit 的 @Test 类似。\n开始测试 创建相关类标注完注解之后，可以直接在 main 方法中开始测试：\n1 2 3 4 5 6 7 8 public class BenchmarkTest { public static void main(String[] args) throws RunnerException { final Options options = new OptionsBuilder() .include(BenchmarkTest.class.getSimpleName()) .build(); new Runner(options).run(); } } Dead-Code Elimination (死码消除) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class DeadCode { /* * The downfall of many benchmarks is Dead-Code Elimination (DCE): compilers * are smart enough to deduce some computations are redundant and eliminate * them completely. If the eliminated part was our benchmarked code, we are * in trouble. */ private double x = Math.PI; private double compute(double d) { for (int c = 0; c \u0026lt; 10; c++) { d = d * d / Math.PI; } return d; } @Benchmark public void baseline() { // do nothing, this is a baseline } @Benchmark public void measureWrong() { // This is wrong: result is not used and the entire computation is optimized away. compute(x); } @Benchmark public double measureRight() { // This is correct: the result is being used. return compute(x); } } 1 2 3 4 Benchmark Mode Cnt Score Error Units DeadCode.baseline avgt 5 0.292 ± 0.008 ns/op DeadCode.measureRight avgt 5 7.374 ± 0.213 ns/op DeadCode.measureWrong avgt 5 0.293 ± 0.003 ns/op Dead-Code Elimination (DCE) 死码消除，编译器非常聪明，上面的代码中，baseline() 和 measureWrong() 有着相同的效率,因为编译器发现有的代码没有作用，如上述 measureWrong() 并没有返回值，计算结果并没有被使用到，这时候为了效率，编译器会消除掉这段代码，但是对基准测试来说就很不友好。我们可以通过增加 return 的方法来避免编译期间代码被擦除掉。\n另外一种解决 DCE 的方法是，JMH 提供了一个 Blackholes （黑洞），我们使用 Blackholes 吃掉(consume)返回值就好了。\n1 2 3 4 @Benchmark public void measure(final Blackhole blackhole) { blackhole.consume(compute(x)); } Constant Fold (常量折叠) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 public class ConstantFold { /* * The flip side of dead-code elimination is constant-folding. * * If JVM realizes the result of the computation is the same no matter what, * it can cleverly optimize it. In our case, that means we can move the * computation outside of the internal JMH loop. * * This can be prevented by always reading the inputs from non-final * instance fields of @State objects, computing the result based on those * values, and follow the rules to prevent DCE. */ // IDEs will say \u0026#34;Oh, you can convert this field to local variable\u0026#34;. Don\u0026#39;t. Trust. Them. // (While this is normally fine advice, it does not work in the context of measuring correctly.) private double x = Math.PI; // IDEs will probably also say \u0026#34;Look, it could be final\u0026#34;. Don\u0026#39;t. Trust. Them. Either. // (While this is normally fine advice, it does not work in the context of measuring correctly.) private final double wrongX = Math.PI; private double compute(double d) { for (int c = 0; c \u0026lt; 10; c++) { d = d * d / Math.PI; } return d; } @Benchmark public double baseline() { // simply return the value, this is a baseline return Math.PI; } @Benchmark public double measureWrong_1() { // This is wrong: the source is predictable, and computation is foldable. return compute(Math.PI); } @Benchmark public double measureWrong_2() { // This is wrong: the source is predictable, and computation is foldable. return compute(wrongX); } @Benchmark public double measureRight() { // This is correct: the source is not predictable. return compute(x); } } 1 2 3 4 5 Benchmark Mode Cnt Score Error Units ConstantFold.baseline avgt 5 1.939 ± 0.100 ns/op ConstantFold.measureRight avgt 5 7.276 ± 0.042 ns/op ConstantFold.measureWrong_1 avgt 5 1.896 ± 0.004 ns/op ConstantFold.measureWrong_2 avgt 5 1.916 ± 0.010 ns/op constant-folding (常量折叠)，上述代码的 measureWrong1 和 measureWrong2 中的运算都是可以预测的值，所以也会在编译期直接替换为计算结果，从而导致基准测试失败，注意 final 修饰的变量也会被折叠。\nLoops（循环） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 public class Loops { /* * It would be tempting for users to do loops within the benchmarked method. * (This is the bad thing Caliper taught everyone). These tests explain why * this is a bad idea. * * Looping is done in the hope of minimizing the overhead of calling the * test method, by doing the operations inside the loop instead of inside * the method call. Don\u0026#39;t buy this argument; you will see there is more * magic happening when we allow optimizers to merge the loop iterations. */ /* * Suppose we want to measure how much it takes to sum two integers: */ int x = 1; int y = 2; /* * This is what you do with JMH. */ @Benchmark public int measureRight() { return (x + y); } /* * The following tests emulate the naive looping. * This is the Caliper-style benchmark. */ private int reps(int reps) { int s = 0; for (int i = 0; i \u0026lt; reps; i++) { s += (x + y); } return s; } /* * We would like to measure this with different repetitions count. * Special annotation is used to get the individual operation cost. */ @Benchmark @OperationsPerInvocation(1) public int measureWrong_1() { return reps(1); } @Benchmark @OperationsPerInvocation(10) public int measureWrong_10() { return reps(10); } @Benchmark @OperationsPerInvocation(100) public int measureWrong_100() { return reps(100); } @Benchmark @OperationsPerInvocation(1_000) public int measureWrong_1000() { return reps(1_000); } @Benchmark @OperationsPerInvocation(10_000) public int measureWrong_10000() { return reps(10_000); } @Benchmark @OperationsPerInvocation(100_000) public int measureWrong_100000() { return reps(100_000); } } 1 2 3 4 5 6 7 8 Benchmark Mode Cnt Score Error Units Loops.measureRight avgt 5 1.880 ± 0.014 ns/op Loops.measureWrong_1 avgt 5 1.880 ± 0.009 ns/op Loops.measureWrong_10 avgt 5 0.188 ± 0.001 ns/op Loops.measureWrong_100 avgt 5 0.019 ± 0.001 ns/op Loops.measureWrong_1000 avgt 5 0.022 ± 0.001 ns/op Loops.measureWrong_10000 avgt 5 0.019 ± 0.001 ns/op Loops.measureWrong_100000 avgt 5 0.020 ± 0.001 ns/op 不要在基准测试的时候使用循环，使用循环就会导致测试结果不准确。\nBlackhole 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 public class ConsumeCPU { /* * At times you require the test to burn some of the cycles doing nothing. * In many cases, you *do* want to burn the cycles instead of waiting. * * For these occasions, we have the infrastructure support. Blackholes * can not only consume the values, but also the time! Run this test * to get familiar with this part of JMH. * * (Note we use static method because most of the use cases are deep * within the testing code, and propagating blackholes is tedious). */ @Benchmark public void consume_0000() { Blackhole.consumeCPU(0); } @Benchmark public void consume_0001() { Blackhole.consumeCPU(1); } @Benchmark public void consume_0002() { Blackhole.consumeCPU(2); } @Benchmark public void consume_0004() { Blackhole.consumeCPU(4); } @Benchmark public void consume_0008() { Blackhole.consumeCPU(8); } @Benchmark public void consume_0016() { Blackhole.consumeCPU(16); } @Benchmark public void consume_0032() { Blackhole.consumeCPU(32); } @Benchmark public void consume_0064() { Blackhole.consumeCPU(64); } @Benchmark public void consume_0128() { Blackhole.consumeCPU(128); } @Benchmark public void consume_0256() { Blackhole.consumeCPU(256); } @Benchmark public void consume_0512() { Blackhole.consumeCPU(512); } @Benchmark public void consume_1024() { Blackhole.consumeCPU(1024); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 Benchmark Mode Cnt Score Error Units ConsumeCPU.consume_0000 avgt 5 1.976 ± 0.007 ns/op ConsumeCPU.consume_0001 avgt 5 1.933 ± 0.014 ns/op ConsumeCPU.consume_0002 avgt 5 2.058 ± 0.007 ns/op ConsumeCPU.consume_0004 avgt 5 3.182 ± 0.012 ns/op ConsumeCPU.consume_0008 avgt 5 4.462 ± 0.020 ns/op ConsumeCPU.consume_0016 avgt 5 10.607 ± 0.043 ns/op ConsumeCPU.consume_0032 avgt 5 27.758 ± 0.138 ns/op ConsumeCPU.consume_0064 avgt 5 77.873 ± 0.437 ns/op ConsumeCPU.consume_0128 avgt 5 190.842 ± 1.602 ns/op ConsumeCPU.consume_0256 avgt 5 412.204 ± 2.976 ns/op ConsumeCPU.consume_0512 avgt 5 856.362 ± 3.612 ns/op ConsumeCPU.consume_1024 avgt 5 1742.743 ± 9.288 ns/op Blackhole 除了可以用来“死码消除”，同时 Blackhole 也可以“吞噬”cpu 时间片。\nBlackhole.consumeCPU 的参数是时间片的 tokens，和时间片成线性关系。\nProfiler 1 2 3 4 5 6 7 8 public static void main(String[] args) throws RunnerException { Options opt = new OptionsBuilder() .include(ProfilersTest.Classy.class.getSimpleName()) .addProfiler(GCProfiler.class) .build(); new Runner(opt).run(); } JMH 内置的性能剖析工具可以查看基准测试消耗在什么地方，具体的剖析方式内置的有如下几种：\nClassloaderProfiler：类加载剖析 CompilerProfiler：JIT 编译剖析 GCProfiler：GC 剖析 StackProfiler：栈剖析 PausesProfiler：停顿剖析 HotspotThreadProfiler：Hotspot 线程剖析 HotspotRuntimeProfiler：Hotspot 运行时剖析 HotspotMemoryProfiler：Hotspot 内存剖析 HotspotCompilationProfiler：Hotspot 编译剖析 HotspotClassloadingProfiler：Hotspot 类加载剖析 图形化分析 1 2 3 4 5 6 7 8 9 10 11 12 public class BenchmarkTest { public static void main(String[] args) throws RunnerException { final Options options = new OptionsBuilder() .include(BenchmarkTest.class.getSimpleName()) .result(\u0026#34;BenchmarkTest.json\u0026#34;) .resultFormat(ResultFormatType.JSON) .build(); new Runner(options).run(); } } 使用 resultFormat 指定导出格式，result 指定导出为止，执行完成后，将测试数据导出为 JSON 文件后，上传到以下网站即可进行分析\nJMH Visualizer\nJMH Visual Chart\n","date":"2023-12-10T10:20:18+08:00","permalink":"https://www.lcsk42.com/post/java-microbenchmark-harness/","title":"Java Microbenchmark Harness"}]