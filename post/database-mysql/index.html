<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="数据库相关总结"><title>Database Mysql</title>
<link rel=canonical href=https://www.lcsk42.com/post/database-mysql/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="Database Mysql"><meta property='og:description' content="数据库相关总结"><meta property='og:url' content='https://www.lcsk42.com/post/database-mysql/'><meta property='og:site_name' content="Lucas's Article"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Database'><meta property='article:tag' content='MySQL'><meta property='article:published_time' content='2025-02-11T14:50:48+08:00'><meta property='article:modified_time' content='2025-02-11T14:50:48+08:00'><meta name=twitter:title content="Database Mysql"><meta name=twitter:description content="数据库相关总结"><link rel="shortcut icon" href=/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_b46f367e8ae3a2b0.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🫠</span></figure><div class=site-meta><h1 class=site-name><a href=/>Lucas's Article</a></h1><h2 class=site-description>Life is short; meeting you is the best fortune.</h2></div></header><ol class=menu-social><li><a href=https://github.com/lcsk42 target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:lcsk42@gmail.com target=_blank title=Mail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-mail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 7a2 2 0 012-2h14a2 2 0 012 2v10a2 2 0 01-2 2H5a2 2 0 01-2-2V7z"/><path d="M3 7l9 6 9-6"/></svg></a></li><li><a href=https://x.com/lcsk42 target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li><li><a href=/index.xml target=_blank title=RSS rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-rss"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 19m-1 0a1 1 0 102 0 1 1 0 10-2 0"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/about/><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-pagekit"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12.077 20H7V4h11v14h-5.077"/></svg>
<span>About</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#索引>索引</a><ol><li><a href=#索引的作用>索引的作用</a></li><li><a href=#索引的类型>索引的类型</a></li><li><a href=#索引的创建和管理>索引的创建和管理</a></li><li><a href=#索引的优缺点>索引的优缺点</a></li><li><a href=#索引的最佳实践>索引的最佳实践</a></li><li><a href=#创建索引的原则>创建索引的原则</a></li></ol></li><li><a href=#索引失效>索引失效</a><ol><li><a href=#条件不符合索引使用规则>条件不符合索引使用规则</a></li><li><a href=#查询条件的组合问题>查询条件的组合问题</a></li><li><a href=#索引选择策略和优化器影响>索引选择策略和优化器影响</a></li><li><a href=#其他影响索引使用的情况>其他影响索引使用的情况</a></li><li><a href=#索引例子>索引例子</a></li></ol></li><li><a href=#锁>锁</a><ol><li><a href=#锁的类型>锁的类型</a></li><li><a href=#锁的粒度>锁的粒度</a></li><li><a href=#锁的机制>锁的机制</a></li><li><a href=#死锁>死锁</a></li><li><a href=#常用锁相关语句>常用锁相关语句</a></li><li><a href=#锁的最佳实践>锁的最佳实践</a></li><li><a href=#锁例子>锁例子</a></li></ol></li><li><a href=#事务>事务</a><ol><li><a href=#事务的四大特征>事务的四大特征</a></li><li><a href=#并发事务问题>并发事务问题</a></li><li><a href=#四种标准的事务隔离级别>四种标准的事务隔离级别</a></li><li><a href=#乐悲观锁>乐(悲)观锁</a><ol><li><a href=#乐观锁-optimistic-lock>乐观锁 (Optimistic Lock)</a></li><li><a href=#悲观锁-pessimistic-lock>悲观锁 (Pessimistic Lock)</a></li><li><a href=#乐悲观锁总结>乐(悲)观锁总结</a></li></ol></li><li><a href=#mvcc多版本并发控制>MVCC（多版本并发控制）</a><ol><li><a href=#mvcc-的工作原理>MVCC 的工作原理</a></li><li><a href=#mvcc-的优点>MVCC 的优点</a></li><li><a href=#mvcc-处理的并发问题>MVCC 处理的并发问题</a></li><li><a href=#mvcc-的实现>MVCC 的实现</a></li><li><a href=#mvcc-总结>MVCC 总结</a></li></ol></li></ol></li><li><a href=#explain>EXPLAIN</a><ol><li><a href=#基本用法>基本用法</a></li><li><a href=#输出列的含义>输出列的含义</a></li><li><a href=#示例分析>示例分析</a><ol><li><a href=#简单查询>简单查询</a></li><li><a href=#连接查询>连接查询</a></li></ol></li><li><a href=#优化建议>优化建议</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/dev/>Dev</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/database-mysql/>Database Mysql</a></h2><h3 class=article-subtitle>数据库相关总结</h3></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 11, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>17 minute read</time></div></footer></div></header><section class=article-content><p>总结了遇到了数据库相关的知识。</p><h2 id=索引>索引</h2><p>MySQL 索引是提高数据库查询性能的重要工具。索引类似于书的目录，可以帮助数据库快速找到所需的数据，而不必遍历整个表。以下是有关 MySQL 索引的一些关键点和常见类型：</p><h3 id=索引的作用>索引的作用</h3><ol><li><strong>加速查询</strong>：通过索引，MySQL 可以快速定位到所需的数据行，从而减少查询时间</li><li><strong>确保唯一性</strong>：唯一索引（Unique Index）可以确保表中的某一列的所有值都是唯一的</li><li><strong>优化排序和分组</strong>：索引可以优化 <code>ORDER BY</code> 和 <code>GROUP BY</code> 操作。</li><li><strong>提高连接性能</strong>：在多表连接时，索引用于加速表之间的匹配。</li></ol><h3 id=索引的类型>索引的类型</h3><ol><li><p><strong>普通索引（Index）</strong>：最基本的索引类型，没有任何限制</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=p>(</span><span class=k>column_name</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>唯一索引（Unique Index）</strong>：确保索引列中的值是唯一的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=p>(</span><span class=k>column_name</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>主键索引（Primary Key）</strong>：一种特殊的唯一索引，不允许有空值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>column_name</span><span class=w> </span><span class=n>datatype</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=n>id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>全文索引（Full-Text Index）</strong>：用于对文本进行全文搜索。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=n>FULLTEXT</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=p>(</span><span class=k>column_name</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>复合索引（Composite Index）</strong>：在多个列上创建的索引。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=p>(</span><span class=n>column1</span><span class=p>,</span><span class=w> </span><span class=n>column2</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=索引的创建和管理>索引的创建和管理</h3><ol><li><p><strong>创建索引</strong>：使用 <code>CREATE INDEX</code> 或在 <code>CREATE TABLE</code> 语句中定义。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=p>(</span><span class=k>column_name</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>删除索引</strong>：使用 <code>DROP INDEX</code> 语句。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>DROP</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>idx_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>查看索引</strong>：使用 <code>SHOW INDEX</code> 语句。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SHOW</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=k>table_name</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=索引的优缺点>索引的优缺点</h3><p>优点：</p><ul><li>显著提高查询速度。</li><li>帮助维护数据的唯一性。</li><li>加快数据检索的效率。</li></ul><p>缺点：</p><ul><li>占用磁盘空间。</li><li>影响插入、更新和删除操作的速度（因为需要维护索引）。</li></ul><h3 id=索引的最佳实践>索引的最佳实践</h3><ol><li><strong>选择性高的列上创建索引</strong>：选择性越高，索引的效率越高。</li><li><strong>尽量避免在频繁更新的列上创建索引</strong>：减少索引维护开销。</li><li><strong>使用覆盖索引</strong>：创建包含所有查询列的复合索引，避免回表查询。</li><li><strong>定期维护索引</strong>：使用 <code>ANALYZE TABLE</code> 和 <code>OPTIMIZE TABLE</code> 进行索引维护。</li></ol><h3 id=创建索引的原则>创建索引的原则</h3><ol><li>最左前缀匹配原则，非常重要的原则，mysql 会一直向右匹配直到遇到范围查询(<code>></code>、<code>&lt;</code>、<code>between</code>、<code>like</code>)就停止匹配，比如 <code>a = 1 and b = 2 and c > 3 and d = 4</code> 如果建立(a, b, c, d)顺序的索引，d 是用不到索引的，如果建立(a, b, d, c)的索引则都可以用到，a, b, d 的顺序可以任意调整。</li><li>=和 in 可以乱序，比如 <code>a = 1 and b = 2 and c = 3</code> 建立(a, b, c)索引可以任意顺序，mysql 的查询优化器会帮你优化成索引可以识别的形式。</li><li>尽量选择区分度高的列作为索引，区分度的公式是 <code>count(distinct col)/count(\*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要 join 的字段我们都要求是 0.1 以上，即平均 1 条扫描 10 条记录。</li><li>索引列不能参与计算，保持列“干净”，比如 <code>from_unixtime(create_time) = '2014-05-29'</code> 就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成 <code>create_time = unix_timestamp('2014-05-29')</code>。</li><li>尽量的扩展索引，不要新建索引。比如表中已经有 a 的索引，现在要加(a, b)的索引，那么只需要修改原来的索引即可。</li></ol><h2 id=索引失效>索引失效</h2><p>在某些情况下，MySQL 的索引可能会失效，导致查询性能下降。以下是一些常见的索引失效的情况：</p><h3 id=条件不符合索引使用规则>条件不符合索引使用规则</h3><ol><li><p><strong>范围查询影响后续索引</strong>：</p><ul><li>当一个查询中使用了范围条件（如 <code>&lt;</code>, <code>></code>, <code>BETWEEN</code>, <code>LIKE</code> <code>'abc%'</code> 等）时，索引在范围条件之后的列将不会被使用。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=w> </span><span class=c1>-- 复合索引 idx_name_department(last_name, department_id)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=c1>-- 只会使用 last_name 的索引，department_id 不会被使用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=s1>&#39;Smith&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>department_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>函数操作导致索引失效</strong>：</p><ul><li>如果在查询条件中对索引列使用了函数或运算，索引会失效。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=w> </span><span class=c1>-- 索引不会被使用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>LEFT</span><span class=p>(</span><span class=n>last_name</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;Smi&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>数据类型不一致</strong>：</p><ul><li>查询条件中的数据类型与索引列的数据类型不一致时，索引可能失效。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=w> </span><span class=c1>-- 索引可能失效，因为 &#39;123&#39; 是字符串，而 id 是整数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;123&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=查询条件的组合问题>查询条件的组合问题</h3><ol><li><p><strong>OR 条件影响索引使用</strong>：</p><ul><li>当查询中使用 <code>OR</code> 条件时，如果 <code>OR</code> 条件中的每个部分都没有单独使用索引，则整个查询不会使用索引。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=w> </span><span class=c1>-- 索引不会被使用，除非 last_name 和 department_id 上都有单独的索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;Smith&#39;</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=n>department_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>不符合最左前缀原则</strong>：</p><ul><li>对于复合索引，查询条件必须包含索引的最左前缀，否则索引失效。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=w> </span><span class=c1>-- 复合索引 idx_name_department(last_name, department_id)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=c1>-- department_id 列不会单独使用索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>department_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=索引选择策略和优化器影响>索引选择策略和优化器影响</h3><ol><li><p><strong>小表全表扫描</strong>：</p><ul><li>对于数据量很小的表，MySQL 优化器可能选择全表扫描，而不是使用索引。</li></ul></li><li><p><strong>高选择性列上的索引</strong>：</p><ul><li>如果索引列的选择性不高（即列中的重复值很多），优化器可能会选择不使用索引。</li></ul></li><li><p><strong>统计信息不准确</strong>：</p><ul><li>当表的数据量变化较大时，索引的统计信息可能变得不准确，需要手动更新统计信息。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ANALYZE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>employees</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=其他影响索引使用的情况>其他影响索引使用的情况</h3><ol><li><p><strong>覆盖索引失效</strong>：</p><ul><li>如果查询的列无法被索引完全覆盖（即索引无法提供所有需要的列），则覆盖索引可能失效。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=w> </span><span class=c1>-- 如果 idx_name_department 只是 (last_name, department_id)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=c1>-- 而查询需要其他列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=k>SELECT</span><span class=w> </span><span class=n>first_name</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;Smith&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>department_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>前导模糊查询</strong>：</p><ul><li>使用前导通配符的模糊查询会导致索引失效。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 索引不会被使用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;%Smith&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=索引例子>索引例子</h3><p>下面是一些示例，展示了不同情况下索引的使用与失效：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 假设有一个复合索引 idx_name_department(last_name, department_id)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 索引有效
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;Smith&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>department_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 索引部分失效，仅 last_name 被使用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=s1>&#39;Smith&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>department_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 索引失效，因为使用了函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=k>LEFT</span><span class=p>(</span><span class=n>last_name</span><span class=p>,</span><span class=w> </span><span class=mi>3</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;Smi&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 索引失效，因为使用了前导通配符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=k>LIKE</span><span class=w> </span><span class=s1>&#39;%Smith&#39;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 索引失效，除非 last_name 和 department_id 上都有单独的索引
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>last_name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;Smith&#39;</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=n>department_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 索引失效，因为不符合最左前缀原则
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>department_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=锁>锁</h2><p>MySQL 锁是数据库管理系统（DBMS）中用于协调多个用户对数据库资源（如表、行）访问的一种机制。锁的主要作用是确保数据一致性和完整性，同时允许并发访问。以下是 MySQL 锁的一些关键概念和常见类型：</p><h3 id=锁的类型>锁的类型</h3><ol><li><p><strong>表级锁（Table Lock）</strong>：</p><ul><li><strong>读锁（共享锁，S 锁）</strong>：允许多个事务同时读取表中的数据，但任何事务在持有读锁时不能对表进行写操作。</li><li><strong>写锁（排他锁，X 锁）</strong>：独占锁，只有获得写锁的事务可以读取和修改表中的数据，其他事务不能读或写该表。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=w> </span><span class=c1>-- 加读锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=k>LOCK</span><span class=w> </span><span class=n>TABLES</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>READ</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>-- 加写锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=k>LOCK</span><span class=w> </span><span class=n>TABLES</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>WRITE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>-- 释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=n>UNLOCK</span><span class=w> </span><span class=n>TABLES</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>行级锁（Row Lock）</strong>：</p><ul><li><strong>共享锁（S 锁）</strong>：允许多个事务读取一行，但不能修改该行。</li><li><strong>排他锁（X 锁）</strong>：独占锁，获得排他锁的事务可以读取和修改该行，其他事务不能访问该行。</li></ul></li></ol><p>行级锁是通过 InnoDB 存储引擎实现的，用于提高并发性能。</p><h3 id=锁的粒度>锁的粒度</h3><ol><li><strong>表锁（Table Lock）</strong>：锁住整张表，适用于读多写少的场景，开销较小，但并发性较差。</li><li><strong>行锁（Row Lock）</strong>：锁住表中的某一行，适用于写操作频繁的场景，开销较大，但并发性较好。</li></ol><h3 id=锁的机制>锁的机制</h3><ol><li><strong>自动锁定</strong>：<ul><li>InnoDB 存储引擎会在执行 DML 操作（如 SELECT, INSERT, UPDATE, DELETE）时自动加锁。</li><li>事务开始时，InnoDB 会自动加上必要的锁，并在事务提交或回滚时释放锁。</li></ul></li><li><strong>显式锁定</strong>：<ul><li>开发者可以使用显式锁定语句来控制锁的行为，适用于需要精细控制锁的场景。</li></ul></li></ol><h3 id=死锁>死锁</h3><ol><li><strong>死锁的定义</strong>：<ul><li>当两个或多个事务相互持有对方所需要的资源并等待对方释放，导致无法继续执行的情况称为死锁。</li></ul></li><li><strong>死锁检测和处理</strong>：<ul><li>InnoDB 存储引擎有内置的死锁检测机制，会自动检测并处理死锁，通过回滚其中一个事务来解除死锁。</li></ul></li></ol><h3 id=常用锁相关语句>常用锁相关语句</h3><ol><li><p><strong>加锁和解锁</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 加读锁（共享锁）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>LOCK</span><span class=w> </span><span class=n>TABLES</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>READ</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 加写锁（排他锁）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>LOCK</span><span class=w> </span><span class=n>TABLES</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>WRITE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 解锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>UNLOCK</span><span class=w> </span><span class=n>TABLES</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>事务和锁</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 开始事务
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 提交事务并释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 回滚事务并释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ROLLBACK</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li><li><p><strong>查看锁信息</strong>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 查看当前锁信息
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SHOW</span><span class=w> </span><span class=n>ENGINE</span><span class=w> </span><span class=n>INNODB</span><span class=w> </span><span class=n>STATUS</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></li></ol><h3 id=锁的最佳实践>锁的最佳实践</h3><ol><li><strong>尽量使用 InnoDB 存储引擎</strong>：因为 InnoDB 支持行级锁，有更高的并发性能和更强的事务支持。</li><li><strong>控制事务大小</strong>：尽量减少单个事务中的操作数量和时间，避免长事务导致锁定时间过长。</li><li><strong>合适的索引</strong>：确保查询使用合适的索引，以减少锁定的行数，提高锁的效率。</li><li><strong>显式锁定</strong>：在必要时使用显式锁定，但要注意控制锁的粒度和范围，以平衡并发性和一致性。</li><li><strong>死锁重试机制</strong>：在应用程序中实现死锁重试机制，以应对偶发的死锁情况。</li></ol><h3 id=锁例子>锁例子</h3><p>下面是一些例子，展示了 MySQL 锁的使用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 1. 显式表锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>LOCK</span><span class=w> </span><span class=n>TABLES</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>READ</span><span class=p>;</span><span class=w> </span><span class=c1>-- 加读锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>UNLOCK</span><span class=w> </span><span class=n>TABLES</span><span class=p>;</span><span class=w> </span><span class=c1>-- 解锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 2. 使用事务和行级锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w> </span><span class=c1>-- 加排他锁
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>UPDATE</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1000</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 3. 死锁重试机制
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>DELIMITER</span><span class=w> </span><span class=o>//</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>PROCEDURE</span><span class=w> </span><span class=n>update_salary</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>BEGIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>DECLARE</span><span class=w> </span><span class=n>retry_count</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>DECLARE</span><span class=w> </span><span class=n>EXIT</span><span class=w> </span><span class=k>HANDLER</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>SQLEXCEPTION</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>BEGIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>SET</span><span class=w> </span><span class=n>retry_count</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>retry_count</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>IF</span><span class=w> </span><span class=n>retry_count</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=k>THEN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>ROLLBACK</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>RESIGNAL</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>ELSE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>ROLLBACK</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>END</span><span class=w> </span><span class=k>IF</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>END</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>START</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>UPDATE</span><span class=w> </span><span class=n>employees</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>salary</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1000</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>END</span><span class=w> </span><span class=o>//</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>DELIMITER</span><span class=w> </span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=事务>事务</h2><h3 id=事务的四大特征>事务的四大特征</h3><ol><li><strong>原子性（Atomicity）</strong>：事务里的内容要么全部成功要么都不成功。</li><li><strong>一致性（Consistency）</strong>：事务前后数据的完整性保持一致，如：a 给 b 转一千块，事务执行以后，a 和 b 的钱总数是一样的。</li><li><strong>隔离性（Isolation）</strong>：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</li><li><strong>持久性（Durability）</strong>：事务结束，数据就持久化到数据库。</li></ol><h3 id=并发事务问题>并发事务问题</h3><ol><li><strong>脏读 (Dirty Read)</strong>
脏读发生在一个事务能够读取另一个事务尚未提交的数据时。如果第二个事务回滚（撤销）了这些更改，那么第一个事务读取到的数据就变得无效或“脏”了。脏读仅在最低的隔离级别“读未提交”（Read Uncommitted）下会发生。
<strong>示例</strong>：<ul><li>事务 A 更新了一行数据，但未提交。</li><li>事务 B 读取了这个更新的数据。</li><li>事务 A 回滚了更新。</li><li>事务 B 读取到的数据现在无效，因为事务 A 的更改没有最终被提交。</li></ul></li><li><strong>不可重复读 (Non-Repeatable Read)</strong>
不可重复读问题出现在一个事务在两次读取同一数据时，数据发生了变化。这种情况通常发生在隔离级别“读已提交”（Read Committed）下。
<strong>示例</strong>：<ul><li>事务 A 读取了一行数据。</li><li>事务 B 更新了该行数据并提交。</li><li>事务 A 再次读取同一行数据，发现数据已经发生变化。</li></ul></li><li><strong>幻读 (Phantom Read)</strong>
幻读问题发生在一个事务执行两次相同的查询，但第二次查询返回的结果集包含了第一次查询时不存在的“幻影”行。这种情况通常发生在隔离级别“可重复读”（Repeatable Read）下，但可以在“串行化”（Serializable）级别避免。
<strong>示例</strong>：<ul><li>事务 A 读取符合某个条件的多行数据。</li><li>事务 B 插入了几行满足事务 A 查询条件的新数据并提交。</li><li>事务 A 再次执行相同的查询，发现结果集中包含了新插入的行。</li></ul></li></ol><h3 id=四种标准的事务隔离级别>四种标准的事务隔离级别</h3><p>在 MySQL 中，事务隔离级别定义了一个事务在读取数据时与其他并发事务的交互方式。</p><ol><li><strong>读未提交 (Read Uncommitted)</strong>：在这个级别，事务可以读取其他事务未提交的数据。允许脏读、不可重复读和幻读。</li><li><strong>读已提交 (Read Committed)</strong>：在这个级别，事务只能读取已经提交的数据。防止脏读，但允许不可重复读和幻读。</li><li><strong>可重复读 (Repeatable Read)</strong>：在这个级别，一个事务在开始时看到的数据一致，即使其他事务在该事务执行过程中提交了数据。MySQL 的默认隔离级别是可重复读。防止脏读和不可重复读，但可能允许幻读。</li><li><strong>串行化 (Serializable)</strong>：在这个级别，所有事务按顺序执行，完全避免并发问题。这会使系统性能下降，但可以避免“脏读”、“不可重复读”和“幻读”。</li></ol><p>各个隔离级别之间的关系如下：</p><blockquote><p>读未提交 &lt; 读已提交 &lt; 可重复读 &lt; 串行化</p></blockquote><p>MySQL 的默认事务隔离级别是“可重复读”，可以通过以下 SQL 命令查看和设置当前的隔离级别：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>-- 查看当前会话的隔离级别
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>@@</span><span class=n>tx_isolation</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 设置当前会话的隔离级别
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SET</span><span class=w> </span><span class=k>SESSION</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>REPEATABLE</span><span class=w> </span><span class=k>READ</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 查看全局隔离级别
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SELECT</span><span class=w> </span><span class=o>@@</span><span class=k>global</span><span class=p>.</span><span class=n>tx_isolation</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 设置全局隔离级别
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>SET</span><span class=w> </span><span class=k>GLOBAL</span><span class=w> </span><span class=k>TRANSACTION</span><span class=w> </span><span class=k>ISOLATION</span><span class=w> </span><span class=k>LEVEL</span><span class=w> </span><span class=k>REPEATABLE</span><span class=w> </span><span class=k>READ</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Spring Boot 中可以通过使用 @Transactional 注解指定某个方法的隔离级别。</p><p>如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span><span class=w> </span><span class=nn>org.springframework.transaction.annotation.Isolation</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kn>import</span><span class=w> </span><span class=nn>org.springframework.transaction.annotation.Transactional</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Service</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>YourService</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Transactional</span><span class=p>(</span><span class=n>isolation</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Isolation</span><span class=p>.</span><span class=na>READ_COMMITTED</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>yourTransactionalMethod</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// your transactional code</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>在这个例子中，<code>yourTransactionalMethod</code> 方法的事务隔离级别被设置为 <code>READ_COMMITTED</code>。</p><p>Spring 提供的隔离级别枚举如下，对应于标准的 SQL 隔离级别：</p><ul><li><strong>Isolation.DEFAULT</strong>：使用底层数据库的默认隔离级别。</li><li><strong>Isolation.READ_UNCOMMITTED</strong>：读未提交。</li><li><strong>Isolation.READ_COMMITTED</strong>：读已提交。</li><li><strong>Isolation.REPEATABLE_READ</strong>：可重复读。</li><li><strong>Isolation.SERIALIZABLE</strong>：串行化。</li></ul><h3 id=乐悲观锁>乐(悲)观锁</h3><h4 id=乐观锁-optimistic-lock>乐观锁 (Optimistic Lock)</h4><p><strong>概念：</strong></p><p>乐观锁假设数据在并发环境下很少发生冲突，因此在操作数据时不加锁。乐观锁在提交更新时检查数据是否被其他事务修改，如果数据被修改，则回滚当前事务。</p><p><strong>特点：</strong></p><ul><li><strong>无锁操作</strong>：在读取数据时不加锁，只在提交更新时检查冲突。</li><li><strong>冲突检测</strong>：通过比较版本号或时间戳来检测数据是否被修改。</li><li><strong>性能较高</strong>：由于没有频繁的加锁和解锁操作，系统性能较高。</li></ul><p>适用场景：</p><ul><li>数据争用不严重的场景。</li><li>读操作多于写操作的场景。</li><li>对性能要求较高的场景。</li></ul><p><strong>实现方式：</strong></p><p>乐观锁通常使用版本号或时间戳机制。例如，在数据库表中添加一个 <code>version</code> 字段，每次更新时检查并递增版本号。以下是一个示例：</p><p>假设有一个 <code>accounts</code> 表：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>id</span><span class=w> </span><span class=nb>INT</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>balance</span><span class=w> </span><span class=nb>DECIMAL</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=w> </span><span class=mi>2</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>version</span><span class=w> </span><span class=nb>INT</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>更新操作：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>balance</span><span class=p>,</span><span class=w> </span><span class=k>version</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/* Perform some business logic, e.g., balance += 100 */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>UPDATE</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>balance</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>100</span><span class=p>,</span><span class=w> </span><span class=k>version</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>version</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=k>version</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>old_version</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>在更新时，检查 version 是否与读取时一致，如果不一致则更新失败，可以通过应用逻辑重试或报错处理。</p><h4 id=悲观锁-pessimistic-lock>悲观锁 (Pessimistic Lock)</h4><p><strong>概念：</strong></p><p>悲观锁假设数据在并发环境下会发生冲突，因此在操作数据之前会锁定资源，以防止其他事务对数据进行修改。悲观锁通常依赖于数据库的锁机制。</p><p><strong>特点：</strong></p><ul><li><strong>加锁强度高</strong>：在读取或写入数据之前，先对数据进行加锁，确保在事务结束之前，其他事务不能对数据进行操作。</li><li><strong>阻塞性</strong>：如果一个事务对数据加了悲观锁，其他尝试访问该数据的事务会被阻塞，直到锁被释放。</li><li><strong>开销大</strong>：由于频繁的加锁和解锁操作，会增加系统开销，影响性能。</li></ul><p><strong>适用场景：</strong></p><ul><li>数据争用严重的场景。</li><li>写操作频繁的场景。</li><li>对数据一致性要求极高的场景。</li></ul><p><strong>实现方式：</strong></p><p>在 SQL 中可以使用 <code>SELECT ... FOR UPDATE</code> 来实现悲观锁。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>BEGIN</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>accounts</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=k>UPDATE</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/* Perform updates */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>COMMIT</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=乐悲观锁总结>乐(悲)观锁总结</h4><ul><li><strong>悲观锁</strong>：通过加锁确保数据一致性，适用于高争用环境，但性能开销较大。</li><li><strong>乐观锁</strong>：通过版本控制或时间戳检测数据冲突，适用于低争用环境，性能较好，但需要处理冲突。</li></ul><p>选择使用哪种锁机制，应根据具体应用的并发情况、数据访问模式和性能需求来决定。</p><h3 id=mvcc多版本并发控制>MVCC（多版本并发控制）</h3><p>多版本并发控制 (MVCC, Multi-Version Concurrency Control) 是一种用于数据库管理系统的并发控制机制，它允许多个事务并发地执行而不会互相阻塞，同时提供一致的读和写操作。MVCC 通过维护数据的多个版本来实现，避免了许多传统锁机制带来的性能开销。</p><h4 id=mvcc-的工作原理>MVCC 的工作原理</h4><p>MVCC 通过为每个数据项保存多个版本，并为每个事务分配一个唯一的时间戳或事务 ID (Transaction ID, TID)，来管理并发事务。以下是 MVCC 的主要工作原理：</p><ol><li><strong>版本链</strong>：
每个数据项都有一个版本链，链中包含该数据项的所有历史版本。每个版本包含数据值和相关的元数据（如创建时间戳和删除时间戳）。</li><li><strong>读取操作</strong>：
当事务读取数据时，它会查找与自己的时间戳匹配的最新版本。这意味着事务只会看到在其开始之前已经提交的版本，不会被其他并发事务未提交的修改所影响。</li><li><strong>写入操作</strong>：
当事务修改数据时，它不会覆盖现有版本，而是创建一个新版本，并将其添加到版本链中。新版本会带有事务的时间戳，表明它是由该事务创建的。</li><li><strong>提交和回滚</strong>：
当事务提交时，创建的新版本会成为可见版本。如果事务回滚，创建的新版本会被标记为无效，不会影响其他事务。</li></ol><h4 id=mvcc-的优点>MVCC 的优点</h4><ol><li><strong>减少锁竞争</strong>：
由于读操作不会阻塞写操作，写操作也不会阻塞读操作，MVCC 有效地减少了锁竞争，提高了系统的并发性能。</li><li><strong>一致性读取</strong>：
事务在读取数据时，总是能够看到一致的视图，不会被其他并发事务的未提交修改所影响，避免了脏读。</li><li><strong>提升性能</strong>：
由于读操作不需要加锁，系统的读性能得到显著提升。写操作创建新版本而不是覆盖旧版本，也提高了写操作的效率。</li></ol><h4 id=mvcc-处理的并发问题>MVCC 处理的并发问题</h4><ol><li><strong>避免脏读</strong>：
读操作只看到已经提交的数据版本，因此避免了读取未提交数据带来的脏读问题。</li><li><strong>避免不可重复读</strong>：
事务在读取同一数据项时，总是能够看到一致的版本，避免了同一事务中多次读取到不同数据的问题。</li><li><strong>幻读</strong>：
MVCC 在某些数据库系统中可以避免幻读问题。通过使用 MVCC 和合适的隔离级别（如可重复读或串行化），可以确保查询结果集的一致性。</li></ol><h4 id=mvcc-的实现>MVCC 的实现</h4><p>不同数据库系统对 MVCC 的实现有所不同。以下是几种流行数据库的 MVCC 实现方式：</p><ol><li><strong>PostgreSQL</strong>：
PostgreSQL 使用事务 ID (XID) 和隐藏字段来实现 MVCC。每个数据行都有两个隐藏字段，分别表示创建该行的事务 ID 和删除该行的事务 ID。</li><li><strong>MySQL (InnoDB 存储引擎)</strong>：
InnoDB 使用 undo log 和事务 ID 来实现 MVCC。每个数据行都有一个隐藏的事务 ID 和回滚指针，用于指向前一个版本的数据。</li><li><strong>Oracle</strong>：
Oracle 使用回滚段来存储旧版本的数据，当需要读取旧版本时，通过回滚段获取数据的历史版本。</li></ol><h4 id=mvcc-总结>MVCC 总结</h4><p>MVCC 是一种强大的并发控制机制，通过维护数据的多个版本，实现高效的并发事务处理。它有效地减少了锁竞争，提高了系统的性能和一致性，是现代数据库系统中广泛应用的技术。</p><h2 id=explain>EXPLAIN</h2><p><code>EXPLAIN</code> 是 MySQL 提供的一种分析工具，用于查看 SQL 查询的执行计划。它显示了查询优化器是如何执行 SQL 语句的，帮助开发人员优化查询性能。以下是 <code>EXPLAIN</code> 的用法和解释。</p><h3 id=基本用法>基本用法</h3><p><code>EXPLAIN SELECT * FROM table_name WHERE condition;</code></p><p><code>EXPLAIN</code> 会显示查询的执行计划，包括使用的索引、连接类型、扫描的行数等。</p><h3 id=输出列的含义>输出列的含义</h3><p>执行 <code>EXPLAIN</code> 后，结果集包含多个列，每一列都有特定的含义：</p><ol><li><p><strong>id</strong>：查询的标识符。每个 <code>SELECT</code> 子句或子查询都会分配一个唯一的 <code>id</code>。</p></li><li><p><strong>select_type</strong>：查询的类型。常见类型包括：</p><ul><li><code>SIMPLE</code>：简单的 SELECT 查询，不包含子查询或 UNION。</li><li><code>PRIMARY</code>：最外层的 SELECT 查询。</li><li><code>SUBQUERY</code>：子查询中的 SELECT。</li><li><code>DERIVED</code>：派生表（子查询中的 FROM 子句）。</li><li><code>UNION</code>：UNION 中的第二个或后续的 SELECT 查询。</li><li><code>UNION RESULT</code>：UNION 的结果集。</li></ul></li><li><p><strong>table</strong>：查询的表。</p></li><li><p><strong>partitions</strong>：查询涉及的分区（如果有）。</p></li><li><p><strong>type</strong>：连接类型，表示查询中的表如何连接。连接类型的效率从高到低依次为：</p><ul><li><code>system</code>：表只有一行（系统表）。</li><li><code>const</code>：表最多只有一行匹配（常量）。</li><li><code>eq_ref</code>：对于每个来自前一个表的行，读取一行。</li><li><code>ref</code>：对于每个来自前一个表的行，读取匹配几行。</li><li><code>range</code>：只检索给定范围的行，使用索引选择行。</li><li><code>index</code>：全索引扫描。</li><li><code>ALL</code>：全表扫描。</li></ul></li><li><p><strong>possible_keys</strong>：查询中可能使用的索引。</p></li><li><p><strong>key</strong>：查询实际使用的索引。</p></li><li><p><strong>key_len</strong>：使用的索引的长度。</p></li><li><p><strong>ref</strong>：使用的列或常量与索引比较。</p></li><li><p><strong>rows</strong>：MySQL 估计要读取的行数。</p></li><li><p><strong>filtered</strong>：查询条件过滤的行的百分比。</p></li><li><p><strong>Extra</strong>：其他信息，比如：</p><ul><li><code>Using index</code>：查询使用了覆盖索引。</li><li><code>Using where</code>：查询使用了 WHERE 子句来过滤行。</li><li><code>Using temporary</code>：查询使用了临时表。</li><li><code>Using filesort</code>：查询使用了文件排序。</li></ul></li></ol><h3 id=示例分析>示例分析</h3><h4 id=简单查询>简单查询</h4><p><code>EXPLAIN SELECT * FROM employees WHERE id = 1;</code></p><p>结果可能显示：</p><div class=table-wrapper><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>employees</td><td>const</td><td>PRIMARY</td><td>PRIMARY</td><td>4</td><td>const</td><td>1</td><td>100.00</td><td>Using where</td></tr></tbody></table></div><p>解释：</p><ul><li><code>id</code> 为 1，表示这是一个简单查询。</li><li><code>select_type</code> 为 <code>SIMPLE</code>，没有子查询。</li><li><code>table</code> 为 <code>employees</code>，表示查询的表。</li><li><code>type</code> 为 <code>const</code>，因为 <code>id</code> 是主键，这是一个常量查询。</li><li><code>possible_keys</code> 和 <code>key</code> 都是 <code>PRIMARY</code>，表示使用了主键索引。</li><li><code>rows</code> 为 1，表示预计扫描一行。</li><li><code>Extra</code> 为 <code>Using where</code>，表示使用了 WHERE 子句。</li></ul><h4 id=连接查询>连接查询</h4><p><code>EXPLAIN SELECT e.*, d.dept_name FROM employees e JOIN departments d ON e.dept_id = d.dept_id;</code></p><p>结果可能显示：</p><div class=table-wrapper><table><thead><tr><th>id</th><th>select_type</th><th>table</th><th>type</th><th>possible_keys</th><th>key</th><th>key_len</th><th>ref</th><th>rows</th><th>filtered</th><th>Extra</th></tr></thead><tbody><tr><td>1</td><td>SIMPLE</td><td>d</td><td>ALL</td><td>PRIMARY</td><td>NULL</td><td>NULL</td><td>NULL</td><td>10</td><td>100.00</td><td></td></tr><tr><td>1</td><td>SIMPLE</td><td>e</td><td>ref</td><td>dept_id</td><td>dept_id</td><td>4</td><td>d.dept_id</td><td>100</td><td>100.00</td><td>Using where</td></tr></tbody></table></div><p>解释：</p><ul><li>第一个 <code>id</code> 为 1 的行表示对 <code>departments</code> 表的全表扫描（type 为 <code>ALL</code>）。</li><li>第二个 <code>id</code> 为 1 的行表示对 <code>employees</code> 表的引用（type 为 <code>ref</code>），使用了 <code>dept_id</code> 索引。</li><li><code>rows</code> 列表明 MySQL 预计从 <code>departments</code> 表中读取 10 行，并从 <code>employees</code> 表中读取 100 行。</li></ul><h3 id=优化建议>优化建议</h3><ol><li><strong>使用合适的索引</strong>：确保查询中使用了合适的索引，以减少扫描的行数。</li><li><strong>避免全表扫描</strong>：尽量避免 <code>type</code> 为 <code>ALL</code> 的全表扫描，可以通过增加索引来优化。</li><li><strong>优化连接类型</strong>：尽量使用效率较高的连接类型，如 <code>ref</code>、<code>eq_ref</code> 等。</li><li><strong>减少临时表和文件排序</strong>：避免 <code>Extra</code> 列中出现 <code>Using temporary</code> 和 <code>Using filesort</code>，可以通过优化查询或增加索引来实现。</li></ol><p>通过合理使用 <code>EXPLAIN</code> 分析查询执行计划，可以发现查询性能的瓶颈，并进行相应的优化。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/database/>Database</a>
<a href=/tags/mysql/>MySQL</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/completable-future/><div class=article-details><h2 class=article-title>CompletableFuture</h2></div></a></article><article><a href=/post/rabbitmq/><div class=article-details><h2 class=article-title>RabbitMQ</h2></div></a></article><article><a href=/post/spring-boot/><div class=article-details><h2 class=article-title>Spring Boot</h2></div></a></article><article><a href=/post/distributed-lock/><div class=article-details><h2 class=article-title>分布式锁</h2></div></a></article><article><a href=/post/thread-pool/><div class=article-details><h2 class=article-title>Java 线程池</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 Lucas's Article</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>